import{s as Z,N as dr,D as an,a as Bn,b as oa,c as aa,d as ra,e as sa,C as _e,T as Wn,f as rn,R as $n,W as Yt,M as sn,g as cn,L as ia,h as Se,G as X,i as Q,j as ur,k as W,l as ca,m as pr,n as la,o as da,p as ua,q as ae,r as ze,V as gt,A as Fe,t as Jn,u as tt,v as Ht,P as ne,w as pa,x as mr,y as Ae,z as ge,B as Ne,E as gr,F as Qe,H as Bt,I as ht,J as Pe,K as ft,O as yt,Q as vt,S as Wt,U as $t,X as Mn,Y as kn,Z as Ln,_ as Dn,$ as hr,a0 as Kn,a1 as fr,a2 as yr,a3 as vr,a4 as qn,a5 as wr,a6 as Ir,a7 as mo,a8 as He,a9 as bn,aa as De,ab as go,ac as _n,ad as ma,ae as Tn,af as Nr,ag as ho,ah as Ve,ai as br,aj as Tr,ak as Sr,al as Ar,am as dt,an as ut,ao as Rn,ap as Mt,aq as On,ar as Ft}from"./debug-D6S6VXZ8.js";import{r as b,o as Cr}from"./vendor-BcNuLXi4.js";import{G as ga}from"./gemini-C8vQU6I3.js";import{i as Er,m as Pr,a as $r,b as Mr,k as kr}from"./resources-CXWwAOhL.js";let pt=null;const kt=[],Lr=e=>{e===null?setTimeout(()=>{pt=null,kt.forEach(t=>{t(pt)})},0):(pt=e,kt.forEach(t=>{t(pt)}))},Dr=e=>{kt.push(e),e(pt)},_r=e=>{const t=kt.indexOf(e);t!==-1&&kt.splice(t,1)},Rr=()=>pt,Or=()=>{const[e,t]=b.useState(Rr());return b.useEffect(()=>(Dr(t),()=>{_r(t)}),[]),e},ha=140,zn=10,Qn=.15,Yl=(e,t)=>{if(e.length===0)return[];const n=new Map(e.map(m=>[m.id,Z(m)])),o=new Map;n.forEach(m=>{const g=m.data.parentNodeId&&m.data.parentNodeId!=="Universe"?m.data.parentNodeId:void 0;if(g){o.has(g)||o.set(g,[]);const h=o.get(g);h&&h.push(m.id)}});const a=dr,r=(t==null?void 0:t.padding)??zn,s=(t==null?void 0:t.anglePadding)??Qn,i=2,c=m=>{const g=n.get(m);if(!g)throw new Error(`Node ${m} missing in layout`);const h=o.get(m)??[],v=s/Math.max(1,Math.sqrt(h.length));if(h.length===0)return g.data.visualRadius=a,g.position={x:0,y:0},g.data.visualRadius;if(h.forEach(w=>c(w)),h.length===1){const w=n.get(h[0]);if(!w)throw new Error("Child node missing");return w.position={x:0,y:0},g.data.visualRadius=(w.data.visualRadius??a)+r,g.position={x:0,y:0},g.data.visualRadius}const f=h.map(w=>{const N=n.get(w);if(!N)throw new Error("Child node missing");return N}).sort((w,N)=>(N.data.visualRadius??a)-(w.data.visualRadius??a));let I=Math.max(...f.map(w=>w.data.visualRadius??a))+r;for(;;){let w=0;for(let N=0;N<f.length;N++){const L=f[N].data.visualRadius??a,D=f[(N+1)%f.length].data.visualRadius??a,x=(L+D+r)/(2*I);if(x>1){w=2*Math.PI+1;break}w+=2*Math.asin(x)+v}if(w<=2*Math.PI)break;I+=i}let T=0;for(let w=0;w<f.length;w++){const N=f[w].data.visualRadius??a,L=f[(w+1)%f.length].data.visualRadius??a;T+=2*Math.asin((N+L+r)/(2*I))+v}let k=Math.max(0,(2*Math.PI-T)/2);for(let w=0;w<f.length;w++){const N=f[w],L=N.data.visualRadius??a;N.position={x:I*Math.cos(k),y:I*Math.sin(k)};const D=f[(w+1)%f.length].data.visualRadius??a;k+=2*Math.asin((L+D+r)/(2*I))+v}let y=1/0,P=-1/0,S=1/0,C=-1/0;f.forEach(w=>{const N=w.data.visualRadius??a;y=Math.min(y,w.position.x-N),P=Math.max(P,w.position.x+N),S=Math.min(S,w.position.y-N),C=Math.max(C,w.position.y+N)});const $=(y+P)/2,M=(S+C)/2;f.forEach(w=>{w.position.x-=$,w.position.y-=M});const A=Math.max(...f.map(w=>{const N=w.data.visualRadius??a;return Math.hypot(w.position.x,w.position.y)+N}))+r;return g.data.visualRadius=A,g.position={x:0,y:0},g.data.visualRadius},l=Array.from(n.values()).filter(m=>!m.data.parentNodeId||m.data.parentNodeId==="Universe").map(m=>m.id),d="__root__";o.set(d,l);const p={id:d,placeName:"root",position:{x:0,y:0},data:{description:"root",nodeType:"region",status:"discovered"}};n.set(d,p),c(d);const u=(m,g,h)=>{const v=n.get(m);if(!v)throw new Error(`Node ${m} missing in offset application`);m!==d&&(v.position={x:v.position.x+g,y:v.position.y+h}),(o.get(m)??[]).forEach(I=>{u(I,v.position.x,v.position.y)})};return u(d,0,0),n.delete(d),Array.from(n.values())},xr=()=>({IDEAL_EDGE_LENGTH:ha,NESTED_PADDING:zn,NESTED_ANGLE_PADDING:Qn,LABEL_MARGIN_PX:sa,LABEL_LINE_HEIGHT_EM:ra,LABEL_OVERLAP_MARGIN_PX:aa,ITEM_ICON_SCALE:oa}),Jt=()=>({saveGameVersion:_e,currentTheme:null,currentScene:"",mainQuest:null,currentObjective:null,actionOptions:[],inventory:[],playerJournal:[],lastJournalWriteTurn:0,lastJournalInspectTurn:0,lastLoreDistillTurn:0,gameLog:[],lastActionLog:null,themeFacts:[],worldFacts:null,heroSheet:null,heroBackstory:null,storyArc:null,allNPCs:[],mapData:{nodes:[],edges:[]},currentMapNodeId:null,destinationNodeId:null,mapLayoutConfig:xr(),mapViewBox:Bn,score:0,localTime:"Unknown",localEnvironment:"Unknown",localPlace:"Unknown",globalTurnNumber:0,dialogueState:null,isVictory:!1,objectiveAnimationType:null,lastDebugPacket:null,lastTurnChanges:null,enabledThemePacks:[...an],thinkingEffort:"Medium",debugLore:!1,debugGoodFacts:[],debugBadFacts:[]}),Sn=e=>{const t=Jt();return t.enabledThemePacks=[...e],t},Ur=`You are an AI assistant guiding a dialogue turn in a text-based adventure game. The player is in conversation with one or more NPCs. Your role is to:
1. Generate responses for the NPC(s) involved in the dialogue.
2. Provide from 4 to 8 first-person dialogue options for the player. The last option MUST be a way for the player to end the dialogue (e.g., "I should get going.", "That's all I needed to know.", "Let's talk another time.").
3. Optionally, indicate if the dialogue is ending from the NPC's side or if the list of participants changes.
4. Optionally add or remove participants of the dialogue, based on context.

Respond ONLY in JSON format with the following structure:
{
  "npcResponses": [ /* Include one entry for each NPC who may speaks this turn. It can be one or multiple NPCs. Speaker MUST be one of the current dialogue participants. Lines must be non-empty. */
    { "speaker": "NPCName1", "line": "What NPCName1 says this turn." }, /* REQUIRED. */
    { "speaker": "NPCName2", "line": "What NPCName2 says this turn, if they speak at all." }, /* Optional line from another Participant NPC. */
    ...
  ],
  "playerOptions": [ /* up to 8 total options */
    "Player's first dialogue choice (phrased in first-person, as if player is speaking, non-empty).",
    "Player's second dialogue choice.",
    ...
    "An AI-generated phrase for the player to end the dialogue (e.g., "Thanks, I'll be on my way.", "Enough! I don't want to talk to you."). This MUST be the last option."
  ],
  "dialogueEnds"?: boolean, /* Optional. Set to true if the NPC(s) clearly signal the end of the conversation, or if the conversation obviously reached its logical end. */
  "updatedParticipants"?: ["NPCName1", "NewNPCJoining", ...] /* Optional. Cannot be empty. Provide the new full list of participants if someone joins or leaves the conversation. If omitted, participants remain the same. DO NOT add Player's Character to the list. */
}

Instructions:
- NPC responses should be in-character, first-person responses, relevant to the ongoing dialogue and Narrator THOUGHTS guidance.
- CRITICALLY IMPORTANT: NPCs are not aware of the Narrator THOUGHTS, so they should NEVER reference the Narrator in their dialogue.
- Player options should be natural, first-person phrases. Ensure variety and meaningful choices.
- The LAST player option must always be a contextually appropriate way for the player to signal they wish to end the conversation.
- If the Player's latest response is a polite hint that the conversation is over, provide the final NPC responses and set "dialogueEnds" true.
- If "updatedParticipants" is provided, the dialogue continues with the new set of participants.
- Maintain thematic consistency based on the theme name and modifier provided in the prompt.
- Consider the player's gender subtly if it makes sense for the interactions, but don't make it overt.
`,fa=`Valid item "type" values are: ${$n}.
- "single-use": Consumed after one use (e.g., potion, one-shot scroll, stimpak, medicine pill, spare part). Assumed to be stored in player's pockets/bag/backpack. Excludes any written material. Cannot be worn on a person directly.
- "multi-use": Can be used multiple times (e.g., lockpick set, toolkit, medkit). Can have limited number of uses, indicated in brackets after the name, or in the description. Assumed to be stored in player's pockets/bag/backpack. Cannot be worn on a person directly.
- "equipment": Can be worn on a person, or wielded (e.g., armor, shield, helmet, lantern, flashlight, crowbar). Can have active/inactive states.
- "container": Can hold things. Describe if empty/full, intended contents (solid, liquid, gas), e.g., "Empty Canteen", "Flask of Oil". Use 'update' to change its description/state (e.g., from empty to full). Full conainer can provide a number of uses until it is empty again (can drink from full bottle several times).
- "key": Unlocks specific doors, chests, portals, or similar. Description should hint at its purpose, e.g., "Ornate Silver Key (for a large chest)". Can be 'lost' or 'updated' (e.g., to "Bent Key") after use.
- "weapon": Melee and ranged weapons, distinct from "equipment" Items that can be explicitly used in a fight when wielded. Ranged weapon consume ammunition or charges.
- "ammunition": For reloading specific ranged weapons, e.g., Arrows for Longbow, Rounds for firearms, Charges for energy weapons. Using weapon consumes ammo (handled by log/update).
- "vehicle": Player's current transport (if isActive: true) or one they can enter if adjacent to it. Integral parts (mounted guns, cargo bays) are 'knownUses', NOT separate items unless detached. If player enters a vehicle, note in "playerItemsHint" that it becomes active. If they exit, note that it becomes inactive. Include the vehicle in "newItems" only when first introduced.
- "immovable": Built-in or heavy feature at a location (e.g., control panel or machinery). Cannot be moved or stored. Interact using known uses or generic attempts.
- "status effect": Temporary condition, positive or negative, generally gained and lost by eating, drinking, environmental exposure, impacts, and wounds. 'isActive: true' while affecting player. 'description' explains its effect, e.g., "Poisoned (move slower)", "Blessed (higher luck)", "Wounded (needs healing)". 'lost' when it expires.`,ya=`Written item types (${Yt}):
  - "page": Single sheet, scroll, or a digital device that can display some static text. Follows the same structure as a one-chapter "book". Always provide a numeric "contentLength" for the page text.
  - "book": Multi-page text with "chapters", paper-based or digital. Each chapter MUST have {"heading", "description", "contentLength"}.
  - "picture": Single image such as a photograph, drawing, or painting. Use ONE chapter to describe what the image portrays in detail.
  - "map": Hand-drawn or printed diagram showing terrain, directions, floor plan, or schematic. Use ONE chapter to describe the layout and any notable markings.`,jr=`${fa}
${ya}`,Fr=`Generate inventory hints using these fields:
- "playerItemsHint": short summary of gains, losses or state changes for the Player.
- "worldItemsHint": short summary of items dropped or discovered in the environment.
- "npcItemsHint": short summary of items held or used by NPCs.
- "librarianHint": short summary for written items (pages, books, pictures, maps). Do not mention the same items in playerItemsHint, worldItemsHint, or npcItemsHint if it is written items.
- "newItems": array of brand new items (including written items) introduced this turn, or [] if none.

## Examples illustrating the hint style:

### Example of creating a *new* item "Old Lantern" and placing it in player's inventory. Because "Old Lantern" is included in newItems, it means the item is not already present in the scene:
playerItemsHint: "Picked up Old Lantern."
newItems:
[
  {
    "activeDescription": "The lantern is lit and casts a warm glow.",
    "description": "A dusty old lantern that still flickers faintly.",
    "isActive": false,
    "knownUses": [
      {
        "actionName": "Light the Lantern",
        "appliesWhenInactive": true,
        "description": "Use this to light your way in dark places.",
        "promptEffect": "Light the lantern to illuminate the area."
      },
      {
        "actionName": "Extinguish the Lantern",
        "appliesWhenActive": true,
        "description": "Extinguish the lantern and conserve fuel.",
        "promptEffect": "Extinguish the lantern."
      }
    ],
    "name": "Old Lantern",
    "type": "equipment"
  }
]

### Example for creating a *new* item "Rusty Key" inside npc_guard_4f3a inventory:
npcItemsHint: "Guard now carries a Rusty Key."
newItems:
[
  {
    "description": "A key for the armory door.",
    "holderId": "npc_guard_4f3a",
    "name": "Rusty Key",
    "type": "key"
  }
]

### Example of creating a *new* 'page' written item and placing it in player's inventory (same structure for the 'map' and 'picture' types):
librarianHint: "Found Smudged Note."
newItems:
[
  {
    "chapters": /* REQUIRED, because the type is 'page' */
    [ /* Only one chapter, because the type is 'page' */
      {
        "contentLength": 50,
        "description": "A hastily scribbled message about the dangers of the sunken tunnel.",
        "heading": "string"
      }
    ],
    "description": "A hastily scribbled message with a big smudge over it.",
    "holderId": "player",
    "name": "Smudged Note",
    "tags": ["typed", "smudged"],
    "type": "page"
  }
]

### Example of creating a *new* 'book' written item and placing it in player's inventory:
librarianHint: "Obtained the Explorer's Adventures."
newItems:
[
  {
    "chapters": /* REQUIRED, because the type is 'book' */
    [ /* Multiple chapters because the type it 'book' */
      {
        "contentLength": 53,
        "description": "Introduction. Written by the author, explaining his decisions to start his travels.",
        "heading": "Preface"
      },
      {
        "contentLength": 246,
        "description": "First trip. The author travelled to Vibrant Isles in the search of the Endless Waterfall",
        "heading": "Journey One"
      },
      {
        "contentLength": 312,
        "description": "Second Trip. The author's adventure in Desolate Steppes in the search of Magnificent Oasis",
        "heading": "Journey Two"
      },
      {
        "contentLength": 98,
        "description": "The author's contemplation about whether the journeys were worth it",
        "heading": "Final Thoughts"
      }
    ],
    "description": "Weathered log of travels.",
    "holderId": "player",
    "name": "Explorer's Adventures",
    "tags": ["handwritten", "faded"],
    "type": "book"
  }
]

### Example for losing, destroying, completely removing the item:
playerItemsHint: "Lost Old Lantern (flickering)."

### Example for giving an *existing* item from one holder to another:
npcItemsHint: "Gave Iron Sword to Guard."

### "take" is an alias for "give". Example:
playerItemsHint: "Took Coin Pouch from Bandit."

### Example for simple update of *existing* item (only changing "isActive"):
playerItemsHint: "Plasma Torch is now active."

### Example for transformation or crafting:
playerItemsHint: "Scrap Metal transformed into Makeshift Shiv."

### Example for adding a known use to an item without changing anything else:
playerItemsHint: "Mystic Orb can now 'Peer into the Orb'."

- ALWAYS appropriately handle spending single-use items and state toggles ("isActive": true/false).
- Make sure that 'page', 'map' and 'picture' type items have exactly ONE chapter.
- Make sure that 'book' type items have between ${String(sn)} and ${String(cn)} chapters.
- Make sure 'page', 'book', 'map' and 'picture' type items have one of the required tags: ${Wn}.
- Using some "single-use" items (food, water, medicine, etc) MUST add or remove appropriate "status effects".
- Mention remaining uses for multi-use items when they change.
IMPORTANT: For items that CLEARLY can be enabled or disabled (e.g., light sources, powered equipment, wielded or worn items) provide at least the two knownUses to enable and disable them with appropriate names:
  - The knownUse to turn on, light, or otherwise enable the item should ALWAYS have "appliesWhenInactive": true (and typically "appliesWhenActive": false or undefined).
  - The knownUse to turn off, extinguish, or disable the item should ALWAYS have "appliesWhenActive": true (and typically "appliesWhenInactive": false or undefined).
  - ALWAYS provide these actions in pairs, e.g. turn on/turn off, wield/put away, wear/take off, light/extinguish, activate/deactivate, start/stop, etc.
IMPORTANT: NEVER add ${rn} known uses - there are dedicated buttons for those in the game.

${jr}

`,va=`Map Node Types:
- region: Broad area containing multiple locations.
- location: Significant named place within a region.
- settlement: Inhabited location such as a town or base.
- district: Subdivision of a settlement or complex, including streets or sectors.
- exterior: Outside of a single structure or vehicle.
- interior: Inside of a structure or vehicle.
- room: Individual enclosed space within an interior.
- feature: Notable sub-location or landmark within any other node.`,wa=`Map Edge Types:
- path: Narrow walking trail or hallway.
- road: Major route or street for ground travel.
- sea route: Travel across open water or space lanes.
- door: Physical entry like doors, gates, hatches, or airlocks.
- teleporter: Instant or rapid transit portals and lifts.
- secret_passage: Hidden or maintenance passageway.
- river_crossing: Means of crossing water or similar obstacles.
- temporary_bridge: Deployable link such as a boarding tube or rope bridge.
- boarding_hook: Grappling device to connect to a moving object.
- shortcut: Any special connection that bypasses hierarchy rules.`,Ia=`Map Node Hierarchy:
- A "region" can contain "locations".
- A "location" can contain "settlements".
- A "settlement" can contain "districts".
- A "district" can contain "exteriors".
- An "exterior" can contain "interiors".
- An "interior" can contain "rooms".
- A "room" can contain "features".
- The "Universe" is the root node, it can contain any other nodes.
- A "feature" can be placed anywhere in the hierarchy, but can never be a parent to any other node.
- Only "feature" nodes can be connected to each other with edges.`,Vr=`- You MUST provide "localTime", "localEnvironment", "localPlace" in the response.
- "localTime" should be a very short phrase (e.g., "Dawn", "Mid-morning", "Twilight", "Deep Night", "Temporal Flux").
- "localEnvironment" should be a concise sentence describing immediate ambient conditions (e.g., "A gentle breeze rustles leaves.", "The air is stale and smells of decay.", "Rain lashes against the windows.", "A low hum pervades the metallic corridor.").
- "localPlace" is a free-form string describing the player's current specific position.
  - It can use relational words with a known Map Node (which represent main locations or significant features, e.g., "inside the Old Mill", "in front of the Stone Altar").
  - It can describe positions between known Map Nodes (e.g., "on the path between the Whispering Woods and the Crystal Cave", "en-route from Port Blacksand to the Serpent's Isle").
  - The new "localPlace" must be a logical continuation from the previous "localPlace", considering the player's action and the scene's outcome. Update "localPlace" whenever the player moves, their immediate surroundings change significantly, or they transition between distinct areas.
- These details MUST be updated as the narrative progresses and be in agreement with the "sceneDescription".
`,Lt=`You are the Dungeon Master for a text-based adventure game. Your role is to describe scenes, provide action/dialogue choices, manage inventory, player goals, track known NPCs (including their presence, general location, and precise location in scene), and track local time/environment/place.
In your thinking focus less on the specific responses you will generate, and more on the overall detailed narrative flow, player engagement, and world consistency.

Local Time, Environment & Place Guide:
${Vr}

Items Guide:
${Fr}

Player Input and Contextual Information:
- Very subtly and indirectly take into account Player's Character Gender, but do not focus attention on it in the text, only on its consequences.
- Current Theme Guidance gives you specific instructions about the setting, tone, and types of challenges or events to generate. Adhere to this guidance.
- If "localPlace" corresponds to a location in "Locations Nearby" list OR remained at the old location, always set "currentMapNodeId" to the name of that location.
- If "sceneDescription" or "logMessage" mentions a new significant NAMED location or feature that is NOT in 'Known Locations' list (nor by one of its aliases), describe it in "mapHint", and set "mapUpdated": true. The map service will handle adding it.
- If new distant quest-related and objective-related locations are mentioned but don't exist on the map, provide a short description of them, their surroundings, and how to reach them in "mapHint" for the Map AI.
- If "sceneDescription" or "logMessage" mentions a new NPC (i.e., not in 'Known NPCs in Current Theme' list), you MUST add it using "npcsAdded". If an existing NPC's description, aliases, or presence change significantly, use "npcsUpdated".
- Pay close attention to 'Active: true' items and their available actions.
- Compare the new Local Place of the Player to the precise locations of relevant NPCs, and update their presence state accordingly.
For example, leaving NPC's location makes them "distant", entering NPC's location makes them 'nearby' if they are still there, or 'unknown', is they moved while the player was not there.
If a Companion leaves the Player, or the Player leaves a Companion, their presence status changes to 'nearby' or, sometimes, 'distant', depending on context.
- The response MUST include "localTime", "localEnvironment", and "localPlace".
- If "mainQuest" or "currentObjective" change, they MUST be provided. Otherwise, they are optional.
- If the narrative implies any changes to the map (new details, locations, connections, status changes), set "mapUpdated": true and write about it in mapHint.
- If Player's Action is "Inspect: [item_name]": Provide details about the item in "logMessage". If new info/use is found, mention it in playerItemsHint.
- If Player's Action is "Attempt to use: [item_name]": Treat it as the most logical action. Describe the outcome in "logMessage". If specific function is revealed, mention the new knownUse in playerItemsHint.
- Summarize any discoveries or updates to books, pages or maps in librarianHint.
- Compare the current events with the story arc's success condition for the active act. When it is undoubtedly fulfilled, set "mainQuestAchieved": true in your response.

CRITICALLY IMPORTANT: If "logMessage" or "sceneDescription" implies items were gained, lost, moved, or changed, you MUST summarize these changes using "playerItemsHint", "worldItemsHint", and "npcItemsHint" and list new items in "newItems".
CRITICALLY IMPORTANT: Names and Aliases (of items, places, NPCs, etc) cannot contain a comma.
`;var fo={};let Me=null,Kt=!1;typeof localStorage<"u"&&(Me=localStorage.getItem(ia));Me||(typeof window<"u"&&window.GEMINI_API_KEY?(Me=window.GEMINI_API_KEY,Kt=!0):(Me=fo.GEMINI_API_KEY??fo.API_KEY??null,Me&&(Kt=!0)));Me||console.error("Gemini API key is not set. Gemini services will be unavailable.");let Na=Me?new ga({apiKey:Me}):null;const ee=()=>!!Me,Hl=()=>Kt,Bl=()=>Me,Wl=e=>{Me=e,Kt=!1,typeof localStorage<"u"&&localStorage.setItem(ia,e),Na=new ga({apiKey:e})};ee()||console.error("Gemini API key is not set. The application will not be able to connect to the Gemini API.");const yo=Na,ln=e=>{if(!e||typeof e!="object")return null;const t=e;if(typeof t.status=="number")return t.status;if(t.error&&typeof t.error.code=="number")return t.error.code;const n=typeof t.message=="string"||typeof t.message=="number"||typeof t.message=="boolean"?String(t.message):"",o=/status:\s*(\d{3})/.exec(n);return o?parseInt(o[1],10):null},_t=e=>{const t=ln(e);return t!==null&&t>=400&&t<600},ba=e=>{if(!e)return!1;const t=e instanceof Error?e.message:typeof e=="string"||typeof e=="number"||typeof e=="boolean"?String(e):"";return t.includes("ERR_SSL_PROTOCOL_ERROR")||t.includes("ECONNRESET")||t.includes("ETIMEDOUT")||t.includes("EAI_AGAIN")||t.includes("Failed to fetch")},Dt={[Q]:[],[X]:[],[Se]:[]};let Vt=[];const Xn=()=>{const e=Date.now()-6e4;Object.values(Dt).forEach(t=>{if(t)for(;t.length&&t[0]<e;)t.shift()})},Gr=()=>{Vt.forEach(e=>{e()})},Yr=e=>{let t=Dt[e];t||(t=[],Dt[e]=t),t.push(Date.now()),Xn(),Gr()},An=e=>{var t;return Xn(),((t=Dt[e])==null?void 0:t.length)??0},Hr=e=>(Vt.push(e),()=>{Vt=Vt.filter(t=>t!==e)}),Br=(e,t)=>{Xn();const n=Dt[e]??[];if(n.length<t)return 0;const o=n.length-t,a=n[o]+6e4;return Math.max(0,a-Date.now())},Wr={[Q]:["thinking","system","schema"],[X]:["thinking","system","schema"],[Se]:[],[ca]:[]},re=async e=>{var o,a,r;if(!ee()||!yo)return Promise.reject(new Error("API Key not configured."));const t={[Q]:ua,[X]:da,[Se]:la,[ca]:pr};let n=null;for(const s of e.modelNames){const[i,c]=Array.isArray(s)?s:[s,Wr[s]??[]],l=c.includes("system"),d=c.includes("thinking"),p=c.includes("schema");let u=e.systemInstruction??"";if(!p&&e.jsonSchema){const h=ur(e.jsonSchema);u=u?`${u}

${h}`:h}const m=l?e.prompt:`${u?u+`

`:""}${e.prompt}`,g={};if(e.temperature!==void 0&&(g.temperature=e.temperature),e.responseMimeType&&p&&(g.responseMimeType=e.responseMimeType),e.maxOutputTokens!==void 0&&(g.maxOutputTokens=e.maxOutputTokens),d&&(e.thinkingBudget!==void 0||e.includeThoughts)){const h={};e.thinkingBudget!==void 0&&(h.thinkingBudget=e.thinkingBudget),e.includeThoughts&&(h.includeThoughts=!0),g.thinkingConfig=h}l&&u&&(g.systemInstruction=u),p&&e.jsonSchema&&(g.responseJsonSchema=e.jsonSchema);for(let h=1;h<=W;){const v=Br(i,t[i]??1);if(v>0||h>1){const f=5e3+v;await new Promise(I=>setTimeout(I,f))}try{const f=await yo.models.generateContent({model:i,contents:m,config:g});return Yr(i),e.label&&console.log(`[${e.label}] ${i} tokens: total ${String(((o=f.usageMetadata)==null?void 0:o.totalTokenCount)??"N/A")}, prompt ${String(((a=f.usageMetadata)==null?void 0:a.promptTokenCount)??"N/A")}, thoughts ${String(((r=f.usageMetadata)==null?void 0:r.thoughtsTokenCount)??"N/A")}`),e.debugLog&&e.debugLog.push({prompt:e.prompt,systemInstruction:u,jsonSchema:e.jsonSchema,modelUsed:i,responseText:f.text??"",promptUsed:m}),{response:f,modelUsed:i,systemInstructionUsed:u,jsonSchemaUsed:p?e.jsonSchema:void 0,promptUsed:m}}catch(f){if(e.debugLog&&e.debugLog.push({prompt:e.prompt,systemInstruction:u,jsonSchema:e.jsonSchema,modelUsed:i,responseText:`ERROR: ${f instanceof Error?f.message:String(f)}`,promptUsed:m}),n=f,!_t(f)&&!ba(f))throw f;const I=ln(f),T=f instanceof Error?f.message:String(f),k=I!==null?String(I):T;console.warn(`dispatchAIRequest: Model ${i} failed with ${k}. Retry ${String(h)}/${String(W)}`),h+=1}}console.warn(`dispatchAIRequest: Model ${i} exhausted retries. Falling back if another model is available.`)}throw n instanceof Error?n:new Error(String(n))},Jr=[512,1024,2048,4096];let Ta="Medium";const Sa=new Map,Aa=e=>{let t=Math.floor(e);switch(Ta){case"Low":t=Math.floor(t/2);break;case"High":t=Math.floor(t*2);break}return Math.min(8192,Math.max(512,t))},Ca=()=>{Jr.forEach(e=>{Sa.set(e,Aa(e))})};Ca();const Kr=e=>{Ta=e,Ca()},be=e=>Sa.get(e)??Aa(e),We=e=>Math.floor(6500+be(e));let wt="";const qt=[];let Rt=0;const zt=[],Ea=()=>{zt.forEach(e=>{e(Rt)})},Pa=()=>{qt.forEach(e=>{e(wt)})},qr=e=>{qt.push(e),e(wt)},zr=e=>{zt.push(e),e(Rt)},Qr=e=>{const t=qt.indexOf(e);t!==-1&&qt.splice(t,1)},Xr=e=>{const t=zt.indexOf(e);t!==-1&&zt.splice(t,1)},se=e=>{wt=e+wt,Pa()},Zr=()=>{Rt+=1,Ea()},$a=()=>{wt="",Pa()},vo=()=>{Rt=0,Ea()},es=()=>wt,ts=()=>Rt,ie=async(e,t=500)=>{vo();for(let n=0;n<=W;n++){let o=!1;try{const{result:r,retry:s=!0}=await e(n);if(r!==null)return r;if(!s)return null}catch(r){if(o=ba(r),!_t(r)&&!o)throw r}if(n===W)break;Zr();const a=o?Math.max(t,5e3):t;await new Promise(r=>setTimeout(r,a))}return vo(),null},ns=Ht.filter(e=>e!=="recovered"&&e!=="stashed"),Ma={type:"object",properties:{currentMapNodeId:{type:"string",description:"Name or ID of the map node the player is currently at."},currentObjective:{type:"string",description:"Short-term objective reflecting the next immediate task. Provide only when updated."},dialogueSetup:{type:"object",description:"Initiates dialogue when context suggests a conversation begins.",properties:{initialNpcResponses:{type:"array",minItems:1,items:{type:"object",properties:{line:{type:"string",description:"Opening line spoken by the NPC."},speaker:{type:"string",description:"Speaker NPC delivering the line."}},propertyOrdering:["line","speaker"],required:["line","speaker"],additionalProperties:!1}},initialPlayerOptions:{type:"array",minItems:4,maxItems:8,items:{type:"string"},description:"First-person dialogue choices, last one not necessarily politely, but contextually approprialely ends the conversation."},participants:{type:"array",minItems:1,items:{type:"string"},description:"NPC names taking part in the conversation, excluding the player."}},propertyOrdering:["initialNpcResponses","initialPlayerOptions","participants"],required:["initialNpcResponses","initialPlayerOptions","participants"],additionalProperties:!1},localEnvironment:{type:"string",description:"Brief sentence describing the current environment or weather. e.g. 'Clear skies, warm sun'."},localPlace:{type:"string",description:"Player's specific location in the scene, including the Place Name. e.g. 'Inside the Old Mill, near the quern'."},localTime:{type:"string",description:"Concise description of current time. e.g. 'Midday', 'Early morning', '12:30'."},logMessage:{type:"string",description:"Outcome of the player's previous actions, including any significant events, discoveries, or changes in the scene. This should be a concise narrative that captures the essence of what has happened since the last turn, providing additional context for the current scene."},mainQuest:{type:"string",description:"Long-term goal for the player. Provide only when it changes."},mapHint:{type:"string",maxLength:1e3,description:"Short hints about new or changed relevant locations and their connections."},mapUpdated:{type:"boolean",description:"Set to true if new locations or changes mean the map might need updating."},newItems:{type:"array",description:'Brand new items that must appear in the game this turn. Also includes status effects and afflictions of the player with item type "status effect"',items:{type:"object",properties:{activeDescription:{type:"string",description:"Optional description shown when the item is active or equipped."},chapters:{type:"array",description:`For the item types 'page', 'map', or 'picture' - exactly one chapter REQUIRED. For the item type 'book' - between ${String(sn)} and ${String(cn)} chapters REQUIRED.`,items:{type:"object",properties:{contentLength:{type:"number",minLength:50,maxLength:500,description:"Approximate length in words."},description:{type:"string",description:"Detailed abstract of the chapter contents."},heading:{type:"string",description:"Short heading for the chapter."}},propertyOrdering:["contentLength","description","heading"],required:["contentLength","description","heading"],additionalProperties:!1}},description:{type:"string",description:"Concise explanation of what the item is."},holderId:{type:"string",description:`ID or Name of the item holder. CAN be NPC, Location, or '${ne}'. CAN NOT be an Item. Use '${ne}' only if it is obvious from the context that the player actually acquired the item.`},isActive:{type:"boolean",description:"Whether the item is currently active, equipped, worn, or piloted (if vehicle)."},knownUses:{type:"array",description:`Optional interactive uses not covered by ${rn}.`,items:{type:"object",properties:{actionName:{type:"string",description:"Name of the use action."},appliesWhenActive:{type:"boolean",description:"Use is available when item is active."},appliesWhenInactive:{type:"boolean",description:"Use is available when item is inactive."},description:{type:"string",description:"Tooltip hint for this use."},promptEffect:{type:"string",description:"Short effect description for the AI."}},propertyOrdering:["actionName","appliesWhenActive","appliesWhenInactive","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Item name as it will appear to the player."},tags:{type:"array",items:{enum:ns},description:`Descriptor tags. For written items such as page, book, map, picture, always supply the text style tag, one of ${Wn}. Assign 'junk' only to unusable items.`},type:{enum:tt,description:`Item type. One of ${Jn}`}},propertyOrdering:["activeDescription","chapters","description","holderId","isActive","knownUses","name","tags","type"],required:["description","name","type"],additionalProperties:!1}},npcItemsHint:{type:"string",description:"Summary of items revealed to be carried by NPCs."},librarianHint:{type:"string",description:"Summary of written material updates."},npcsAdded:{type:"array",description:"NPCs introduced this turn.",items:{type:"object",properties:{aliases:{type:"array",items:{type:"string",minItems:1,maxItems:3},description:Fe},description:{type:"string",minLength:100,description:"Concise NPC description including role, appearance and personality."},lastKnownLocation:{type:"string",description:"General location when presenceStatus is distant or unknown."},name:{type:"string",description:"Unique NPC name introduced this turn."},preciseLocation:{type:"string",description:"NPC's exact position in the scene when presenceStatus is nearby or companion."},presenceStatus:{enum:gt,description:"Current relation to the player: companion, nearby or distant."}},propertyOrdering:["aliases","description","lastKnownLocation","name","preciseLocation","presenceStatus"],required:["aliases","description","lastKnownLocation","name","presenceStatus"],additionalProperties:!1}},npcsUpdated:{type:"array",description:"Updates to existing NPCs.",items:{type:"object",properties:{addAlias:{type:"string",description:`${Fe} Single alias to append to the NPC record.`},name:{type:"string",description:"Existing NPC name or ID being updated."},newAliases:{type:"array",items:{type:"string",minItems:1,maxItems:3},description:`${Fe} When provided, it replaces all old Aliases for this NPC.`},newDescription:{type:"string",minLength:100,description:"Expanded or revised description for the NPC."},newLastKnownLocation:{type:"string",description:"Updated general location if the NPC is away."},newPreciseLocation:{type:"string",description:"Updated exact position in the scene, when newPresenceStatus is nearby or companion."},newPresenceStatus:{enum:gt,description:"Updated relation to the player or scene."}},propertyOrdering:["addAlias","name","newAliases","newDescription","newLastKnownLocation","newPreciseLocation","newPresenceStatus"],required:["name"],additionalProperties:!1}},objectiveAchieved:{type:"boolean",description:"True when the current objective was successfully completed this turn."},mainQuestAchieved:{type:"boolean",description:"Set to true when the current act's success condition is undoubtedly met."},options:{type:"array",minItems:ze,maxItems:ze,items:{type:"string"},description:`Exactly ${String(ze)} distinct action options for the player to choose to progress in the story, tailored to the context.`},playerItemsHint:{type:"string",description:"Summary of player item gains, losses or state changes."},sceneDescription:{type:"string",minLength:500,description:"Description of the scene, taking into account the entirety of the player's current situation and surroundings. Include relevant details the player must be aware of to make informed decisions. This should be an engaging text that sets the stage for the player's next actions."},worldItemsHint:{type:"string",description:"Summary of items discovered or dropped in the world."}},required:["currentMapNodeId","localEnvironment","localPlace","localTime","logMessage","options","sceneDescription"],propertyOrdering:["currentMapNodeId","currentObjective","dialogueSetup","localEnvironment","localPlace","localTime","logMessage","mainQuest","mapHint","mapUpdated","newItems","npcItemsHint","librarianHint","npcsAdded","npcsUpdated","objectiveAchieved","mainQuestAchieved","options","playerItemsHint","sceneDescription","worldItemsHint"],additionalProperties:!1},xn=async(e,t)=>{if(!ee())return console.error("API Key not configured for Gemini Service."),Promise.reject(new Error("API Key not configured."));const n=await ie(async o=>{var a,r,s;try{console.log(`Executing storyteller turn (Attempt ${String(o+1)}/${String(W)})`),se(ae.storyteller.icon);const i=be(4096),c=t??We(4096),{response:l,systemInstructionUsed:d,jsonSchemaUsed:p,promptUsed:u}=await re({modelNames:[Q],prompt:e,systemInstruction:Lt,temperature:1,thinkingBudget:i,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:Ma,label:"Storyteller",maxOutputTokens:c}),g=(((s=(r=(a=l.candidates)==null?void 0:a[0])==null?void 0:r.content)==null?void 0:s.parts)??[]).filter(h=>h.thought===!0&&typeof h.text=="string").map(h=>h.text);return{result:{response:l,thoughts:g,systemInstructionUsed:d,jsonSchemaUsed:p,promptUsed:u}}}catch(i){throw console.error(`Error executing AI Main Turn (Attempt ${String(o+1)}/${String(W+1)}):`,i),i}});if(n)return n;throw new Error("Failed to execute AI Main Turn after maximum retries.")},os=(e,t=[])=>{const n=e.data.parentNodeId??"Universe",o=e.data.description,a=t.filter(s=>s.holderId===e.id),r=a.length>0?` Items: ${a.map(s=>`"${s.name}"`).join(", ")}`:"";return` - ${e.id} - "${e.placeName}" (parent: ${n}), "${o}"${r}`},as=e=>`- ${e.id} (${String(e.data.status)} ${String(e.data.type)})`,rs=(e,t="",n=!0,o=!0,a=!0,r=!1)=>{const s=Array.isArray(e)?e:[e];if(s.length===0)return"";const i=r?"; ":`;
`;return s.map(l=>{let d=`${t}${l.id} - "${l.placeName}"`;return n&&l.data.aliases&&l.data.aliases.length>0&&(d+=` (aka ${l.data.aliases.map(p=>`"${p}"`).join(", ")})`),o&&(d+=` (Type: ${l.data.nodeType}, Visited: ${String(!!l.data.visited)}, ParentNodeId: ${l.data.parentNodeId??"N/A"}, Status: ${l.data.status})`),a&&(d+=`, "${l.data.description}"`),d}).join(i)+"."},ss=(e,t=!0,n=!0,o=!0)=>{const a=new Map;e.forEach(l=>{const d=l.data.parentNodeId&&l.data.parentNodeId!=="Universe"?l.data.parentNodeId:"Universe",p=a.get(d);p?p.push(l):a.set(d,[l])});const r=(l,d)=>l.placeName.localeCompare(d.placeName);for(const l of a.values())l.sort(r);const s=[],i=(l,d,p)=>{const m=rs(l,`${d}${p?"└─":"├─"} `,t,n,o,!0);s.push(m);const g=d+(p?"   ":"│  "),h=a.get(l.id)??[];h.forEach((v,f)=>{i(v,g,f===h.length-1)})},c=a.get("Universe")??[];return c.forEach((l,d)=>{i(l,"",d===c.length-1)}),s.join(`
`)},is=(e,t)=>{const n=e.data.status??"open",o=e.data.type??"path",a=[];e.data.travelTime&&a.push(`travel time: ${e.data.travelTime}`),e.data.description&&a.push(e.data.description);const r=a.length>0?` (${a.join(", ")})`:"";return` - ${n} ${o} to "${t.placeName}"${r}.`},nt=(e,t=!1,n=!0)=>{const o=e.filter(a=>a.data.nodeType!=="feature"&&a.data.nodeType!=="room");return o.length===0?"None specifically known in this theme yet.":t?o.map(a=>{let r=" - ";return n&&(r+=`${a.id} - `),r+=`"${a.placeName}"`,a.data.aliases&&a.data.aliases.length>0&&(r+=` (aka ${a.data.aliases.map(s=>`"${s}"`).join(", ")})`),r+=a.data.status=="rumored"?", rumored":"",r+=`, "${a.data.description||"No description available."}"`,r}).join(`;
`)+".":o.map(a=>{let r="";return n&&(r+=`${a.id} - `),r+=`"${a.placeName}"`,a.data.aliases&&a.data.aliases.length>0&&(r+=` (aka ${a.data.aliases.map(s=>`"${s}"`).join(", ")})`),r}).join(", ")+"."},wo=e=>e?{open:10,accessible:9,active:8,temporary_bridge:6,secret_passage:5,door:4,rumored:3,closed:2,locked:1,blocked:0,inactive:-1}[e]??0:7,Io=(e,t,n,o,a)=>{const r=n.filter(c=>c.sourceNodeId===e.id||c.targetNodeId===e.id),s={};r.forEach(c=>{const l=c.sourceNodeId===e.id?c.targetNodeId:c.sourceNodeId;if(l===o||a.has(l))return;let d=s[l];d||(d=[],s[l]=d),d.push(c)});const i=[];for(const c in s){const l=s[c];if(!l)continue;const d=l.filter(g=>!(g.data.status&&pa.includes(g.data.status)||g.data.status==="one_way"&&g.targetNodeId===e.id));if(d.length===0)continue;d.sort((g,h)=>{const v=(g.sourceNodeId===e.id?100:0)+wo(g.data.status);return(h.sourceNodeId===e.id?100:0)+wo(h.data.status)-v});const p=d[0],u=t.find(g=>g.id===c);if(!u)continue;const m=is(p,u);i.push(m),a.add(c)}return i},ka=(e,t,n,o,a,r)=>{const s=new Set,i=[{nodeId:e,hop:0}],c=new Set,l=["open","accessible","active"];for(;i.length>0;){const d=i.shift();if(d&&!(c.has(d.nodeId)&&d.nodeId!==e)&&(c.add(d.nodeId),d.nodeId!==e&&s.add(d.nodeId),d.hop<t)){const p=o.filter(u=>(u.sourceNodeId===d.nodeId||u.targetNodeId===d.nodeId)&&l.includes(u.data.status));for(const u of p){const m=u.sourceNodeId===d.nodeId?u.targetNodeId:u.sourceNodeId;if(!c.has(m)){const g=n.find(h=>h.id===m);g&&(g.data.nodeType,i.push({nodeId:m,hop:d.hop+1}))}}}}return s},No=(e,t,n=[])=>{if(!t)return"Current location unknown.";const o=e.nodes,a=e.edges,r=ka(t,2,o,a);r.add(t);const s=[];return r.forEach(i=>{const c=o.find(l=>l.id===i);c&&s.push(os(c,n))}),s.join(`;
`)+"."},cs=(e,t,n,o,a)=>{if(!t||!n)return"Player's precise map location is currently unknown or they are between known locations.";const r=o.find(h=>h.id===t);if(!r)return"";let s=` - You are currently at ${r.id} - "${r.placeName}".`;r.data.description&&(s+=` ${r.data.description}.`);const i=r.data.nodeType==="feature"&&r.data.parentNodeId&&r.data.parentNodeId!=="Universe"?o.find(h=>h.id===r.data.parentNodeId):null;i&&(i.data.nodeType==="feature"?s+=` This is a feature of "${i.placeName}".`:s+=` This is part of the larger known location: "${i.placeName}".`),s+=`
`;const c=r.data.nodeType==="feature"?r.data.parentNodeId&&r.data.parentNodeId!=="Universe"?r.data.parentNodeId:void 0:r.id;let l="";if(c){const h=o.find(v=>v.id===c);if(h&&h.data.nodeType!=="feature"){const v=o.filter(I=>I.data.nodeType==="feature"&&I.data.parentNodeId===h.id),f=[];if(v.length>0){for(const I of v)if(I.id!==r.id)for(const T of a){if(T.sourceNodeId!==I.id&&T.targetNodeId!==I.id||T.data.status&&pa.includes(T.data.status))continue;const k=T.sourceNodeId===I.id?T.targetNodeId:T.sourceNodeId,y=o.find(P=>P.id===k);if(y&&y.data.nodeType==="feature"&&y.data.parentNodeId&&y.data.parentNodeId!==h.id&&y.data.parentNodeId!=="Universe"){const P=o.find(S=>S.id===y.data.parentNodeId&&S.data.nodeType!=="feature");if(P){const S=T.data.status??"open",C=T.data.type??"path";f.push(` - '${S} ${C}' exit at '${I.placeName}', leading to '${P.placeName}' via '${y.placeName}'.`)}}}}f.length>0?l=`
Possible Exits from Current Main Area (`+h.placeName+`):
`+f.join(`
`):l=`
No mapped exits from the current main area ("${h.placeName}") to other major areas are known.`}else h&&h.data.nodeType==="feature"&&(l=`You are at a detailed feature ("${h.placeName}"). Connections to other major areas are listed below if available.`)}else l="Current location is not part of a larger mapped area.";s+=l+`

`;const d=new Set,p=r.data.nodeType==="feature"&&i?i.id:null,u=Io(r,o,a,p,d),m=i?Io(i,o,a,r.id,d):[];u.length>0&&(s+="Paths leading directly from your current spot ("+r.placeName+`):
`+u.join(`
`)),m.length>0&&i&&(u.length>0&&(s+=`

`),s+=`Additional paths and features within or connected to "${i.placeName}":
`+m.join(`
`)),s+=`
`;const g=ka(r.id,2,o,a);if(g.size>0){const h=Array.from(g).map(v=>{var f;return(f=o.find(I=>I.id===v))==null?void 0:f.placeName}).filter(v=>!!v).map(v=>`"${String(v)}"`);h.length>0&&(s+=`
Locations nearby (within two hops): ${h.join(", ")}.`)}return s},bo=async(e,t,n,o,a)=>{if(!ee())return console.error(`fetchCorrectedNPCDetails_Service: API Key not configured. Cannot fetch details for "${e}".`),null;const r=a.length>0?"Known map locations in this theme: "+nt(a,!0):"No specific map locations are currently known for this theme.",s=`
You are an AI assistant generating detailed JSON objects for new NPCs.
Provide a suitable description, aliases, presenceStatus, lastKnownLocation, and preciseLocation for a character. Information MUST be derived *strictly* from the provided context.

NPC Name: "${e}"

Context:
- Log Message (how they appeared/what they're doing): "${t??"Not specified, infer from scene."}"
- Scene Description (where they appeared/are relevant): "${n??"Not specified, infer from log."}"
- ${r}
- Theme Guidance (influences NPC style/role): "${o.storyGuidance}"

Respond ONLY in JSON format with the following structure:
{
  "aliases": ["string"],
  "description": "string (A detailed, engaging description fitting the scene and theme. MUST be non-empty.)",
  "lastKnownLocation": "string | null",
  "preciseLocation": "string | null",
  "presenceStatus": ${mr}
}

Constraints:
- 'description' and 'presenceStatus' are REQUIRED and must be non-empty.
- If 'presenceStatus' is 'nearby' or 'companion', 'preciseLocation' MUST be a descriptive string derived from context; 'lastKnownLocation' can be null or a broader area.
- If 'presenceStatus' is 'distant' or 'unknown', 'preciseLocation' MUST be null; 'lastKnownLocation' should describe general whereabouts or be 'Unknown' if context doesn't specify.
`,i="You generate detailed JSON objects for new NPCs based on narrative context. Provide description, aliases, presenceStatus, lastKnownLocation, and preciseLocation. Adhere strictly to the JSON format and field requirements. Derive all information strictly from the provided context.";return ie(async c=>{try{se(ae.correction.icon);const{response:l}=await re({modelNames:[X,Q],prompt:s,systemInstruction:i,responseMimeType:"application/json",temperature:Ae,label:"Corrections"}),d=ge(Ne(l.text??""));if(d&&typeof d.description=="string"&&d.description.trim()!==""&&Array.isArray(d.aliases)&&d.aliases.every(p=>typeof p=="string")&&typeof d.presenceStatus=="string"&&gt.includes(d.presenceStatus)&&(d.lastKnownLocation===null||typeof d.lastKnownLocation=="string")&&(d.preciseLocation===null||typeof d.preciseLocation=="string")&&!((d.presenceStatus==="nearby"||d.presenceStatus==="companion")&&(d.preciseLocation===null||d.preciseLocation===""))&&!((d.presenceStatus==="distant"||d.presenceStatus==="unknown")&&d.preciseLocation!==null))return{result:d};console.warn(`fetchCorrectedNPCDetails_Service (Attempt ${String(c+1)}/${String(W+1)}): Corrected details for "${e}" invalid or incomplete. Response:`,d)}catch(l){throw console.error(`fetchCorrectedNPCDetails_Service error (Attempt ${String(c+1)}/${String(W+1)}):`,l),l}return{result:null}})},ls=Er,ds=ls.type,Cn=new Set(["destroyed","consumed","deleted","removed","lost","gone","broken"]);function Qt(e){if(typeof e!="string")return null;const t=e.toLowerCase().trim();return tt.includes(t)?t:ds[t]??null}const Zn=Pr,eo=$r,us=Zn.status,ps=Zn.type,ms=eo.type,gs=eo.status,hs=Zn.remove,fs=eo.remove;function En(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function ys(e,t){const n={};for(const a of t)n[a]=[En(a)];for(const[a,r]of Object.entries(e)){let s=n[r];s||(s=[En(r)],n[r]=s),s.push(En(a))}const o=[];for(const[a,r]of Object.entries(n)){if(!r)continue;const s=r.map(i=>i.replace(/\s+/g,"\\s+")).join("|");o.push([new RegExp(s,"i"),a])}return o}const vs=Mr,ws=vs.tag;function Is(e){if(typeof e!="string")return null;const t=e.toLowerCase().trim();return Ht.includes(t)?t:ws[t]??null}function Ns(e){if(!Array.isArray(e))return null;const t=[];for(const n of e){const o=Is(n);o&&t.push(o)}return t}const To=new Set(gr),bs=["page","book","map","picture"],So=new Set(bs);function Ts(e,t){const n=`${e} ${t}`.toLowerCase();return/(handwritten|scribbled|ink|pen|quill)/.test(n)?"handwritten":/(typewriter|typed)/.test(n)?"typed":/(digital|screen|display|tablet|monitor|terminal)/.test(n)?"digital":"printed"}function La(e){if(!e||typeof e!="object")return!1;const t=e;return!(typeof t.actionName!="string"||t.actionName.trim()===""||typeof t.promptEffect!="string"||t.promptEffect.trim()===""||t.appliesWhenActive!==void 0&&typeof t.appliesWhenActive!="boolean"||t.appliesWhenInactive!==void 0&&typeof t.appliesWhenInactive!="boolean"||typeof t.description!="string"||t.description.trim()==="")}function Ao(e,t){if(!e||typeof e!="object")return!1;const n=e;if(typeof n.type=="string"){const a=Qt(n.type);a&&(n.type=a)}if(typeof n.name!="string"||n.name.trim()==="")return console.warn("isValidItem: 'name' is missing or invalid.",e),!1;if(t==="create"||!t){if(typeof n.type!="string"||!tt.includes(n.type))return console.warn(`isValidItem (context: ${t??"default"}): 'type' is missing or invalid.`,e),!1;if(typeof n.description!="string"||n.description.trim()==="")return console.warn(`isValidItem (context: ${t??"default"}): 'description' is missing or invalid.`,e),!1;if(typeof n.holderId!="string"||n.holderId.trim()==="")return console.warn(`isValidItem (context: ${t??"default"}): 'holderId' is missing or invalid.`,e),!1}if(t==="change"&&n.newName!=null&&(typeof n.newName!="string"||n.newName.trim()===""))return console.warn("isValidItem (context: change, with newName): 'newName' is invalid.",e),!1;if(n.type!==void 0){const a=Qt(n.type);if(!a)return console.warn("isValidItem: 'type' is present but invalid.",e),!1;n.type=a}if(n.description!==void 0&&(typeof n.description!="string"||n.description.trim()==="")&&(t==="create"||t==="change"&&n.newName)&&n.description.trim()==="")return console.warn("isValidItem: 'description' is present but empty, which is invalid for a create or transformation.",e),!1;if(n.activeDescription!==void 0&&typeof n.activeDescription!="string")return console.warn("isValidItem: 'activeDescription' is present but invalid.",e),!1;if(n.isActive!==void 0&&typeof n.isActive!="boolean")return console.warn("isValidItem: 'isActive' is present but invalid.",e),!1;if(n.stashed!==void 0&&typeof n.stashed!="boolean")return console.warn("isValidItem: 'stashed' is present but invalid.",e),!1;if(n.tags!==void 0){if(!Array.isArray(n.tags)||!n.tags.every(s=>typeof s=="string"))return console.warn("isValidItem: 'tags' is present but invalid.",e),!1;const a=Ns(n.tags);a?n.tags=a:n.tags=n.tags.filter(s=>Ht.includes(s));const r=n.type===void 0?Ht:So.has(n.type)?[...Qe,...Bt]:Qe;n.tags=n.tags.filter(s=>r.includes(s))}if(So.has(n.type??"")){n.tags=n.tags??[];const a=n.tags.filter(r=>To.has(r));if(a.length===0){const r=Ts(n.name,n.description??"");n.tags.unshift(r)}else if(a.length>1){const[r]=a;n.tags=[r,...n.tags.filter(s=>!To.has(s))]}}if(n.holderId!==void 0&&(typeof n.holderId!="string"||n.holderId.trim()===""))return console.warn("isValidItem: 'holderId' is present but invalid.",e),!1;const o=a=>Array.isArray(a)&&a.every(r=>r&&typeof r=="object"&&typeof r.heading=="string"&&typeof r.description=="string"&&typeof r.contentLength=="number"&&(r.imageData===void 0||typeof r.imageData=="string"));if(n.type==="page"||n.type==="book"||n.type==="map"||n.type==="picture"){if(n.chapters!==void 0){if(!o(n.chapters))return console.warn("isValidItem: 'chapters' is present but invalid.",e),!1;(n.type==="page"||n.type==="map"||n.type==="picture")&&n.chapters.length>1&&(n.chapters=[n.chapters[0]])}else{const a=typeof n.contentLength=="number"?n.contentLength:30;n.chapters=[{heading:n.name,description:n.description??"",contentLength:a,actualContent:typeof n.actualContent=="string"?n.actualContent:void 0,visibleContent:typeof n.visibleContent=="string"?n.visibleContent:void 0}]}delete n.contentLength,delete n.actualContent,delete n.visibleContent}else if(n.chapters!==void 0&&!o(n.chapters))return console.warn("isValidItem: 'chapters' is present but invalid for non-book/page item.",e),!1;return n.contentLength!==void 0&&typeof n.contentLength!="number"?(console.warn("isValidItem: 'contentLength' is present but invalid.",e),!1):n.actualContent!==void 0&&typeof n.actualContent!="string"?(console.warn("isValidItem: 'actualContent' is present but invalid.",e),!1):n.visibleContent!==void 0&&typeof n.visibleContent!="string"?(console.warn("isValidItem: 'visibleContent' is present but invalid.",e),!1):n.knownUses!==void 0&&!(Array.isArray(n.knownUses)&&n.knownUses.every(La))?(console.warn("isValidItem: 'knownUses' is present but invalid.",e),!1):!0}function Co(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.id=="string"&&t.id.trim()!==""&&typeof t.name=="string"&&t.name.trim()!==""}function Da(e){if(!e||typeof e!="object")return!1;const t=e;if(typeof t.id!="string"||t.id.trim()===""||typeof t.name!="string"||t.name.trim()===""||typeof t.type!="string"||!tt.includes(t.type))return!1;const n=["page","book","map","picture"].includes(t.type);if(t.knownUses===void 0&&t.tags===void 0&&t.chapters===void 0||t.knownUses!==void 0&&!(Array.isArray(t.knownUses)&&t.knownUses.every(La)))return!1;const o=n?[...Qe,...Bt]:Qe,a=Array.isArray(t.tags)&&t.tags.every(s=>o.includes(s)),r=Array.isArray(t.chapters)&&t.chapters.every(s=>{const i=s;return typeof i.heading=="string"&&typeof i.description=="string"&&typeof i.contentLength=="number"});if(n){if(!a||!r)return!1}else if(t.tags!==void 0&&!a||t.chapters!==void 0&&!r)return!1;return!0}function Ss(e){if(!e||typeof e!="object")return!1;const t=e;if(typeof t.type=="string"){const n=Qt(t.type);n&&(t.type=n)}return typeof t.name=="string"&&t.name.trim()!==""&&typeof t.description=="string"&&t.description.trim()!==""&&typeof t.type=="string"&&tt.includes(t.type)}function _a(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.name!="string"||t.name.trim()===""||t.newDescription!==void 0&&typeof t.newDescription!="string"||t.newAliases!==void 0&&!(Array.isArray(t.newAliases)&&t.newAliases.every(n=>typeof n=="string"))||t.addAlias!==void 0&&typeof t.addAlias!="string"||t.newPresenceStatus!==void 0&&!gt.includes(t.newPresenceStatus)||t.newLastKnownLocation!==void 0&&t.newLastKnownLocation!=null&&typeof t.newLastKnownLocation!="string"||t.newPreciseLocation!==void 0&&t.newPreciseLocation!=null&&typeof t.newPreciseLocation!="string"?!1:((t.newPresenceStatus==="nearby"||t.newPresenceStatus==="companion")&&t.newPreciseLocation,(t.newPresenceStatus==="distant"||t.newPresenceStatus==="unknown")&&t.newPreciseLocation!=null,!0)}function Un(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.name!="string"||t.name.trim()===""||typeof t.description!="string"||t.description.trim()===""||t.aliases!==void 0&&!(Array.isArray(t.aliases)&&t.aliases.every(n=>typeof n=="string"))||t.presenceStatus!==void 0&&!gt.includes(t.presenceStatus)||t.lastKnownLocation!==void 0&&t.lastKnownLocation!=null&&typeof t.lastKnownLocation!="string"||t.preciseLocation!==void 0&&t.preciseLocation!=null&&typeof t.preciseLocation!="string"?!1:((t.presenceStatus==="nearby"||t.presenceStatus==="companion")&&t.preciseLocation,(t.presenceStatus==="distant"||t.presenceStatus==="unknown")&&t.preciseLocation!=null,!0)}function jn(e){if(!e||typeof e!="object")return console.warn("isDialogueSetupPayloadStructurallyValid: dialogueSetup is missing or not an object."),!1;const t=e;if(!Array.isArray(t.participants)||t.participants.length===0||!t.participants.every(o=>typeof o=="string"&&o.trim()!==""))return console.warn("isDialogueSetupPayloadStructurallyValid: dialogueSetup.participants is invalid.",t.participants),!1;const n=t.participants;return!Array.isArray(t.initialNpcResponses)||t.initialNpcResponses.length===0||!t.initialNpcResponses.every(o=>o&&typeof o.speaker=="string"&&o.speaker.trim()!==""&&n.includes(o.speaker)&&typeof o.line=="string"&&o.line.trim()!=="")?(console.warn("isDialogueSetupPayloadStructurallyValid: dialogueSetup.initialNpcResponses is invalid.",t.initialNpcResponses),!1):!Array.isArray(t.initialPlayerOptions)||t.initialPlayerOptions.length<4||!t.initialPlayerOptions.every(o=>typeof o=="string"&&o.trim()!=="")?(console.warn("isDialogueSetupPayloadStructurallyValid: dialogueSetup.initialPlayerOptions is invalid.",t.initialPlayerOptions),!1):!0}const As=async(e,t,n,o)=>{if(!ee())return console.error("fetchCorrectedAddDetailsPayload_Service: API Key not configured."),null;const a=`You are an AI assistant fixing a malformed addDetails JSON object for a text adventure game.

Malformed Payload:
\`\`\`json
${e}
\`\`\`

Log Message: "${t??"Not specified"}"
Scene Description: "${n??"Not specified"}"
Theme Guidance: "${o.storyGuidance}"

Task: Provide ONLY the corrected JSON object with fields { "id": string, "name": string, "type": (${Jn}), "knownUses"?, "tags"?, "chapters"? }.`,r="Return only the corrected addDetails JSON object.";return ie(async s=>{try{se(ae.correction.icon);const{response:i}=await re({modelNames:[X,Q],prompt:a,systemInstruction:r,responseMimeType:"application/json",temperature:Ae,label:"Corrections"}),c=i.text??"",l=ge(Ne(c));if(l&&Da(l))return{result:l};console.warn(`fetchCorrectedAddDetailsPayload_Service (Attempt ${String(s+1)}/${String(W+1)}): invalid response`,l)}catch(i){throw console.error(`fetchCorrectedAddDetailsPayload_Service error (Attempt ${String(s+1)}/${String(W+1)}):`,i),i}return{result:null}})},Cs=async(e,t,n,o)=>{if(!ee())return console.error("fetchFullPlaceDetailsForNewMapNode_Service: API Key not configured."),null;const a=`You are an AI assistant that generates detailed information for a new game map location (a main MapNode) that has just been added to the game map. The Map AI should have provided these details, but this is a fallback.
Given the name of this new map location and the current narrative context, provide a suitable description and aliases for it. The provided 'Map Location Name to Detail' is fixed and MUST be used as the 'name' in your JSON response.

Map Location Name to Detail: "${e}"

## Narrative Context:
- Log Message: "${t??"Not specified"}"
- Scene Description: "${n??"Not specified"}"
- Theme Guidance: "${o.storyGuidance}"

Required JSON Structure:
{
  "aliases": ["string"], // ${Fe}
  "description": "string", // ${ht}
  "name": "${e}"
}

Respond ONLY with the single, complete JSON object.`,r=`Generate detailed JSON for a new game map location. The 'name' field in the output is predetermined and MUST match the input. Focus on creating ${ht} and aliases (${Fe}, array, can be empty). Adhere strictly to the JSON format.`;return ie(async s=>{try{se(ae.correction.icon);const{response:i}=await re({modelNames:[X,Q],prompt:a,systemInstruction:r,responseMimeType:"application/json",temperature:Ae,label:"Corrections"}),c=ge(Ne(i.text??""));if(c&&typeof c.name=="string"&&c.name===e&&typeof c.description=="string"&&c.description.trim()!==""&&Array.isArray(c.aliases)&&c.aliases.every(l=>typeof l=="string"))return{result:c};console.warn(`fetchFullPlaceDetailsForNewMapNode_Service (Attempt ${String(s+1)}/$${String(W+1)}): Corrected map location payload invalid or name mismatch for "${e}". Response:`,c)}catch(i){throw console.error(`fetchFullPlaceDetailsForNewMapNode_Service error (Attempt ${String(s+1)}/$${String(W+1)}):`,i),i}return{result:null}})},Es=async(e,t,n)=>{if(!ee())return console.error("fetchLikelyParentNode_Service: API Key not configured."),null;const o=t.currentMapNodeId&&t.themeNodes.find(u=>u.id===t.currentMapNodeId),a=new Map;t.themeNodes.forEach(u=>a.set(u.id,u));const r=new Map;t.themeNodes.forEach(u=>r.set(u.id,new Set)),t.themeEdges.forEach(u=>{r.has(u.sourceNodeId)||r.set(u.sourceNodeId,new Set),r.has(u.targetNodeId)||r.set(u.targetNodeId,new Set);const m=r.get(u.sourceNodeId);m&&m.add(u.targetNodeId);const g=r.get(u.targetNodeId);g&&g.add(u.sourceNodeId)});const s=e.nodeType??"feature",i=Pe[s],c=t.themeNodes.filter(u=>Pe[u.data.nodeType]<i).map(u=>`- ${u.id} ("${u.placeName}")`).join(`
`),l=t.themeEdges.map(u=>`${u.id} ${u.sourceNodeId}->${u.targetNodeId}`).join(`
`),d=`Map Node: "${e.placeName}" (${e.nodeType??"feature"})
Scene: "${t.sceneDescription}"
Current location: ${t.localPlace}
Current Map Node: ${o?o.placeName:"Unknown"}

## Possible Nodes:
${c}

## Edges:
${l}

Respond ONLY with the name or id of the best parent node, or "Universe" if none.`,p='Choose the most logical parent node name or id for the provided Map Node. If none is suitable use "Universe".';return ie(async u=>{var m;try{se(ae.correction.icon);const{response:g}=await re({modelNames:[Se,X,Q],prompt:d,systemInstruction:p,temperature:Ae,label:"Corrections",debugLog:n}),h=(m=g.text)==null?void 0:m.trim();if(h)return{result:h.trim()}}catch(g){throw console.error(`fetchLikelyParentNode_Service error (Attempt ${String(u+1)}/$${String(W+1)}):`,g),g}return{result:null}})},Ps=async(e,t,n)=>{if(!ee())return console.error("fetchCorrectedNodeIdentifier_Service: API Key not configured."),null;const o=t.themeNodes.map(s=>`- ${s.id} ("${s.placeName}")`).join(`
`),a=`A different AI referred to a map location using an incorrect identifier: "${e}".
Known map nodes in the current theme:
${o}
Choose the most likely intended node ID from the list above. Respond with an empty string if none match.`,r="Respond ONLY with a single node ID from the list or an empty string.";return ie(async s=>{var i;try{se(ae.correction.icon);const{response:c}=await re({modelNames:[Se,X,Q],prompt:a,systemInstruction:r,temperature:Ae,label:"Corrections",debugLog:n}),l=(i=c.text)==null?void 0:i.trim();if(l){const d=l.trim(),p=t.themeNodes.find(m=>m.id===d);if(p)return{result:p.id};const u=t.themeNodes.find(m=>m.placeName===d);if(u)return{result:u.id}}}catch(c){throw console.error(`fetchCorrectedNodeIdentifier_Service error (Attempt ${String(s+1)}/$${String(W+1)}):`,c),c}return{result:null}})},$s={type:"object",properties:{observations:{type:"string",minLength:1500,description:"Contextually relevant observations about the chains and map graph."},rationale:{type:"string",minLength:1e3,description:"Explain the reasoning behind your chain fixes and refinement suggestions."},edgesToAdd:{type:"array",items:{type:"object",properties:{description:{type:"string",minLength:30,description:Wt},sourcePlaceName:{type:"string",description:"Name of the source feature node. MUST be a feature type node."},status:{enum:vt},targetPlaceName:{type:"string",description:"Name of the target feature node. MUST be a feature type node."},travelTime:{type:"string"},type:{enum:yt}},propertyOrdering:["description","sourcePlaceName","status","targetPlaceName","travelTime","type"],required:["sourcePlaceName","status","targetPlaceName","type"],additionalProperties:!1}},nodesToAdd:{type:"array",description:"List of nodes to add to the map.",minItems:1,items:{type:"object",properties:{aliases:{type:"array",description:Fe,minItems:2,items:{type:"string"}},description:{type:"string",minLength:30,description:ht},nodeType:{enum:["feature"]},parentNodeId:{type:"string",description:"Name of the Parent Node this feature belongs to, or 'Universe' (keyword for root node) if it has no parent"},placeName:{type:"string",description:"A contextually relevant location name, based on Theme and Scene Description"},status:{enum:ft}},propertyOrdering:["aliases","description","nodeType","parentNodeId","placeName","status"],required:["aliases","description","nodeType","parentNodeId","placeName","status"],additionalProperties:!1}}},required:["observations","rationale","edgesToAdd","nodesToAdd"],propertyOrdering:["observations","rationale","edgesToAdd","nodesToAdd"],additionalProperties:!1},Ms=async(e,t)=>{if(!ee()||e.length===0)return{payload:null,debugInfo:null};const o=(()=>{const i=new Map,c=new Map,l=[];e.forEach((u,m)=>{const g=new Set,h=[];[...u.sourceChain,...u.targetChain.slice().reverse()].forEach(v=>{v.data.nodeType!=="feature"&&!g.has(v.id)&&(h.push(v),g.add(v.id),i.set(v.id,v))}),h.length===0&&(g.has(u.originalSource.id)||(h.push(u.originalSource),g.add(u.originalSource.id),i.set(u.originalSource.id,u.originalSource)),g.has(u.originalTarget.id)||(h.push(u.originalTarget),g.add(u.originalTarget.id),i.set(u.originalTarget.id,u.originalTarget)));for(let v=0;v<h.length-1;v++){const f=h[v],I=h[v+1],T=f.id<I.id?`${f.id}|${I.id}`:`${I.id}|${f.id}`;c.has(T)||c.set(T,{source:f,target:I,data:u.edgeData})}l.push(`Chain ${String(m+1)}: ${h.map(v=>`"${v.placeName}"`).join(" -> ")}`)});const d=Array.from(i.values()).map((u,m)=>{const g=t.themeNodes.filter(h=>h.data.parentNodeId===u.id&&h.data.nodeType==="feature").map(h=>` - "${h.placeName}" (${h.data.nodeType}, ${h.data.status}, ${h.data.description})`).join(`
`)||" - None";return`Node ${String(m+1)}: "${u.placeName}" (Type: ${u.data.nodeType}, Status: ${u.data.status}, Description: ${u.data.description})
${g}`}).join(`
`),p=Array.from(c.values()).map((u,m)=>`Edge ${String(m+1)}: "${u.source.placeName}" -> "${u.target.placeName}" (Type: ${u.data.type??"path"}, Status: ${u.data.status??"open"}, Desc: ${u.data.description??"None"})`).join(`
`);return`Parent Nodes:
${d}

Edges:
${p}

Chains:
${l.join(`
`)}`})(),a=`Suggest chains of locations (feature nodes) to connect distant map nodes in a text adventure.
** Context: **
Scene Description: "${t.sceneDescription}"
Theme: "${t.currentTheme.name}" (${t.currentTheme.storyGuidance})

---

## Graph:
${o}`,r=`Imagine a Player travelling along the provided chains. For each Parent Node in the graph imagine locations within them that may connect them to their neighbours.
CHOOSE ONE for each Parent Node:
- IF there is a contextually appropriate feature node already present under that Parent Node, use it directly in edgesToAdd.
- IF there is 'None', or no appropriate candidate feature node exists under that Parent Node, you MUST use nodesToAdd to add a contextually appropriate feature node with full information, based on Context.

ALWAYS choose between selecting an existing feature node OR adding a new one. NEVER leave a Parent Node without a feature node connected to neighbour Parent Nodes' feature nodes.
You can add edges ONLY between feature nodes. NEVER try to connect feature nodes to Parent Nodes directly. NEVER try to connect Parent Nodes to each other.
New edges MUST inherit the original chain edge type and status.
Every new node MUST have a unique placeName. Use only the valid node/edge status and type values.
Edges MUST connect ALL feature nodes along each chain path using the shared feature nodes for common Parent Nodes.

${va}
${wa}
${Ia}
`;return await ie(async i=>{var c,l,d;try{console.log(`fetchConnectorChains_Service (Attempt ${String(i+1)}/${String(W+1)})`),se(ae.correction.icon);const p=be(2048),{response:u}=await re({modelNames:[X,Q],prompt:a,systemInstruction:r,thinkingBudget:p,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:$s,temperature:Ae,label:"Corrections"}),g=(((d=(l=(c=u.candidates)==null?void 0:c[0])==null?void 0:l.content)==null?void 0:d.parts)??[]).filter(T=>T.thought===!0&&typeof T.text=="string").map(T=>T.text),h={prompt:a,rawResponse:u.text??"",parsedPayload:void 0,validationError:void 0,observations:void 0,rationale:void 0,thoughts:g.length>0?g:void 0},v=Ne(u.text??""),f=ge(v);if(!f)return h.validationError="Failed to parse JSON",{result:{payload:null,debugInfo:h}};let I=null;return Array.isArray(f)?I=f.reduce((T,k)=>{if(k&&typeof k=="object"){const y=k;Array.isArray(y.nodesToAdd)&&(T.nodesToAdd=[...T.nodesToAdd??[],...y.nodesToAdd]),Array.isArray(y.edgesToAdd)&&(T.edgesToAdd=[...T.edgesToAdd??[],...y.edgesToAdd]),y.observations&&!T.observations&&(T.observations=y.observations),y.rationale&&!T.rationale&&(T.rationale=y.rationale)}return T},{}):typeof f=="object"&&(I=f),h.parsedPayload=I??void 0,I&&(I.observations&&!h.observations&&(h.observations=I.observations),I.rationale&&!h.rationale&&(h.rationale=I.rationale)),I&&(I.nodesToAdd||I.edgesToAdd)?{result:{payload:I,debugInfo:h}}:(h.validationError="Parsed JSON missing nodesToAdd or edgesToAdd",{result:{payload:null,debugInfo:h}})}catch(p){throw console.error(`fetchConnectorChains_Service error (Attempt ${String(i+1)}/${String(W+1)}):`,p),p}})??{payload:null,debugInfo:null}},ks=async(e,t,n,o)=>{if(!ee())return console.error("decideFeatureHierarchyUpgrade_Service: API Key not configured."),null;const a=`A feature node has acquired a child which violates the map hierarchy rules.
Parent Feature: "${e.placeName}" (Desc: "${e.data.description}")
Child Node: "${t.placeName}" (Type: ${t.data.nodeType})
Choose the best fix: "convert_child" to make the child a sibling, or "upgrade_parent" to upgrade the parent to a higher-level node.`,r="Respond only with convert_child or upgrade_parent.";return ie(async s=>{var i;try{se(ae.correction.icon);const{response:c}=await re({modelNames:[Se,X,Q],prompt:a,systemInstruction:r,temperature:Ae,label:"Corrections",debugLog:o}),l=((i=c.text)==null?void 0:i.trim())??null;if(l){const d=l.trim().toLowerCase();if(d.includes("upgrade"))return{result:"upgrade_parent"};if(d.includes("convert")||d.includes("sibling"))return{result:"convert_child"}}}catch(c){throw console.error(`decideFeatureHierarchyUpgrade_Service error (Attempt ${String(s+1)}/$${String(W+1)}):`,c),c}return{result:null}})},Ls=async(e,t)=>{if(!ee())return console.error("chooseHierarchyResolution_Service: API Key not configured."),null;const n=e.options.map((r,s)=>`${String(s+1)}. ${r}`).join(`
`),o=`Scene: ${e.sceneDescription}
Parent: "${e.parent.placeName}" (${e.parent.data.nodeType}) - ${e.parent.data.description}
Child: "${e.child.placeName}" (${e.child.data.nodeType}) - ${e.child.data.description}
Choose the most sensible resolution for their hierarchy conflict:
${n}
Respond ONLY with the option number.`,a="Answer with the single number of the best option.";return ie(async r=>{var s;try{se(ae.correction.icon);const{response:i}=await re({modelNames:[Se,X,Q],prompt:o,systemInstruction:a,temperature:Ae,label:"Corrections",debugLog:t}),c=(s=i.text)==null?void 0:s.trim();if(c){const l=parseInt(c.trim(),10);if(Number.isInteger(l)&&l>=1&&l<=e.options.length)return{result:l}}}catch(i){throw console.error(`chooseHierarchyResolution_Service error (Attempt ${String(r+1)}/$${String(W+1)}):`,i),i}return{result:null}})};function Ds(e){if(typeof e!="object"||e===null)return!1;const t=e;return typeof t.placeName!="string"||t.placeName.trim()===""?(console.warn("Validation Error (NodeAdd): 'placeName' is required. Value:",t.placeName),!1):!Array.isArray(t.aliases)||!t.aliases.every(n=>typeof n=="string")?(console.warn("Validation Error (NodeAdd): 'aliases' must be an array of strings. Value:",t.aliases),!1):typeof t.description!="string"||t.description.trim()===""?(console.warn("Validation Error (NodeAdd): 'description' is required and must be a non-empty string. Value:",t.description),!1):typeof t.nodeType!="string"||!$t.includes(t.nodeType)?(console.warn("Validation Error (NodeAdd): 'nodeType' is invalid. Value:",t.nodeType),!1):typeof t.parentNodeId!="string"||t.parentNodeId.trim()===""?(console.warn("Validation Error (NodeAdd): 'parentNodeId' is required. Value:",t.parentNodeId),!1):typeof t.status!="string"||!ft.includes(t.status)?(console.warn("Validation Error (NodeAdd): 'status' is invalid. Value:",t.status),!1):!0}function _s(e){if(typeof e!="object"||e===null)return!1;const t=e;return typeof t.placeName!="string"||t.placeName.trim()===""?(console.warn("Validation Error (NodeUpdate): 'placeName' is required. Value:",t.placeName),!1):t.aliases!==void 0&&!(Array.isArray(t.aliases)&&t.aliases.every(n=>typeof n=="string"))?(console.warn("Validation Error (NodeUpdate): 'aliases' must be an array of strings if provided. Value:",t.aliases),!1):t.description!==void 0&&typeof t.description!="string"?(console.warn("Validation Error (NodeUpdate): 'description' must be a string if provided. Value:",t.description),!1):t.nodeType!==void 0&&(typeof t.nodeType!="string"||!$t.includes(t.nodeType))?(console.warn("Validation Error (NodeUpdate): 'nodeType' is invalid. Value:",t.nodeType),!1):t.parentNodeId!==void 0&&typeof t.parentNodeId!="string"?(console.warn("Validation Error (NodeUpdate): 'parentNodeId' must be a string if provided. Value:",t.parentNodeId),!1):t.status!==void 0&&(typeof t.status!="string"||!ft.includes(t.status))?(console.warn("Validation Error (NodeUpdate): 'status' is invalid. Value:",t.status),!1):t.newPlaceName!==void 0&&(typeof t.newPlaceName!="string"||t.newPlaceName.trim()==="")?(console.warn("Validation Error (NodeUpdate): 'newPlaceName' must be a non-empty string if provided. Value:",t.newPlaceName),!1):!0}function Rs(e){if(typeof e!="object"||e===null)return!1;const t=e;if(typeof t.sourcePlaceName!="string"||t.sourcePlaceName.trim()==="")return console.warn("Validation Error (EdgeAdd): 'sourcePlaceName' is required. Value:",t.sourcePlaceName),!1;if(typeof t.targetPlaceName!="string"||t.targetPlaceName.trim()==="")return console.warn("Validation Error (EdgeAdd): 'targetPlaceName' is required. Value:",t.targetPlaceName),!1;if(typeof t.type!="string")return console.warn("Validation Error (EdgeAdd): 'type' is invalid. Value:",t.type),!1;const n=t.type;if(!yt.includes(n))return console.warn("Validation Error (EdgeAdd): 'type' is invalid. Value:",t.type),!1;if(typeof t.status!="string")return console.warn("Validation Error (EdgeAdd): 'status' is invalid. Value:",t.status),!1;const o=t.status;return vt.includes(o)?t.description!==void 0&&typeof t.description!="string"?(console.warn("Validation Error (EdgeAdd): 'description' must be a string if provided. Value:",t.description),!1):t.travelTime!==void 0&&typeof t.travelTime!="string"?(console.warn("Validation Error (EdgeAdd): 'travelTime' must be a string if provided. Value:",t.travelTime),!1):!0:(console.warn("Validation Error (EdgeAdd): 'status' is invalid. Value:",t.status),!1)}function Os(e){if(typeof e!="object"||e===null)return!1;const t=e;if(typeof t.sourcePlaceName!="string"||t.sourcePlaceName.trim()==="")return console.warn("Validation Error (EdgeUpdate): 'sourcePlaceName' is required. Value:",t.sourcePlaceName),!1;if(typeof t.targetPlaceName!="string"||t.targetPlaceName.trim()==="")return console.warn("Validation Error (EdgeUpdate): 'targetPlaceName' is required. Value:",t.targetPlaceName),!1;if(t.type!==void 0){if(typeof t.type!="string")return console.warn("Validation Error (EdgeUpdate): 'type' is invalid. Value:",t.type),!1;const n=t.type;if(!yt.includes(n))return console.warn("Validation Error (EdgeUpdate): 'type' is invalid. Value:",t.type),!1}if(t.status!==void 0){if(typeof t.status!="string")return console.warn("Validation Error (EdgeUpdate): 'status' is invalid. Value:",t.status),!1;const n=t.status;if(!vt.includes(n))return console.warn("Validation Error (EdgeUpdate): 'status' is invalid. Value:",t.status),!1}return t.description!==void 0&&typeof t.description!="string"?(console.warn("Validation Error (EdgeUpdate): 'description' must be a string if provided. Value:",t.description),!1):t.travelTime!==void 0&&typeof t.travelTime!="string"?(console.warn("Validation Error (EdgeUpdate): 'travelTime' must be a string if provided. Value:",t.travelTime),!1):!0}function Ra(e){return typeof e!="object"||e===null?(console.warn("Validation Error (AIMapUpdatePayload): Payload is not an object or is null."),!1):e.nodesToAdd!=null&&(!Array.isArray(e.nodesToAdd)||!e.nodesToAdd.every(Ds))?(console.warn("Validation Error (AIMapUpdatePayload): 'nodesToAdd' is invalid."),!1):e.nodesToUpdate!=null&&(!Array.isArray(e.nodesToUpdate)||!e.nodesToUpdate.every(_s))?(console.warn("Validation Error (AIMapUpdatePayload): 'nodesToUpdate' is invalid."),!1):e.nodesToRemove!=null&&(!Array.isArray(e.nodesToRemove)||!e.nodesToRemove.every(xs))?(console.warn("Validation Error (AIMapUpdatePayload): 'nodesToRemove' is invalid."),!1):e.edgesToAdd!=null&&(!Array.isArray(e.edgesToAdd)||!e.edgesToAdd.every(Rs))?(console.warn("Validation Error (AIMapUpdatePayload): 'edgesToAdd' is invalid."),!1):e.edgesToUpdate!=null&&(!Array.isArray(e.edgesToUpdate)||!e.edgesToUpdate.every(Os))?(console.warn("Validation Error (AIMapUpdatePayload): 'edgesToUpdate' is invalid."),!1):e.edgesToRemove!=null&&(!Array.isArray(e.edgesToRemove)||!e.edgesToRemove.every(Us))?(console.warn("Validation Error (AIMapUpdatePayload): 'edgesToRemove' is invalid."),!1):e.suggestedCurrentMapNodeId!=null&&typeof e.suggestedCurrentMapNodeId!="string"?(console.warn("Validation Error (AIMapUpdatePayload): 'suggestedCurrentMapNodeId' must be a string or null if present. Value:",e.suggestedCurrentMapNodeId),!1):!0}function xs(e){if(typeof e!="object"||e===null)return!1;const t=e;return typeof t.nodeId!="string"||t.nodeId.trim()===""?(console.warn("Validation Error (NodeRemove): 'nodeId' is required. Value:",t.nodeId),!1):t.nodeName!==void 0&&(typeof t.nodeName!="string"||t.nodeName.trim()==="")?(console.warn("Validation Error (NodeRemove): 'nodeName' must be a non-empty string if provided. Value:",t.nodeName),!1):!0}function Us(e){if(typeof e!="object"||e===null)return!1;const t=e;return typeof t.edgeId!="string"||t.edgeId.trim()===""?(console.warn("Validation Error (EdgeRemove): 'edgeId' is required. Value:",t.edgeId),!1):t.sourceId!==void 0&&(typeof t.sourceId!="string"||t.sourceId.trim()==="")?(console.warn("Validation Error (EdgeRemove): 'sourceId' must be a non-empty string if provided. Value:",t.sourceId),!1):t.targetId!==void 0&&(typeof t.targetId!="string"||t.targetId.trim()==="")?(console.warn("Validation Error (EdgeRemove): 'targetId' must be a non-empty string if provided. Value:",t.targetId),!1):!0}const Eo=(e,t,n)=>{if(e){if(e.status){const o=us[e.status.toLowerCase()];o!==void 0&&(e.status=o),ft.includes(e.status)||t.push(`${n} invalid status "${e.status}"`)}if(e.nodeType){const o=ps[e.nodeType.toLowerCase()];o!==void 0&&(e.nodeType=o),$t.includes(e.nodeType)||t.push(`${n} invalid nodeType "${e.nodeType}"`)}}},Po=(e,t,n)=>{if(e){if(e.type){const o=ms[e.type.toLowerCase()];o!==void 0&&(e.type=o),yt.includes(e.type)||t.push(`${n} invalid type "${e.type}"`)}if(e.status){const o=gs[e.status.toLowerCase()];o!==void 0&&(e.status=o),vt.includes(e.status)||t.push(`${n} invalid status "${e.status}"`)}}},js=new Set(hs),Fs=new Set(fs);function Vs(e){const t=[],n=e.nodesToRemove?[...e.nodesToRemove]:[];(e.nodesToUpdate??[]).forEach(r=>{var i;const s=(i=r.status)==null?void 0:i.toLowerCase();s&&js.has(s)?n.push({nodeId:r.placeName,nodeName:r.placeName}):t.push(r)}),e.nodesToUpdate=t.length>0?t:void 0,e.nodesToRemove=n.length>0?n:void 0;const o=[],a=e.edgesToRemove?[...e.edgesToRemove]:[];(e.edgesToUpdate??[]).forEach(r=>{var i;const s=(i=r.status)==null?void 0:i.toLowerCase();s&&Fs.has(s)?a.push({edgeId:"",sourceId:r.sourcePlaceName,targetId:r.targetPlaceName}):o.push(r)}),e.edgesToUpdate=o.length>0?o:void 0,e.edgesToRemove=a.length>0?a:void 0}function Gs(e){const t=(o,a,r)=>{const s=o.toLowerCase(),i=a.toLowerCase(),c=(r??"any").toLowerCase();return s<i?`${s}|${i}|${c}`:`${i}|${s}|${c}`},n=(o,a)=>{if(!o)return o;const r=new Set,s=[];for(const i of o){const c=t(i.sourcePlaceName,i.targetPlaceName,a(i));r.has(c)||(r.add(c),s.push(i))}return s};if(e.edgesToAdd=n(e.edgesToAdd??void 0,o=>o.type),e.edgesToUpdate=n(e.edgesToUpdate??void 0,o=>o.type),e.edgesToRemove){const o=new Set,a=[];for(const r of e.edgesToRemove){const s=r.edgeId.toLowerCase();o.has(s)||(o.add(s),a.push(r))}e.edgesToRemove=a}}function to(e){const t=[];return(e.nodesToAdd??[]).forEach((n,o)=>{Eo(n,t,`nodesToAdd[${String(o)}]`)}),(e.nodesToUpdate??[]).forEach((n,o)=>{Eo(n,t,`nodesToUpdate[${String(o)}]`)}),(e.edgesToAdd??[]).forEach((n,o)=>{Po(n,t,`edgesToAdd[${String(o)}]`)}),(e.edgesToUpdate??[]).forEach((n,o)=>{Po(n,t,`edgesToUpdate[${String(o)}]`)}),t}function Ys(e){const t=[],n=[];for(const o of e.nodesToRemove??[])/^edge_/i.test(o.nodeId)?n.push({edgeId:o.nodeId}):t.push(o);for(const o of e.edgesToRemove??[])/^node_/i.test(o.edgeId)?t.push({nodeId:o.edgeId,nodeName:o.edgeId}):n.push(o);e.nodesToRemove=t.length>0?t:void 0,e.edgesToRemove=n.length>0?n:void 0}const $o=async(e,t,n)=>{if(!ee())return console.error("fetchCorrectedMapUpdatePayload_Service: API Key not configured."),null;const o=`You are an AI assistant fixing a malformed map update payload for a text adventure game.

Malformed JSON:
\`\`\`json
${e}
\`\`\`
Validation Error: "${t??"Unknown"}"
Respond ONLY with the corrected JSON object.`,a=`Correct the map update payload so it adheres to the expected structure. Valid node types: ${Mn}. Valid node statuses: ${kn}. Valid edge types: ${Ln}. Valid edge statuses: ${Dn}. ${ht} ${Wt} ${Fe} Theme Guidance: ${n.storyGuidance}`;return ie(async r=>{try{se(ae.correction.icon);const{response:s}=await re({modelNames:[X,Q],prompt:o,systemInstruction:a,responseMimeType:"application/json",temperature:Ae,label:"Corrections"}),i=ge(Ne(s.text??""));if(i&&(to(i),Ra(i)))return{result:i};console.warn(`fetchCorrectedMapUpdatePayload_Service (Attempt ${String(r+1)}/${String(W+1)}): corrected payload invalid.`,i)}catch(s){throw console.error(`fetchCorrectedMapUpdatePayload_Service error (Attempt ${String(r+1)}/${String(W+1)}):`,s),s}return{result:null}})},no=async(e,t,n,o,a,r)=>{if(!ee())return console.error(`fetchCorrectedName_Service: API Key not configured. Cannot correct ${e} name.`),null;if(a.length===0)return console.warn(`fetchCorrectedName_Service: No valid names provided for ${e} to match against. Returning original: "${t}".`),t;const s=`The corrected ${e} name MUST be one of these exact, case-sensitive full names: [${a.map(l=>`"${l}"`).join(", ")}].`,i=`
You are an AI assistant specialized in matching a potentially incorrect or partial entity name against a predefined list of valid names, using narrative context.
Entity Type: ${e}
Malformed/Partial Name Provided by another AI: "${t}"

Narrative Context (use this to understand which entity was likely intended):
- Log Message: "${n??"Not specified, infer from scene."}"
- Scene Description: "${o??"Not specified, infer from log."}"

List of Valid Names:
${s}

Task: Based on the context and the list of valid names, determine the correct full string name.
Respond ONLY with the single, corrected ${e} name as a string.
If no suitable match can be confidently made, respond with an empty string.`,c=`Your task is to match a malformed ${e} name against a provided list of valid names, using narrative context. Respond ONLY with the best-matched string from the valid list, or an empty string if no confident match is found. Adhere to the theme context: ${r.storyGuidance}`;return ie(async l=>{var d;try{se(ae.correction.icon);const{response:p}=await re({modelNames:[Se,X,Q],prompt:i,systemInstruction:c,temperature:Ae,label:"Corrections"}),u=((d=p.text)==null?void 0:d.trim())??null;if(u!==null){let m=u.trim();if(m=m.replace(/^['"]+|['"]+$/g,"").trim(),m==="")return console.warn(`fetchCorrectedName_Service (Attempt ${String(l+1)}/${String(W+1)}): AI indicated no match for ${e} "${t}" from the valid list.`),{result:null,retry:!1};if(a.includes(m))return console.warn("fetchCorrectedName_Service: Returned corrected Name ",m,"."),{result:m};console.warn(`fetchCorrectedName_Service (Attempt ${String(l+1)}/${String(W+1)}): AI returned name "${m}" for ${e} which is NOT in the validNamesList. Discarding result.`)}else console.warn(`fetchCorrectedName_Service (Attempt ${String(l+1)}/${String(W+1)}): AI call failed for ${e}. Received: null`)}catch(p){throw console.error(`fetchCorrectedName_Service error (Attempt ${String(l+1)}/${String(W+1)}):`,p),p}return{result:null}})},Hs=async(e,t,n)=>{if(!ee())return console.error("assignSpecificNamesToDuplicateNodes_Service: API Key not configured."),[];const o=new Map;e.forEach(r=>{const s=r.placeName.toLowerCase(),i=o.get(s)??[];i.push(r),o.set(s,i)});const a=[];for(const r of Array.from(o.values()))if(!(r.length<=1))for(let s=1;s<r.length;s+=1){const i=r[s],c=`You are an AI assistant disambiguating map location names in a text adventure game.
Theme: "${t.name}"
Another map node shares the name "${r[0].placeName}". Provide a short, unique new name for the following node.
Node Type: ${i.data.nodeType}
Aliases: ${(i.data.aliases??[]).join(", ")||"None"}
Description: ${i.data.description}`,l="Respond ONLY with a short Title Case name that distinguishes this location.",d=await ie(async p=>{var u;try{se(ae.correction.icon);const{response:m}=await re({modelNames:[Se,X,Q],prompt:c,systemInstruction:l,temperature:Ae,label:"Corrections",debugLog:n}),g=(u=m.text)==null?void 0:u.trim();if(g){const h=g.replace(/^['"]+|['"]+$/g,"").trim();if(h)return{result:h}}}catch(m){throw console.error(`assignSpecificNamesToDuplicateNodes_Service error (Attempt ${String(p+1)}/${String(W+1)}):`,m),m}return{result:null}});d&&a.push({nodeId:i.id,newName:d})}return a},Mo={foreign:{notRecovered:"The text appears to be in an unfamiliar language and might be translated",recovered:"The foreign text has been translated"},runic:{notRecovered:"The text is written in strange runes and might be translated",recovered:"The runic text has been translated"},glitching:{notRecovered:"The text is glitching or corrupted and might be restored",recovered:"The previously corrupted text has been restored"},encrypted:{notRecovered:"The text is encoded and might be decoded",recovered:"The text has been decoded"}},qe=(e,t="",n=!0,o=!0,a=!1,r=!1,s=!1)=>{const i=Array.isArray(e)?e:[e];if(i.length===0)return"Empty.";const c=a?"; ":`;
`;return i.map(l=>{let d=`${t}${l.id} - "${l.name}"`;const p=[];if(n){if(p.push(`Type: "${l.type}"`),r&&l.tags&&l.tags.length>0&&p.push(`Tags: ${l.tags.join(", ")}`),s&&l.tags&&l.tags.length>0){const u=l.tags.includes("recovered"),m=l.tags.map(g=>{const h=Mo[g];return h?u?h.recovered:h.notRecovered:null}).filter(g=>!!g);m.length>0&&p.push(m.join(" "))}p.push(`Description: "${l.isActive&&l.activeDescription?l.activeDescription:l.description}"${l.isActive?", It is active":""}`),d+=` (${p.join(", ")})`}else{const u=[];if(r&&l.tags&&l.tags.length>0&&u.push(`Tags: ${l.tags.join(", ")}`),s&&l.tags&&l.tags.length>0){const m=l.tags.includes("recovered"),g=l.tags.map(h=>{const v=Mo[h];return v?m?v.recovered:v.notRecovered:null}).filter(h=>!!h);g.length>0&&u.push(g.join(" "))}u.length>0&&(d+=` (${u.join(", ")})`)}if(o&&l.knownUses&&l.knownUses.length>0){const u=l.knownUses.filter(m=>{const g=!!l.isActive;return m.appliesWhenActive!==void 0&&m.appliesWhenInactive!==void 0?m.appliesWhenActive&&g||m.appliesWhenInactive&&!g:m.appliesWhenActive!==void 0?m.appliesWhenActive===g:m.appliesWhenInactive!==void 0?m.appliesWhenInactive===!g:!0});u.length>0&&(d+=`, Available Actions: ${u.map(m=>`"${m.actionName}"`).join(", ")}`)}return d}).join(c)},dn=e=>{if(!e||!Array.isArray(e.acts)||e.acts.length===0)return!1;const t=e.currentAct-1;if(t<0||t>=e.acts.length)return!1;const n=e.acts.at(t);return!(!n||!Array.isArray(n.sideObjectives))},Bs=()=>{const e=[],t=(a,r)=>{const s=e[a];e[a]=e[r],e[r]=s},n=a=>{for(;a>0;){const r=Math.floor((a-1)/2);if(e[r].priority<=e[a].priority)break;t(r,a),a=r}},o=a=>{const r=e.length-1;for(;;){const s=a*2+1,i=a*2+2;let c=a;if(s<=r&&e[s].priority<e[c].priority&&(c=s),i<=r&&e[i].priority<e[c].priority&&(c=i),c===a)break;t(a,c),a=c}};return{push(a,r){e.push({value:a,priority:r}),n(e.length-1)},pop(){if(e.length===0)return;const a=e[0].value,r=e.pop();return r!==void 0&&e.length>0&&(e[0]=r,o(0)),a},size(){return e.length}}},Ws={open:1,accessible:1,active:1,one_way:1,rumored:5,closed:1/0,locked:1/0,blocked:1/0,hidden:1/0,collapsed:1/0,removed:1/0,inactive:1/0},xt=20,un=e=>{const t=new Map,n=new Map(e.nodes.map(i=>[i.id,i])),o=i=>{const c=i?n.get(i):void 0;return!!c&&c.data.status!=="blocked"},a=new Map;for(const i of e.nodes){const c=i.data.parentNodeId;if(!c)continue;a.has(c)||a.set(c,[]);const l=a.get(c);l&&l.push(i.id)}const r=(i,c,l,d)=>{t.has(i)||t.set(i,[]);const p=t.get(i);p&&p.push({edgeId:l,to:c,cost:d})};for(const i of e.edges){if(!o(i.sourceNodeId)||!o(i.targetNodeId))continue;const c=i.data.status??"open",l=Ws[c];l!==1/0&&(r(i.sourceNodeId,i.targetNodeId,i.id,l),c!=="one_way"&&r(i.targetNodeId,i.sourceNodeId,i.id,l))}for(const i of e.nodes){const c=i.data.parentNodeId;if(!c||c==="Universe"||!o(i.id)||!o(c)||!(a.get(c)??[]).some(m=>m!==i.id&&o(m)))continue;const p=`hierarchy:${i.id}->${c}`,u=`hierarchy:${c}->${i.id}`;r(i.id,c,p,xt),r(c,i.id,u,xt)}const s=new Map;for(const i of e.nodes){const c=i.data.parentNodeId;if(!c)continue;s.has(c)||s.set(c,[]);const l=s.get(c);l&&l.push(i)}for(const i of s.values()){const c=p=>p.data.nodeType==="feature"||p.data.isFeature===!0,l=i.filter(c),d=i.filter(p=>!c(p));for(const p of l)for(const u of d){if(!o(p.id)||!o(u.id))continue;const m=`hierarchy:${p.id}->${u.id}`,g=`hierarchy:${u.id}->${p.id}`;r(p.id,u.id,m,xt),r(u.id,p.id,g,xt)}}return{adjacency:t,nodeMap:n,childrenByParent:a}},Oa=(e,t,n,o)=>{const{adjacency:a,nodeMap:r,childrenByParent:s}=o??un(e),i=g=>{const h=g?r.get(g):void 0;return!!h&&h.data.status!=="blocked"},c=(g,h)=>{const v=s.get(g);if(v!=null&&v.includes(h))return v.some(I=>I!==h&&I!==t&&i(I));const f=s.get(h);return f!=null&&f.includes(g)?f.some(I=>I!==g&&I!==t&&i(I)):!0},l=new Map,d=new Map,p=Bs();for(p.push({nodeId:t,cost:0},0),l.set(t,0);p.size()>0;){const g=p.pop();if(!g)break;if(g.cost!==(l.get(g.nodeId)??1/0))continue;if(g.nodeId===n)break;const h=a.get(g.nodeId)??[];for(const v of h){if(v.edgeId.startsWith("hierarchy:")&&!c(g.nodeId,v.to))continue;const f=g.cost+v.cost;f<(l.get(v.to)??1/0)&&(l.set(v.to,f),d.set(v.to,{from:g.nodeId,edgeId:v.edgeId}),p.push({nodeId:v.to,cost:f},f))}}if(!l.has(n))return null;const u=[];let m=n;for(u.unshift({step:"node",id:m});m!==t;){const g=d.get(m);if(!g)break;u.unshift({step:"edge",id:g.edgeId}),m=g.from,u.unshift({step:"node",id:m})}return u},mt=(e,t="",n=!0,o=!0,a=!0,r=!1)=>{const s=Array.isArray(e)?e:[e];if(s.length===0)return"";const i=r?"; ":`;
`;return s.map(l=>{let d=`${t}${l.id} - "${l.name}"`;return n&&l.aliases&&l.aliases.length>0&&(d+=` (aka ${l.aliases.map(p=>`"${p}"`).join(", ")})`),o&&(d+=` (${l.presenceStatus}`,l.presenceStatus==="companion"||l.presenceStatus==="nearby"?d+=`, ${l.preciseLocation??(l.presenceStatus==="companion"?"with you":"nearby")}`:d+=`, Last Location: ${l.lastKnownLocation??"Unknown"}`,d+=")"),a&&(d+=`, "${l.description}"`),d}).join(i)+"."},xa=e=>e.length===0?"":" - "+e.join(`
 - `),oo=(e,t,n,o,a)=>{const r=[];e.forEach(d=>{const p=[d.placeName,...d.data.aliases??[]];new RegExp(p.map(m=>`\\b${m.replace(/[.*+?^${}()|[\\]\\]/g,"\\$&")}\\b`).join("|"),"i").test(n)&&r.push(d)});const s=[];t.forEach(d=>{const p=[d.name,...d.aliases??[]];new RegExp(p.map(m=>`\\b${m.replace(/[.*+?^${}()|[\\]\\]/g,"\\$&")}\\b`).join("|"),"i").test(n)&&s.push(d)});let i="";const c=nt(r,!0);c&&c!=="None specifically known in this theme yet."&&(i+=`${o}
${c}
`);const l=mt(s," - ");return l&&(i+=`${a}
${l}`),i.trimStart()},Js=(e,t,n)=>{var y,P,S;if(!t||!n||t===n)return null;const o=un(e),a=Oa(e,t,n,o);if(!a||a.length<3)return null;const r=e.nodes.find(C=>C.id===n),s=(r==null?void 0:r.placeName)??n,i=r==null?void 0:r.data.parentNodeId,c=i&&i!=="Universe"?((y=e.nodes.find(C=>C.id===i))==null?void 0:y.placeName)??i:null,l=c?`${s} in ${c}`:s,d=(r==null?void 0:r.data.status)==="rumored",p=a[1],u=a[2],m=a.length>4?a[4]:void 0;if(p.step!=="edge"||u.step!=="node")return null;const g=e.nodes.find(C=>C.id===u.id),h=(g==null?void 0:g.placeName)??u.id,v=m&&m.step==="node"?e.nodes.find(C=>C.id===m.id):null,f=m?(v==null?void 0:v.placeName)??m.id:"",I=(g==null?void 0:g.data.status)==="rumored",T=(v==null?void 0:v.data.status)==="rumored";let k=d?`Player wants to reach a rumored place - ${l}.`:`Player wants to travel to ${l}.`;if(p.id.startsWith("hierarchy:")){const[C,$]=p.id.split(":")[1].split("->"),M=((P=e.nodes.find(w=>w.id===C))==null?void 0:P.placeName)??C,A=((S=e.nodes.find(w=>w.id===$))==null?void 0:S.placeName)??$;k+=` The journey leads towards ${A} in the general area of ${M}, and then towards ${T?"a rumored place - "+f:f}.`}else{const C=e.edges.find(A=>A.id===p.id),$=(C==null?void 0:C.data.status)??"open",M=(C==null?void 0:C.data.description)??(C==null?void 0:C.data.type)??"path";$==="rumored"?k+=` There is a rumor a path exists from here to ${I?"a rumored place - "+h:h}.`:k+=` The path leads through ${M} towards ${I?"a rumored place - "+h:h}.`}return k},ao=e=>[`Geography: ${e.geography}`,`Climate: ${e.climate}`,`Technology Level: ${e.technologyLevel}`,`Supernatural Elements: ${e.supernaturalElements}`,`Major Factions: ${e.majorFactions.join(", ")}`,`Key Resources: ${e.keyResources.join(", ")}`,`Cultural Notes: ${e.culturalNotes.join(", ")}`,`Notable Locations: ${e.notableLocations.join(", ")}`].join(`
`),pn=(e,t=!1)=>{const n=[`Player Character Name: ${e.name}`,`Gender: ${e.gender}.`,`Occupation: ${e.occupation}.`,`Traits: ${e.traits.join(", ")}.`];return t&&e.startingItems.length>0&&n.push(`Starting items: ${e.startingItems.join(", ")}.`),n.join(`
`)},Ua=e=>[`5 years ago: ${e.fiveYearsAgo}`,`1 year ago: ${e.oneYearAgo}`,`6 months ago: ${e.sixMonthsAgo}`,`1 month ago: ${e.oneMonthAgo}`,`1 week ago: ${e.oneWeekAgo}`,`Yesterday: ${e.yesterday}`,`Now: ${e.now}`].join(`
`),ro=e=>{if(!dn(e))return"";const t=e.acts[e.currentAct-1],n=t.sideObjectives.join(", ");return[`Arc Title: ${e.title}`,`Overview: ${e.overview}`,`Current Act ${String(t.actNumber)}: ${t.title}`,`Act Description: ${t.description}`,`Main Objective: ${t.mainObjective}`,`Side Objectives: ${n}`,`Success Condition: ${t.successCondition}`].join(`
`)},Ks=e=>(e.mapHint!==void 0&&(e.mapHint=e.mapHint.trim()),e.playerItemsHint!==void 0&&(e.playerItemsHint=e.playerItemsHint.trim()),e.worldItemsHint!==void 0&&(e.worldItemsHint=e.worldItemsHint.trim()),e.npcItemsHint!==void 0&&(e.npcItemsHint=e.npcItemsHint.trim()),Array.isArray(e.newItems)&&(e.newItems=e.newItems.filter(Ss)),e),qs=(e,t)=>{const n=Ne(e),o=ge(n);try{if(!o)throw new Error("JSON parse failed");if(!Array.isArray(o.npcResponses)||!o.npcResponses.every(r=>typeof r.speaker=="string"&&typeof r.line=="string")||!Array.isArray(o.playerOptions)||!o.playerOptions.every(r=>typeof r=="string")||o.dialogueEnds!==void 0&&typeof o.dialogueEnds!="boolean"||o.updatedParticipants!==void 0&&(!Array.isArray(o.updatedParticipants)||!o.updatedParticipants.every(r=>typeof r=="string")))return console.warn("Parsed dialogue JSON does not match DialogueAIResponse structure:",o),null;o.playerOptions.length===0&&(o.playerOptions=["End Conversation."]);const a=o;return t&&t.length>0&&a.npcResponses.forEach((r,s)=>{t[s]&&(r.thought=t[s])}),a}catch(a){return console.warn("Failed to parse dialogue JSON response from AI:",a),console.debug("Original dialogue response text:",e),null}},ja=(e,t)=>qs(e,t),zs=async(e,t,n,o,a,r,s,i)=>{if(!ee())return console.error("fetchCorrectedDialogueSetup_Service: API Key not configured."),null;const c=o.length>0?mt(o," - "):"None specifically known in this theme yet.",l=nt(a,!0),d=r.map(g=>g.name).join(", ")||"Empty",u=`
Role: You are an AI assistant correcting a malformed 'dialogueSetup' JSON payload for a text adventure game.
Task: Reconstruct the 'dialogueSetup' object based on narrative context and the malformed data.

Malformed 'dialogueSetup' Payload:
\`\`\`json
${JSON.stringify(i)}
\`\`\`

Narrative Context:
- Log Message: "${e??"Not specified"}"
- Scene Description: "${t??"Not specified"}"
- Theme Guidance: "${n.storyGuidance}"
- Known/Available NPCs for Dialogue: ${c}
- Known Map Locations: ${l}
- Player Inventory: ${d}
 - Player Gender: "${s}"

Required JSON Structure for corrected 'dialogueSetup':
{
  "initialNpcResponses": [{ "speaker": "NPCr Name 1", "line": "Their first line." }],
  "initialPlayerOptions": [],
  "participants": ["NPC Name 1", "NPC Name 2"?]
}

Respond ONLY with the single, complete, corrected JSON object for 'dialogueSetup'.`,m="Correct a malformed 'dialogueSetup' JSON payload. Ensure 'participants' are valid NPCs, 'initialNpcResponses' are logical, and 'initialPlayerOptions' are varied with an exit option. Adhere strictly to the JSON format.";return ie(async g=>{try{se(ae.correction.icon);const{response:h}=await re({modelNames:[X,Q],prompt:u,systemInstruction:m,responseMimeType:"application/json",temperature:Ae,label:"Corrections"}),v=ge(Ne(h.text??""));if(v&&jn(v))return{result:v};console.warn(`fetchCorrectedDialogueSetup_Service (Attempt ${String(g+1)}/${String(W+1)}): Corrected dialogueSetup payload invalid. Response:`,v)}catch(h){throw console.error(`fetchCorrectedDialogueSetup_Service error (Attempt ${String(g+1)}/${String(W+1)}):`,h),h}return{result:null}})},Qs=async(e,t,n,o)=>{if(!ee())return console.error("fetchCorrectedDialogueTurn_Service: API Key not configured."),null;const a=t.map(i=>`"${i}"`).join(", ")||"None",r=`Role: You fix malformed JSON for a dialogue turn in a text adventure game.

Theme Guidance: "${n.storyGuidance}"

Malformed Dialogue Response:
\`\`\`
${e}
\`\`\`

Valid Participant Names: [${a}]

Required JSON Structure:
{
  "dialogueEnds": boolean?,
  "npcResponses": [{ "speaker": "Name", "line": "text" }],
  "playerOptions": ["text"],
  "updatedParticipants": ["Name"]?
}

Do NOT change the text of any npcResponses.line or playerOptions.
Ensure each "speaker" value is one of the valid participant names.
Respond ONLY with the corrected JSON object.`,s=`Correct a malformed dialogue turn JSON object without altering the dialogue text. Speaker names must be among: ${a}. Adhere strictly to JSON format.`;return ie(async i=>{var c;try{se(ae.correction.icon);const{response:l}=await re({modelNames:[Se,X,Q],prompt:r,systemInstruction:s,temperature:Ae,label:"Corrections"}),d=((c=l.text)==null?void 0:c.trim())??null;if(d){const p=ja(d,o);if(p!=null&&p.npcResponses.every(u=>t.includes(u.speaker)))return{result:p};console.warn(`fetchCorrectedDialogueTurn_Service (Attempt ${String(i+1)}/${String(W+1)}): corrected response invalid or speakers not in list.`,d)}else console.warn(`fetchCorrectedDialogueTurn_Service (Attempt ${String(i+1)}/${String(W+1)}): AI returned empty response.`)}catch(l){throw console.error(`fetchCorrectedDialogueTurn_Service error (Attempt ${String(i+1)}/${String(W+1)}):`,l),l}return{result:null}})},Xs=kr,Fa=Xs.block,Zs=Array.from(new Set(Object.values(Fa)));let Ut=null;function ei(){return Ut||(Ut=ys(Fa,Zs),Ut)}function ti(e){return ei().some(([n])=>n.test(e))}function ni(e){return ti(e.actionName)}function ko(e){return e&&e.filter(t=>!ni(t))}const Lo=(e,t)=>{switch(t){case"create":{const n=e;if((typeof n.holderId!="string"||n.holderId.trim()==="")&&(n.holderId=ne),Ao(n,"create")){const o=n;return o.knownUses=ko(o.knownUses),{action:t,item:n}}return null}case"change":{const n=e,o=typeof n.type=="string"?n.type:void 0,a=typeof n.status=="string"?n.status:void 0,r=o?Qt(o):null,s=a?a.toLowerCase():null,i=o?o.toLowerCase():null;if(r&&Cn.has(r)||i&&Cn.has(i)||s&&Cn.has(s)){const c={id:typeof n.id=="string"?n.id:void 0,name:typeof n.name=="string"?n.name:void 0};return Co(c)?{action:"destroy",item:c}:null}if(Ao(e,"change")){const c=e;return c.knownUses=ko(c.knownUses),{action:"change",item:e}}return null}case"addDetails":return Da(e)?{action:"addDetails",item:e}:{action:"addDetails",item:e,invalidPayload:e};case"destroy":return Co(e)?{action:"destroy",item:e}:null;case"move":{const n=e;if(typeof n.id=="string"&&typeof n.newHolderId=="string"){const o={id:n.id,name:n.name,newHolderId:n.newHolderId};return{action:t,item:o}}return null}default:return null}},so=e=>{const t=Ne(e),n=ge(t);if(!n)return null;let o=null;const a=(s,i)=>{const c=[];for(const l of s){if(!l||typeof l!="object")continue;const d=Lo(l,i);d&&c.push(d)}return c},r=s=>{const i=[];for(const c of s){if(!c||typeof c!="object")continue;const l=c,d=typeof l.action=="string"?l.action:void 0,p=l.item&&typeof l.item=="object"?l.item:void 0;if(d&&p){const u=Lo(p,d);u&&i.push(u)}}return i};if(Array.isArray(n))o={itemChanges:a(n,"create")};else if(typeof n=="object"){const s=n,i=[];Array.isArray(s.create)&&i.push(...a(s.create,"create")),Array.isArray(s.change)&&i.push(...a(s.change,"change")),Array.isArray(s.move)&&i.push(...a(s.move,"move")),Array.isArray(s.destroy)&&i.push(...a(s.destroy,"destroy")),Array.isArray(s.addDetails)&&i.push(...a(s.addDetails,"addDetails")),Array.isArray(s.itemChanges)&&i.push(...r(s.itemChanges)),o={itemChanges:i,observations:typeof s.observations=="string"?s.observations:void 0,rationale:typeof s.rationale=="string"?s.rationale:void 0}}return o},oi={type:"array",items:{type:"object",properties:{action:{enum:hr},item:{type:"object",properties:{id:{type:"string"},name:{type:"string"},type:{enum:tt},description:{type:"string"},activeDescription:{type:"string"},isActive:{type:"boolean"},holderId:{type:"string",description:"ID of current holder such as player, node_* or npc_*"},newHolderId:{type:"string",description:"Used with move action to specify new holder"},newName:{type:"string",description:"Used with change action for transformations"},tags:{type:"array",items:{type:"string"}},knownUses:{type:"array",items:{type:"object",properties:{actionName:{type:"string"},promptEffect:{type:"string"},description:{type:"string"},appliesWhenActive:{type:"boolean"},appliesWhenInactive:{type:"boolean"}},required:["actionName","promptEffect","description"]}},chapters:{type:"array",items:{type:"object",properties:{heading:{type:"string"},description:{type:"string"},contentLength:{type:"number"}},required:["heading","description","contentLength"]}}},required:["name"]}},required:["action","item"]}},ai=async(e,t,n,o,a,r,s,i,c,l)=>{if(!ee())return console.error("fetchCorrectedItemChangeArray_Service: API Key not configured."),null;const d=`You are an AI assistant fixing a malformed inventory update JSON payload for a text adventure game.

## Malformed Payload:
\`\`\`json
${e}
\`\`\`

## Narrative Context:
- Log Message: "${t??"Not specified"}"
- Scene Description: "${n??"Not specified"}"
- Player Items Hint: "${o}"
- World Items Hint: "${a}"
- NPC Items Hint: "${r}"
- Current Place ID: "${s??"unknown"}"
- Companions: ${i}
- Nearby NPCs: ${c}
- Theme Guidance: "${l.storyGuidance||"General adventure theme."}"

Task: Provide ONLY the corrected JSON array of ItemChange objects.`,p=`Correct a JSON array of ItemChange objects for the inventory system.
Each element must be { "action": (${Kn}), "item": { ... } }.
Item properties must appear in this order: id, name, type, description, activeDescription, isActive, holderId, newHolderId, newName, tags, knownUses, chapters.
Valid item types: ${Jn}.

## Examples:
[
  { // Example for creating a new item from context
    "action": "create",
    "item": {
      "name": "Old Lantern",
      "type": "equipment",
      "description": "A dusty old lantern that still flickers faintly.",
      "activeDescription": "The lantern is lit and casts a warm glow.",
      "isActive": false,
      "holderId": "player",
      "tags": [],
      "knownUses": [
        {
          "actionName": "Light the Lantern",
          "promptEffect": "Light the lantern to illuminate the area.",
          "description": "Use this to light your way in dark places.",
          "appliesWhenActive": false,
          "appliesWhenInactive": true
        },
        {
          "actionName": "Extinguish the Lantern",
          "promptEffect": "Extinguish the lantern.",
          "description": "Extinguish and conserve the fuel",
          "appliesWhenActive": true,
          "appliesWhenInactive": false
        }
      ],
      "chapters": []
    }
  },
  { // Example for destroying an existing item
    "action": "destroy",
    "item": {
      "id": "item_old_lantern_7fr4",
      "name": "Old Lantern (flickering)"
    }
  },
  { // Example for moving an item to a new holder
    "action": "move",
    "item": {
      "id": "item_iron_sword_ab12",
      "name": "Iron Sword",
      "newHolderId": "npc_guard_4f3a"
    }
  },
  { // Example for toggling state on an existing item
    "action": "change",
    "item": {
      "id": "item_plasma_torch_7fr4",
      "name": "Plasma Torch",
      "isActive": true
    }
  },
  { // Example for adding new details to an existing item
    "action": "addDetails",
    "item": {
      "id": "item_mystic_orb_7fr4",
      "name": "Mystic Orb",
      "type": "single-use",
      "knownUses": [
        {
          "actionName": "Peer into the Orb",
          "promptEffect": "Peer into the Mystic Orb, trying to glimpse the future.",
          "description": "Try to see the beyond",
          "appliesWhenActive": true
        }
      ]
    }
  },
  { // Example for creating a single-page written item
    "action": "create",
    "item": {
      "name": "Smudged Note",
      "type": "page",
      "description": "A hastily scribbled message with a big smudge over it.",
      "holderId": "player",
      "tags": ["typed", "smudged"],
      "chapters": [
        {
          "heading": "Warning",
          "description": "A hastily scribbled message about the dangers of the sunken tunnel.",
          "contentLength": 50
        }
      ]
    }
  },
  { // Example for creating a multi-chapter book
    "action": "create",
    "item": {
      "name": "Explorer's Adventures",
      "type": "book",
      "description": "Weathered log of travels.",
      "holderId": "player",
      "tags": ["handwritten", "faded"],
      "chapters": [
        {
          "heading": "Preface",
          "description": "Introduction. Written by the author, explaining his decisions to start his travels.",
          "contentLength": 53
        },
        {
          "heading": "Journey One",
          "description": "First trip. The author travelled to Vibrant Isles in the search of the Endless Waterfall",
          "contentLength": 246
        },
        {
          "heading": "Journey Two",
          "description": "Second Trip. The author's adventure in Desolate Steppes in the search of Magnificent Oasis",
          "contentLength": 312
        },
        {
          "heading": "Final Thoughts",
          "description": "The author's contemplation about whether the journeys were worth it",
          "contentLength": 98
        }
      ]
    }
  }
]

Respond ONLY with the corrected JSON array.`;return ie(async u=>{try{se(ae.correction.icon);const{response:m}=await re({modelNames:[X,Q],prompt:d,systemInstruction:p,responseMimeType:"application/json",jsonSchema:oi,temperature:Ae,label:"Corrections"}),g=ge(Ne(m.text??"")),h=g?so(JSON.stringify(g)):null,v=h?h.itemChanges:null;if(v)return{result:v};console.warn(`fetchCorrectedItemChangeArray_Service (Attempt ${String(u+1)}/${String(W+1)}): corrected payload invalid.`,g)}catch(m){throw console.error(`fetchCorrectedItemChangeArray_Service error (Attempt ${String(u+1)}/${String(W+1)}):`,m),m}return{result:null}})},ri=e=>{const{currentTheme:t,currentQuest:n,currentObjective:o,currentScene:a,localTime:r,localEnvironment:s,localPlace:i,knownMainMapNodesInTheme:c,knownNPCsInTheme:l,inventory:d,heroSheet:p,dialogueHistory:u,playerLastUtterance:m,dialogueParticipants:g,relevantFacts:h}=e,v=p!==null?pn(p,!1):"The player character remains undescribed.",f=(p==null?void 0:p.gender)??"Male",I=e.storyArc?ro(e.storyArc):"";let T=[...u];T.length>0&&T[T.length-1].speaker.toLowerCase()==="player"&&T[T.length-1].line===m&&(T=T.slice(0,-1));const k=T.map(w=>({...w}));let y=!1;for(let w=k.length-1;w>=0;w--){const N=k[w];N.speaker.toLowerCase()==="player"?y=!0:y&&"thought"in N&&delete N.thought}const P=k.map(w=>`${w.thought?`Narrator THOUGHTS: "${w.thought}"
`:""}${w.speaker}: "${w.line}"`).join(`
`),S=d.length>0?d.map(w=>`${w.name} (Type: ${w.type}, Active: ${String(!!w.isActive)})`).join(", "):"Empty",C=nt(c,!0,!1);let $="## Known NPCs: ";l.length>0?$+=l.map(w=>{let N=`"${w.name}" (Description: ${w.description}; Presence: ${w.presenceStatus}`;return w.presenceStatus==="nearby"||w.presenceStatus==="companion"?N+=` at ${w.preciseLocation??"around"}`:N+=`, last seen: ${w.lastKnownLocation??"Unknown"}`,N+=")",N}).join("; ")+".":$+="None specifically known.";let M="";g.forEach(w=>{const N=l.find(L=>L.name===w);N!=null&&N.dialogueSummaries&&N.dialogueSummaries.length>0&&(M+=`
Recent Past Conversations involving ${w}:
`,N.dialogueSummaries.slice(-3).forEach(D=>{M+=`- Summary: "${D.summaryText}" (Participants: ${D.participants.join(", ")}; Time: ${D.timestamp}; Location: ${D.location})
`}))});const A=h.length>0?h.map(w=>`- ${w}`).join(`
`):"None";return`**Context for Dialogue Turn**
${I?`Narrative Arc:
${I}
`:`Current Theme: "${t.name}";
Theme Guidance: "${t.storyGuidance}";`}
Current Main Quest: "${n??"Not set"}";
Current Objective: "${o??"Not set"}";
Scene Description (for environmental context): "${a}";
Local Time: "${r??"Unknown"}", Environment: "${s??"Undetermined"}", Place: "${i??"Undetermined"}";

## Player Character Description:
Gender: ${f}.
${v}
Character Traits should slightly influence dialogue choices.

## Relevant Facts about the world:
${A}

## Player's Inventory:
${S}

## Known Locations:
${C}

${$}

## Dialogue Context:
- Current Dialogue Participants: ${g.join(", ")};
${M.trim()?M:`
- No specific past dialogue summaries available for current participants.`}

- Dialogue History (most recent last; lines starting with THOUGHT describe internal thoughts):
${P}

- Player's Last Utterance/Choice: "${m}"

Based on this context, provide the next part of the dialogue according to the DIALOGUE_SYSTEM_INSTRUCTION.
The NPC(s) should respond to the player's last utterance, taking into account any relevant past conversation summaries.
Provide new dialogue options, ensuring the last one is a way to end the dialogue.
`},si=e=>{var r,s,i;const t=e.dialogueLog.map(c=>`${c.speaker}: "${c.line}"`).join(`
`),n=e.inventory.length>0?e.inventory.map(c=>`${c.name} (Type: ${c.type})`).join(", "):"Empty",o=nt(e.mapDataForTheme.nodes.filter(c=>c.data.nodeType!=="feature"),!0,!1);let a="Known NPCs: ";return e.knownNPCsInTheme.length>0?a+=e.knownNPCsInTheme.map(c=>{let l=`"${c.name}" (Description: ${c.description}; Presence: ${c.presenceStatus}`;return c.presenceStatus==="nearby"||c.presenceStatus==="companion"?l+=` at ${c.preciseLocation??"around"}`:l+=`, last seen: ${c.lastKnownLocation??"Unknown"}`,l+=")",l}).join("; ")+".":a+="None specifically known.",`
 Context for Dialogue Summary:
${e.storyArc?`Narrative Arc: ${e.storyArc.title} (Act ${String(e.storyArc.currentAct)}: ${e.storyArc.acts[e.storyArc.currentAct-1].title})`:`Current Theme: "${((r=e.currentTheme)==null?void 0:r.name)??e.themeName}"
- Theme Guidance: "${((s=e.currentTheme)==null?void 0:s.storyGuidance)??"None"}"`}
- Current Main Quest (before dialogue): "${e.mainQuest??"Not set"}"
- Current Objective (before dialogue): "${e.currentObjective??"Not set"}"
- Scene Description (when dialogue started): "${e.currentScene}"
- Local Time: "${e.localTime??"Unknown"}", Environment: "${e.localEnvironment??"Undetermined"}", Place: "${e.localPlace??"Undetermined"}"
  - Player's Character Gender: "${((i=e.heroSheet)==null?void 0:i.gender)??"Male"}"

- Player's Inventory (before dialogue):
${n}
- Known Locations (before dialogue):
${o}
- ${a}
- Dialogue Participants: ${e.dialogueParticipants.join(", ")}

## Full Dialogue Transcript:
${t}

Based *only* on the Dialogue Transcript and the provided context, determine what specific game state changes (items, NPCs, quest/objective updates, log message, map updates) resulted *directly* from this dialogue.
The "logMessage" field in your response should be a concise summary suitable for the main game log.
Provide the next scene description and ${String(ze)} action options for the player as you would for a normal game turn.
If the dialogue revealed a new alias for an existing NPC, use "npcsUpdated" with "addAlias".
If the dialogue changed some NPC's general whereabouts, use "newLastKnownLocation" in "npcsUpdated".
If the dialogue revealed new map information (new locations, changed accessibility, etc.), or if Player's own location changed over the course of the dialogue, then set "mapUpdated": true.
`},ii=e=>{var a,r;const t=e.dialogueLog.map(s=>`  ${s.speaker}: ${s.line}`).join(`
`),n=`You are an AI assistant creating a detailed memory of a conversation. This memory will be remembered by the NPCs who participated.
Your task is to write a concise yet detailed summary of the conversation.
The summary should be between 500 and 1500 characters. It should be written from the point of view of the Conversation Participants other than the Player.
The summary should ALWAYS mention all names and the "Player" explicitly without pronouns.
It should capture:
- Key topics discussed.
- Important information revealed or exchanged by any participant.
- Significant decisions made or outcomes reached.
- The overall emotional tone or atmosphere of the conversation.
- Any impressions or key takeaways the NPCs might have.

Output ONLY the summary text. Do NOT use JSON or formatting. Do NOT include any preamble like "Here is the summary:".`,o=`Generate a memory summary for the following conversation:
- Conversation Participants: ${e.dialogueParticipants.join(", ")}
${e.storyArc?`- Narrative Arc: ${e.storyArc.title} (Act ${String(e.storyArc.currentAct)}: ${e.storyArc.acts[e.storyArc.currentAct-1].title})`:`- Theme: "${((a=e.currentTheme)==null?void 0:a.name)??e.themeName}" (${((r=e.currentTheme)==null?void 0:r.storyGuidance)??"None"})`}
- Scene at the start of conversation: "${e.currentScene}"
- Context: Time: "${e.localTime??"Unknown"}", Environment: "${e.localEnvironment??"Undetermined"}", Place: "${e.localPlace??"Undetermined"}"

## Full Dialogue Transcript:
${t}

Output ONLY the summary text. Do NOT use JSON or formatting. Do NOT include any preamble like "Here is the summary:".`;return{systemInstructionPart:n,userPromptPart:o}},Xe=e=>{const n=e.replace(/\s+/g,"_").replace(/[^a-zA-Z0-9_]/g,"").replace(/_+$/,""),o=Math.random().toString(36).substring(2,6);return`${n}_${o}`},Et=e=>e.replace(/\[[^\]]*\]|\([^)]*\)/g,"").replace(/\s+/g," ").trim(),Do=(e,t,n,o)=>{if(!e||!t)return 1/0;const a=Oa(e,t,n,o);return a?a.filter(r=>r.step==="edge").length:1/0},je=(e,t,n,o,a=!1)=>{if(!e)return a?[]:void 0;const r=t.find(y=>y.id===e);if(!a&&r)return r;const s=y=>y.toLowerCase().replace(/[.,!?;:"(){}[\]'’]/g,"").trim(),i=s(e),c=t.filter(y=>s(y.placeName)===i),l=t.filter(y=>{var P;return(P=y.data.aliases)==null?void 0:P.some(S=>s(S)===i)}).filter(y=>!c.includes(y)),d=n?un(n):void 0,p=y=>!n||!o?y:[...y].sort((P,S)=>Do(n,o,P.id,d)-Do(n,o,S.id,d)),u=p(c),m=p(l);if(a){const y=[];return r&&y.push(r),y.push(...u),y.push(...m),y}if(u.length>0)return u[0];if(m.length>0)return m[0];const g=e.toLowerCase();let h=t.find(y=>y.id.toLowerCase().includes(g));const v=/^(.*)_([a-zA-Z0-9]{4})$/;let f=null;if(!h){const y=v.exec(e);if(y){const P=y[1];f=P;const S=t.filter(C=>C.id.toLowerCase().startsWith(`${P.toLowerCase()}_`));S.length===1&&(h=S[0])}}if(h)return h;const I=s((f??e).replace(/_/g," ")),T=t.find(y=>s(y.placeName)===I);if(T)return T;const k=t.find(y=>{var P;return(P=y.data.aliases)==null?void 0:P.some(S=>s(S)===I)});return k||r},io=(e,t,n=!1)=>{if(!e)return n?[]:void 0;const o=t.find(i=>i.id===e);if(!n&&o)return o;const a=e.toLowerCase(),r=t.filter(i=>i.name.toLowerCase()===a),s=t.filter(i=>{var c;return(c=i.aliases)==null?void 0:c.some(l=>l.toLowerCase()===a)}).filter(i=>!r.includes(i));if(n){const i=[];return o&&i.push(o),i.push(...r),i.push(...s),i}return r.length>0?r[0]:s.length>0?s[0]:o},Re=(e,t,n=!1,o=!1)=>{if(!Array.isArray(e)||e.length===0)return n?[]:null;const[a,r]=e,s=[],i=typeof r=="string"?r:void 0,c=(l,d)=>{const p=Et(l),u=Et(d);return o?p.toLowerCase()===u.toLowerCase():p===u};if(a){const l=t.find(d=>d.id===a);if(l){if(i&&!c(l.name,i)&&console.warn(`findItemByIdentifier: Provided name "${i}" does not match item name "${l.name}" for id "${a}".`),!n)return l;s.push(l)}}if((!a||n)&&i){const l=t.filter(d=>c(d.name,i)&&(!a||d.id!==a));if(n)s.push(...l);else if(l.length>0)return l[0]}if(!n&&o&&i){const l=Et(i).toLowerCase(),d=t.find(p=>Et(p.name).toLowerCase()===l);if(d)return d}return n?s:null},Fn=e=>Xe(`node_${e}`),Be=e=>Xe(`npc_${e}`),Va=e=>{const t=Et(e);return Xe(`item_${t}`)};function ci(e,t){if(!e||typeof e!="object")return console.warn("parseAIResponse: Parsed data is not a valid object.",e),t==null||t(),null;const n=e;return typeof n.sceneDescription!="string"||n.sceneDescription.trim()===""?(console.warn("parseAIResponse: sceneDescription is missing or empty.",e),t==null||t(),null):(n.mainQuest===void 0||n.mainQuest===null||typeof n.mainQuest=="string")&&(n.currentObjective===void 0||n.currentObjective===null||typeof n.currentObjective=="string")&&(n.logMessage===void 0||n.logMessage===null||typeof n.logMessage=="string")&&(n.npcsAdded===void 0||n.npcsAdded===null||Array.isArray(n.npcsAdded))&&(n.npcsUpdated===void 0||n.npcsUpdated===null||Array.isArray(n.npcsUpdated))&&(n.objectiveAchieved===void 0||n.objectiveAchieved===null||typeof n.objectiveAchieved=="boolean")&&(n.mainQuestAchieved===void 0||n.mainQuestAchieved===null||typeof n.mainQuestAchieved=="boolean")&&(n.localTime===void 0||n.localTime===null||typeof n.localTime=="string")&&(n.localEnvironment===void 0||n.localEnvironment===null||typeof n.localEnvironment=="string")&&(n.localPlace===void 0||n.localPlace===null||typeof n.localPlace=="string")&&(n.dialogueSetup===void 0||n.dialogueSetup===null||typeof n.dialogueSetup=="object")&&(n.mapUpdated===void 0||n.mapUpdated===null||typeof n.mapUpdated=="boolean")&&(n.currentMapNodeId===void 0||n.currentMapNodeId===null||typeof n.currentMapNodeId=="string")&&(n.mapHint===void 0||n.mapHint===null||typeof n.mapHint=="string")&&(n.playerItemsHint===void 0||n.playerItemsHint===null||typeof n.playerItemsHint=="string")&&(n.worldItemsHint===void 0||n.worldItemsHint===null||typeof n.worldItemsHint=="string")&&(n.npcItemsHint===void 0||n.npcItemsHint===null||typeof n.npcItemsHint=="string")&&(n.librarianHint===void 0||n.librarianHint===null||typeof n.librarianHint=="string")&&(n.newItems===void 0||n.newItems===null||Array.isArray(n.newItems))?fr(n):(console.warn("parseAIResponse: Basic field validation failed (pre-dialogue specifics and array checks).",e),t==null||t(),null)}async function li(e,t){var r;let n=e.dialogueSetup,o=Array.isArray(e.options)?e.options:[],a=!1;if(n){let s=jn(n);if(!s){console.warn("parseAIResponse: 'dialogueSetup' is present but malformed. Attempting correction.");const i=[...t.allRelevantNPCs];(e.npcsAdded??[]).forEach(l=>{Un(l)&&i.push({...l,id:Be(l.name),presenceStatus:l.presenceStatus??"unknown",lastKnownLocation:l.lastKnownLocation??null,preciseLocation:l.preciseLocation??null})}),(e.npcsUpdated??[]).forEach(l=>{if(_a(l)){const d=t.allRelevantNPCs.find(p=>p.name===l.name);i.push({id:Be(l.name),name:l.name,description:l.newDescription??(d==null?void 0:d.description)??"Updated NPC",aliases:l.newAliases??(d==null?void 0:d.aliases)??[],presenceStatus:l.newPresenceStatus??(d==null?void 0:d.presenceStatus)??"unknown",lastKnownLocation:l.newLastKnownLocation??(d==null?void 0:d.lastKnownLocation)??null,preciseLocation:l.newPreciseLocation??(d==null?void 0:d.preciseLocation)??null})}});const c=await zs(t.logMessageFromPayload??e.logMessage,t.sceneDescriptionFromPayload??e.sceneDescription,t.currentTheme,i,t.allRelevantMainMapNodesForCorrection,t.currentInventoryForCorrection,t.heroGender,n);c&&jn(c)?(n=c,s=!0,console.log("parseAIResponse: Successfully corrected 'dialogueSetup'.")):(console.warn("parseAIResponse: Failed to correct 'dialogueSetup' or corrected version is still invalid. Discarding dialogue attempt."),n=void 0,s=!1)}a=s&&!!n,a&&(o=[])}return!a&&(n=void 0,!Array.isArray(o)||!o.every(s=>typeof s=="string"))?(console.warn("parseAIResponse: options are missing or invalid (must be array of strings) when not in dialogue.",e),(r=t.onParseAttemptFailed)==null||r.call(t),null):{dialogueSetup:n,options:o,isDialogueTurn:a}}async function di(e,t,n,o){const a=[];if(Array.isArray(e))for(const c of e){const l=typeof c=="object"&&c!==null&&"name"in c?c.name:void 0;if(Un(c))a.push({...c,id:Be(c.name),presenceStatus:c.presenceStatus??"unknown",lastKnownLocation:c.lastKnownLocation??null,preciseLocation:c.preciseLocation??null});else{console.warn(`parseAIResponse ('npcsAdded'): Invalid NPC structure for "${l??"Unknown Name"}". Attempting correction.`);const d=await bo(l??"Newly Mentioned NPC",o.logMessageFromPayload??n.logMessage,o.sceneDescriptionFromPayload??n.sceneDescription,o.currentTheme,o.allRelevantMainMapNodesForCorrection);if(d){const p=d.description.split(" ").slice(0,2).join(" ")||"Corrected NPC",u={name:l??p,description:d.description,aliases:d.aliases,presenceStatus:d.presenceStatus,lastKnownLocation:d.lastKnownLocation,preciseLocation:d.preciseLocation};Un(u)?(a.push({...u,id:Be(u.name)}),console.log("parseAIResponse ('npcsAdded'): Successfully corrected NPC:",u.name)):console.warn(`parseAIResponse ('npcsAdded'): Corrected NPC "${l??"Unknown Name"}" still invalid. Discarding. Corrected Data:`,u)}else console.warn(`parseAIResponse ('npcsAdded'): Failed to correct NPC "${l??"Unknown Name"}". Discarding.`)}}else e!==void 0&&console.warn("parseAIResponse ('npcsAdded'): Field was present but not an array.",e);const r=Array.isArray(t)?t:[],s=[];for(const c of r)if(typeof c=="object"&&c!==null&&"name"in c&&typeof c.name=="string"&&c.name.trim()!==""){const l={...c,name:c.name},d=l.name,p=[...o.allRelevantNPCs,...a],u=io(l.name,p);if(u)l.name=u.name;else{const m=new Set(p.map(g=>g.name));if(!m.has(l.name)){console.warn(`parseAIResponse ('npcsUpdated'): Identifier "${d}" not found. Attempting name correction.`);const g=await no("NPC name",l.name,o.logMessageFromPayload??n.logMessage,o.sceneDescriptionFromPayload??n.sceneDescription,Array.from(m),o.currentTheme);g&&g.trim()!==""?(l.name=g,console.log(`parseAIResponse ('npcsUpdated'): Corrected target name to "${g}".`)):console.warn(`parseAIResponse ('npcsUpdated'): Failed to correct identifier "${d}". Will attempt to process as is, may convert to 'add'.`)}}_a(l)?s.push(l):console.warn(`parseAIResponse ('npcsUpdated'): Payload for "${d}" is invalid after potential name correction. Discarding. Payload:`,l)}else console.warn("parseAIResponse ('npcsUpdated'): Update missing or has invalid 'name'. Discarding.",c);const i=[];for(const c of s){const l=c.name,d=o.allRelevantNPCs.some(m=>m.name===l),p=a.findIndex(m=>m.name===l),u=p!==-1;if(d||u){if(i.push(c),u){const m=a[p];c.newDescription!==void 0&&(m.description=c.newDescription),c.newAliases!==void 0&&(m.aliases=c.newAliases),c.addAlias&&(m.aliases=Array.from(new Set([...m.aliases??[],c.addAlias]))),c.newPresenceStatus!==void 0&&(m.presenceStatus=c.newPresenceStatus),c.newLastKnownLocation!==void 0&&(m.lastKnownLocation=c.newLastKnownLocation),c.newPreciseLocation!==void 0&&(m.preciseLocation=c.newPreciseLocation),m.presenceStatus==="distant"||m.presenceStatus==="unknown"?m.preciseLocation=null:m.preciseLocation??(m.preciseLocation=m.presenceStatus==="companion"?"with you":"nearby in the scene"),a[p]=m}}else{console.warn(`parseAIResponse ('npcsUpdated'): Target NPC "${l}" for update not found. Converting to an add operation.`);const m={id:Be(l),name:l,description:c.newDescription??`Details for ${l} are emerging.`,aliases:c.newAliases??(c.addAlias?[c.addAlias]:[]),presenceStatus:c.newPresenceStatus??"unknown",lastKnownLocation:c.newLastKnownLocation??null,preciseLocation:c.newPreciseLocation??null};if(m.description===`Details for ${l} are emerging.`){const h=await bo(l,o.logMessageFromPayload??n.logMessage,o.sceneDescriptionFromPayload??n.sceneDescription,o.currentTheme,o.allRelevantMainMapNodesForCorrection);h&&(m.description=h.description,m.aliases=Array.from(new Set([...m.aliases??[],...h.aliases])),m.presenceStatus=h.presenceStatus,m.lastKnownLocation=h.lastKnownLocation,m.preciseLocation=h.preciseLocation)}m.presenceStatus==="distant"||m.presenceStatus==="unknown"?m.preciseLocation=null:m.preciseLocation??(m.preciseLocation=m.presenceStatus==="companion"?"with you":"nearby in the scene");const g=a.findIndex(h=>h.name===m.name);g===-1?a.push(m):a[g]={...a[g],...m}}}return{npcsAdded:a,npcsUpdated:i}}async function Xt(e,t,n,o,a,r,s=[],i={nodes:[],edges:[]},c=[]){var p,u,m;const l=Ne(e),d=i.nodes.filter(g=>g.data.nodeType!=="feature");try{const g=ge(l);if(g===null)throw new Error("JSON parse failed");const h=ci(g,o);if(!h)return null;const v={heroGender:(n==null?void 0:n.gender)??"Male",currentTheme:t,onParseAttemptFailed:o,logMessageFromPayload:a,sceneDescriptionFromPayload:r,allRelevantNPCs:s,allRelevantMainMapNodesForCorrection:d,currentInventoryForCorrection:c},f=await li(h,v);if(!f)return null;h.dialogueSetup=f.dialogueSetup,h.options=f.options;let I=f.isDialogueTurn;h.itemChange=[];const T=await di(h.npcsAdded,h.npcsUpdated,h,v);if(h.npcsAdded=T.npcsAdded,h.npcsUpdated=T.npcsUpdated,I&&h.dialogueSetup){const k=[...s,...h.npcsAdded??[]],y=new Set([...k.map(S=>S.name),...h.npcsUpdated.map(S=>S.name)]),P=[];for(const S of h.dialogueSetup.participants){const C=io(S,k);if(C)P.push(C.name);else if(y.has(S))P.push(S);else{console.warn(`parseAIResponse: Dialogue participant "${S}" is not among known or newly added/updated NPCs. Attempting name correction against this turn's NPCs.`);const $=await no("dialogue participant",S,a??h.logMessage,r??h.sceneDescription,Array.from(y),t);$&&y.has($)?(P.push($),console.log(`parseAIResponse: Corrected dialogue participant name from "${S}" to "${$}".`)):console.warn(`parseAIResponse: Dialogue participant "${S}" could not be validated/corrected against this turn's NPCs. Discarding participant.`)}}P.length===0&&h.dialogueSetup.participants.length>0?(console.warn("parseAIResponse: No valid dialogue participants remain after final name validation. Discarding dialogue attempt."),h.dialogueSetup=void 0,I=!1,(!Array.isArray(h.options)||h.options.length===0||!h.options.every(S=>typeof S=="string"&&S.trim()!==""))&&(console.warn("parseAIResponse: options invalid after dialogue cancellation. Resetting to default failsafe.",h.options),h.options=["Look around.","Ponder the situation.","Check inventory.","Try to move on.","Consider your objective.","Plan your next steps."])):h.dialogueSetup.participants=P}if(I)h.options=[];else{if(!Array.isArray(h.options)||h.options.length===0||!h.options.every(k=>typeof k=="string"&&k.trim()!==""))return console.warn("parseAIResponse: options are missing, empty, or invalid when not inDialogue (final check).",h.options),o==null||o(),null;for(;h.options.length<ze;)h.options.push("...");h.options.length>ze&&(h.options=h.options.slice(0,ze))}return h.objectiveAchieved=h.objectiveAchieved??!1,h.mainQuestAchieved=h.mainQuestAchieved??!1,h.localTime=((p=h.localTime)==null?void 0:p.trim())??"Time Unknown",h.localEnvironment=((u=h.localEnvironment)==null?void 0:u.trim())??"Environment Undetermined",h.localPlace=((m=h.localPlace)==null?void 0:m.trim())??"Undetermined Location",Ks(h),delete h.placesAdded,delete h.placesUpdated,h}catch(g){return console.warn("parseAIResponse: Failed to parse JSON response from AI. This attempt will be considered a failure.",g),console.debug("parseAIResponse: Original response text (before any processing):",e),console.debug("parseAIResponse: JSON string after fence stripping (if any, input to JSON.parse):",l),o==null||o(),null}}const ui={type:"object",properties:{dialogueEnds:{type:"boolean",description:"Set true when the NPCs indicate the conversation is over or naturally concludes."},npcResponses:{type:"array",minItems:1,description:"NPC lines for this turn. Each speaker must be an active participant and lines must be non-empty.",items:{type:"object",properties:{line:{type:"string"},speaker:{type:"string"}},propertyOrdering:["line","speaker"],required:["line","speaker"],additionalProperties:!1}},playerOptions:{type:"array",minItems:vr,maxItems:yr,description:"Possible player replies. The last option must politely or firmly end the conversation.",items:{type:"string"}},updatedParticipants:{type:"array",minItems:1,description:"Provide the new full list of participants if it changes. Don't include the player.",items:{type:"string"}}},required:["npcResponses","playerOptions"],propertyOrdering:["dialogueEnds","npcResponses","playerOptions","updatedParticipants"],additionalProperties:!1},pi=async(e,t,n,o,a,r,s,i,c,l,d,p,u,m,g,h)=>{if(!ee())return console.error("API Key not configured for Dialogue Service."),Promise.reject(new Error("API Key not configured."));const v=ri({currentTheme:e,currentQuest:n,currentObjective:o,currentScene:a,localTime:r,localEnvironment:s,localPlace:i,knownMainMapNodesInTheme:c,knownNPCsInTheme:l,inventory:d,heroSheet:p,storyArc:t,dialogueHistory:u,playerLastUtterance:m,dialogueParticipants:g,relevantFacts:h}),f=await ie(async I=>{var T,k,y;try{console.log(`Fetching dialogue turn (Participants: ${g.join(", ")}, Attempt ${String(I+1)}/${String(W+1)})`),se(ae.dialogue_turn.icon);const P=be(512),{response:S}=await re({modelNames:[X,Q],prompt:v,systemInstruction:Ur,temperature:.8,responseMimeType:"application/json",thinkingBudget:P,includeThoughts:!0,jsonSchema:ui,label:"Dialogue"}),$=(((y=(k=(T=S.candidates)==null?void 0:T[0])==null?void 0:k.content)==null?void 0:y.parts)??[]).filter(A=>A.thought===!0&&typeof A.text=="string").map(A=>A.text);let M=ja(S.text??"",$);if(M??(M=await Qs(S.text??"",g,e,$)),M)return{result:{parsed:M,rawResponse:S.text??"",thoughts:$}};console.warn(`executeDialogueTurn (Attempt ${String(I+1)}/${String(W+1)}): invalid response even after correction`)}catch(P){throw console.error(`Error fetching dialogue turn (Attempt ${String(I+1)}/${String(W+1)}):`,P),P}return{result:null}});if(f)return{parsed:f.parsed,prompt:v,rawResponse:f.rawResponse,thoughts:f.thoughts};throw new Error("Failed to fetch dialogue turn after maximum retries.")},mi=async e=>{if(!ee())return console.error("API Key not configured for Dialogue Summary Service."),Promise.reject(new Error("API Key not configured."));if(!e.currentTheme)return console.error("DialogueSummaryContext missing currentTheme. Cannot summarize dialogue."),Promise.reject(new Error("DialogueSummaryContext missing currentTheme."));const t=e.currentTheme,n=si(e),o=await ie(async a=>{var r,s,i;try{console.log(`Summarizing dialogue with ${e.dialogueParticipants.join(", ")}, Attempt ${String(a+1)}/${String(W+1)})`),se(ae.dialogue_summary.icon);const c=be(4096),{response:l}=await re({modelNames:[Q],prompt:n,systemInstruction:Lt,temperature:1,responseMimeType:"application/json",thinkingBudget:c,includeThoughts:!0,jsonSchema:Ma,label:"Storyteller"}),p=(((i=(s=(r=l.candidates)==null?void 0:r[0])==null?void 0:s.content)==null?void 0:i.parts)??[]).filter(m=>m.thought===!0&&typeof m.text=="string").map(m=>m.text),u=await Xt(l.text??"",t,e.heroSheet??null,void 0,void 0,void 0,e.knownNPCsInTheme,e.mapDataForTheme,e.inventory);if(u)return{result:{parsed:u,rawResponse:l.text??"",thoughts:p}};console.warn(`executeDialogueSummary (Attempt ${String(a+1)}/${String(W+1)}): invalid JSON, retrying`)}catch(c){throw console.error(`Error summarizing dialogue (Attempt ${String(a+1)}/${String(W+1)}):`,c),c}return{result:null}});return o?{parsed:o.parsed,prompt:n,rawResponse:o.rawResponse,thoughts:o.thoughts}:{parsed:null,prompt:n,rawResponse:"",thoughts:[]}},gi=async e=>{if(!ee())return console.error("API Key not configured for Dialogue Memory Summary Service."),null;if(!e.currentTheme)return console.error("DialogueMemorySummaryContext missing currentTheme. Cannot summarize memory."),null;const{systemInstructionPart:t,userPromptPart:n}=ii(e);return await ie(async a=>{var r;try{console.log(`Generating memory summary for dialogue with ${e.dialogueParticipants.join(", ")}, Attempt ${String(a+1)}/${String(W+1)})`),se(ae.dialogue_memory_creation.icon);const{response:s}=await re({modelNames:[Se,X],prompt:n,systemInstruction:t,temperature:Ae,label:"Corrections"}),i=((r=s.text)==null?void 0:r.trim())??null;if(i&&i.length>0)return console.log(`summarizeDialogueForMemory: ${e.dialogueParticipants.join(", ")} will remember ${i}`),{result:i};console.warn(`executeMemorySummary (Attempt ${String(a+1)}/${String(W+1)}): empty memory text`)}catch(s){if(console.error(`Error generating memory summary (Attempt ${String(a+1)}/${String(W+1)}):`,s),!_t(s))return{result:null,retry:!1};throw s}return{result:null}})??null},Ga=(e,t,n,o,a)=>{const r=n?`
${ao(n)}`:"",s=o?`
${pn(o,!1)}`:"",i=a?`
${Ua(a)}`:"",c=`${r}${s}${i}`;return`Theme: ${e}

  ## Context:
${t}${c}

List immutable facts according to your instructions. Return JSON as:
[{"entities": ["id1", "id2"], "text": "fact"}]
`},hi=(e,t,n,o,a)=>{const r=t.map(c=>`- ID ${String(c.id)}: ${c.text} [${c.entities.join(", ")}]`).join(`
`)||"None.",s=n.map(c=>`- ${c.text} [${c.entities.join(", ")}]`).join(`
`)||"None.",i=xa([o,a].filter(c=>c.trim()!==""));return`Theme: ${e}

  ## Recent Events:
${i||"None"}

  ## Known Facts:
${r}

  ## New Candidate Facts:
${s}

Provide facts integration, changes and pruning instructions acording to your instructions.
`},fi=(e,t,n,o,a,r)=>{const s=t.map((c,l)=>`${String(l+1)}. (Tier ${String(c.tier)}) ${c.text}`).join(`
`),i=a.map(c=>`- ${c}`).join(`
`);return`**Context for Fact Selection**
Theme: ${e}
Last Scene: "${n}"
Recent Log:
  ${i}
  ${r}

  ## Player Actions:
${o}

  ------
  
Select the 10 most relevant facts from the list of Known Facts:
${s}
`},yi=(e,t,n,o,a,r,s)=>{const i=t.map(p=>`- ID ${String(p.id)}: "${p.text}" [${p.entities.join(", ")}] (Tier ${String(p.tier)})`).join(`
`),c=a.map(p=>`- ${p}`).join(`
`),l=r.map(p=>`- ${p}`).join(`
`),d=s.map(p=>`- ${p}`).join(`
`);return`Theme: ${e}
Current Quest: ${n??"None"}
Current Objective: ${o??"None"}

## Recent Events:
${d||"None"}

## Inventory Items:
${c||"None"}

## Known Places:
${l||"None"}

## Current Facts:
${i}

Identify pairs of facts that could be merged into a single, more specific statement.
Delete facts that reference obsolete quests, objectives, conditions, items or places. If merging or deleting, provide instructions.
`},vi=e=>{if(!e||typeof e!="object")return!1;const t=e;return!(typeof t.action!="string"||t.entities!==void 0&&(!Array.isArray(t.entities)||!t.entities.every(n=>typeof n=="string"))||t.text!==void 0&&typeof t.text!="string")},Ya=e=>{const t=Ne(e),n=ge(t);return n&&Array.isArray(n)&&n.every(o=>{if(!o||typeof o!="object")return!1;const a=o.entities;return typeof o.text=="string"&&Array.isArray(a)&&a.every(r=>typeof r=="string")})?n:null},Ha=(e,t=[])=>{const n=Ne(e),o=ge(n);if(!o||typeof o!="object")return null;const a=o,r=[],s=t.map(d=>d.id);if(Array.isArray(a.factsChange)&&a.factsChange.forEach(d=>{vi(d)&&(Array.isArray(d.entities)&&(d.entities=d.entities.filter(p=>typeof p=="string")),r.push(d))}),r.some(d=>(d.action==="change"||d.action==="delete")&&(typeof d.id!="number"||!s.includes(d.id))))return null;const i=typeof a.loreRefinementOutcome=="string"?a.loreRefinementOutcome:"",c=typeof a.observations=="string"?a.observations:void 0,l=typeof a.rationale=="string"?a.rationale:void 0;return{factsChange:r,loreRefinementOutcome:i,observations:c,rationale:l}},wi=e=>{const t=Ne(e),n=ge(t);return n&&Array.isArray(n)&&n.every(o=>typeof o=="string")?n:null},Ba=`You are the Loremaster, collecting immutable facts about the game world from narrative context.
Your sole task is to harvest immutable, setting-level facts from the surrounding narrative and return them as a JSON array of objects with "text" and "entities" fields.
The "entities" array must list IDs of map nodes, NPCs or items referenced in the fact, selected from the supplied node_, npc_, and item_ IDs. Use 'player' ID to reference the player character. Use 'universe' ID to reference the world in general.
Each fact must aid long-term continuity and world-building.

## What is a valid fact? Think “map pins & rulebook notes”
- Geography & structures, such as Stable locations, routes, landmarks, architecture, for example: “The Citadel of Glass rises at the mouth of the Azure Gulf.”
- Lore & history, such as Past events, legendary deeds, consequences, for example: “The War of Ashes ended with the signing of the Ember Accord.”
- Cultural rules & customs, such as Laws, taboos, rituals, social hierarchies, for example: “Necromancy is outlawed within the Kingdom of Silverpine.”
- Relationships & roles, such as Power structures, affiliations, well-known titles, for example: “The Order of Verdant Flame answers directly to the crown.”
- Properties of artefacts or creatures, such as Enduring traits that future scenes should honour, for example: “Obsidian golems can be shattered only by sound of a crystal horn.”

## What to reject outright:
- Ephemeral or player-centric details;
- Reference to non-specific nondescript directions or locations - a tavern, a path, a road, a plain, a river, a forest, a mountain, a city, a kingdom, a continent, etc.;
- Current weather, smells, lighting, time of day;
- Sensory “vibe” descriptions (“The market buzzes with chatter”);
- Player inventory, position, quests, feelings, level, dialogue;
- Transactional minutiae - Prices, haggling, countdowns to completion;
- Unverified rumours or philosophical musings - “It is said that…”, “True readiness involves an open spirit…”;
- Bare names or cosmetic trivia “The tavern keeper is named Jorim.”;
- Clothing colours unless culturally significant;
- Duplicates or contradictions;
- Statements already recorded or that clash with existing facts.

## Quality checklist (run mentally for every candidate)
- Standalone? Reads clearly and specific enough to be understood without outside context.
- Enduring? Will still matter a week of in-game time later.
- World-level? Describes the setting, not the current scene.
- Certain? Factual, not conjecture or flavour text.
- Non-redundant? Adds something new (no near-duplicates).

## Examples of *good* quality facts:
- "The city of Dorim is carved into a cliff face.",
- "A secret tunnel links the tavern cellar to the old crypt.",
- "The black market dealer's nickname is Catfish.",
- "The password to the lower deck service console is qwerty123.",
- "The city of Copperhaven is built on three terraced plateaus.",
- "A crystal bridge spans the River Umber beneath the northern plateau.",
- "The Sapphire Guild controls all official cartography in the realm.",
- "Defeating a stone golem requires striking the rune on its chest.",
- "The High Council convenes at dawn on the first day of every month.",
- "The catacombs under Copperhaven were sealed two centuries ago after a plague."

## Examples of *bad* quality and irrelevant facts to avoid:
- "The weather is rainy." (Weather is too transient)
- "The player is in a tavern." (Contextual information, not a fact)
- "The player posesses a sword." (Player actions or possessions are not world facts)
- "The player is thinking about their plans." (Player dialogue is not a fact)
- "The player is a human." (Player characteristics are not world facts)
- "The player is a level 5 warrior." (Player attributes are not world facts)
- "The player is accompanied by an elf." (Player companions are not world facts)
- "It is night time outside." (Time of day is too transient)
- "Joseph said 'It is dangerous in the catacombs'." (Dialogue is not a fact)
- "Kevin stated, 'The forest is haunted'." (Dialogue is not a fact)
- "A gentle breeze blows through the trees." (Weather is too transient)
- "The player carries a rusty dagger." (Player possessions are not world facts)
- "A merchant offers apples for two copper coins." (Transactional details are not world facts)
- "The alley smells of wet garbage." (Sensory details are not world facts)
- "Gregory says, 'Beware the king!'" (Dialogue is not a fact)
- "Morning sunlight warms the streets." (Time of day is too transient)
- "It is rumored that dragons might exist somewhere." (Conjecture is not a fact)

CRITICALLY IMPORTANT: DO NOT include bad quality and irrelevant facts.
`,_o=`You are the Loremaster maintaining up-to-date set of facts about the game world.
1. Compare Recent Events and Known Facts, then change or delete any Known Facts that are obsolete and no longer in effect based on the story developments described in Recent Events.
2. Compare Candidate Facts with existing Known Facts, then add good Known Facts that don't lead to overlaps and potential contradictions with Known Facts.
Known Facts are listed with their numeric IDs. Use these IDs when specifying which fact to change or delete.

## Examples:
"factsChange": [
    {
        "action": "delete",
        "id": 13
    },
    {
        "action": "add",
        "entities": [
            "node_Whisperwood_Jungle_38ax"
        ],
        "text": "The Whisperwood Jungle is a colossal green wall of ancient trees and tangled vines, characterized by oppressive humidity in its undergrowth and a high canopy with gaps allowing sunlight to filter through. It resonates with exotic bird calls and the distant roar of vast, unseen creatures."
    },
    {
        "action": "change",
        "entities": [
            "node_Whisperwood_Jungle_38ax",
            "node_Jagged_Peaks_44re",
            "item_Ancient_Map_Fragment_mjdl"
        ],
        "id": 3
        "text": "From the current location within the Whisperwood Jungle, the colossal green wall appears to stretch limitlessly to the north. To the east, a dip in the terrain suggests a watercourse, while a lone, massive flowering tree with vibrant red blossoms is visible to the south. To the west, a distant jagged peak is discernible, matching a feature marked on the Ancient Map Fragment.",
        "tier": 2
    }
]
`,Ro=`You are the Loremaster selecting relevant known facts.
Relevant facts are those that directly inform the next scene: details the NPCs might reference, rules that shape the environment, or recent events likely to influence decisions.
Select the ten most important facts for the upcoming story turn.
`,Oo=`You are the Loremaster refining and pruning accumulated facts.
Consider the last 20 log entries supplied in the prompt. Remove or edit any facts that have been addressed and are no longer in effect.
1. Look for statements that describe the same idea and merge them into a single, more specific fact. Keep the length of the merged fact under 200 words. Split any fact longer than 200 words into two non-overlapping facts.
Increase the tier of the merged fact by one.
When merging, combine the entity IDs from all merged facts into a single set with no duplicates.

2. Prune facts that reference obsolete or irrelevant details, such as:
- places that no longer exist;
- items that no longer exist;
- old quest and objective that is different from the current quest and objective.

3. Edit or prune any facts facts that are obsolete and no longer in effect according to Recent Events.

## Examples:
"factsChange": [
    {
        "action": "delete",
        "id": 13
    },
    {
        "action": "add",
        "entities": [
            "node_Whisperwood_Jungle_38ax"
        ],
        "text": "The Whisperwood Jungle is a colossal green wall of ancient trees and tangled vines, characterized by oppressive humidity in its undergrowth and a high canopy with gaps allowing sunlight to filter through. It resonates with exotic bird calls and the distant roar of vast, unseen creatures."
    },
    {
        "action": "change",
        "entities": [
            "node_Whisperwood_Jungle_38ax",
            "node_Jagged_Peaks_44re",
            "item_Ancient_Map_Fragment_mjdl"
        ],
        "id": 3,
        "text": "From the current location within the Whisperwood Jungle, the colossal green wall appears to stretch limitlessly to the north. To the east, a dip in the terrain suggests a watercourse, while a lone, massive flowering tree with vibrant red blossoms is visible to the south. To the west, a distant jagged peak is discernible, matching a feature marked on the Ancient Map Fragment.",
        "tier": 2
    }
]
`,Wa={type:"array",items:{type:"object",properties:{text:{type:"string"},entities:{type:"array",minItems:1,items:{type:"string"}}},propertyOrdering:["entities","text"],required:["entities","text"],additionalProperties:!1,description:'A fact extracted from the context that satisfies the requirement for the *good* quality fact and does not show signs of a *bad* quality fact. Entities array must include at least one relevant node_*, npc_*, or item_* ID from the supplied list of IDs, or the IDs "player" or "universe".'}},xo={type:"array",minItems:10,maxItems:10,description:"From the provided facts list select 10 most important facts for the upcoming story turn.",items:{type:"string"}},Uo={type:"object",properties:{observations:{type:"string",minLength:500,description:"Minimum 300 words. Observations about the lore state and the proposed new facts, e.g. There are 3 facts that can be merged. Some of the facts may be too vague or obsolete to be included..."},rationale:{type:"string",minLength:500,description:"Minimum 300 words. Rationale for and against including the proposed facts into the lore, e.g. Most facts are good enough to be included in the lore. However, the facts about the old tavern are no longer relevant. The fact about *a path* leading to the church is too vague - a more concrete named path should have been mentioned instead. I will omit these facts."},factsChange:{type:"array",items:{oneOf:[{type:"object",properties:{action:{enum:["add"]},entities:{type:"array",items:{type:"string"}},text:{type:"string",description:"Must be one of the accepted *New Candidate Facts*."}},propertyOrdering:["action","entities","text"],required:["action","entities","text"],additionalProperties:!1},{type:"object",description:"Change or delete the lore facts that are no longer relevant according to Recent Events",properties:{action:{enum:["delete","change"]},entities:{type:"array",items:{type:"string"}},id:{type:"integer",description:"ID of the fact to change or remove."},text:{type:"string",description:"Updated fact text for the change action."}},propertyOrdering:["action","entities","id","text"],required:["action","id"],additionalProperties:!1}]}}},required:["observations","rationale","factsChange"],propertyOrdering:["observations","rationale","factsChange"],additionalProperties:!1},jo={type:"object",properties:{observations:{type:"string",minLength:500,description:"Minimum 300 words. Observations about the lore state, close duplicates, too vague facts, and facts made obsolete by recent events."},rationale:{type:"string",minLength:500,description:"Minimum 300 words. Rationale for the proposed mergers, splits, and deletions."},factsChange:{type:"array",items:{type:"object",description:"REQUIRED for the *add* and *change* actions. Omitted for the *delete* action.",properties:{action:{enum:["add","change","delete"]},entities:{type:"array",items:{type:"string"}},id:{type:"integer",description:"Required for *change* and *delete* actions."},text:{type:"string",maxLength:2e3,description:"REQUIRED for the *add* and *change* actions. MUST be under 200 words."},tier:{type:"integer",description:"Omit tier for *add* action. Increase tier by one for *change* action, when any number of other facts are merged into this one.",default:1}},propertyOrdering:["action","entities","id","text","tier"],required:["action"],additionalProperties:!1}}},required:["observations","rationale","factsChange"],propertyOrdering:["observations","rationale","factsChange"],additionalProperties:!1},Ii=async e=>{if(!ee())return console.error("extractInitialFacts_Service: API not configured"),null;const{themeName:t,worldFacts:n,heroSheet:o,heroBackstory:a}=e,r=Ga(t,"",n,o,a),s=await ie(async()=>{var h,v,f,I;(h=e.onSetLoadingReason)==null||h.call(e,"loremaster_extract"),se(ae.loremaster_extract.icon);const i=be(512),c=We(512),{response:l,systemInstructionUsed:d,jsonSchemaUsed:p,promptUsed:u}=await re({modelNames:[X,Q],prompt:r,systemInstruction:Ba,thinkingBudget:i,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:Wa,temperature:.7,label:"LoremasterExtractInitial",maxOutputTokens:c}),g=(((I=(f=(v=l.candidates)==null?void 0:v[0])==null?void 0:f.content)==null?void 0:I.parts)??[]).filter(T=>T.thought===!0&&typeof T.text=="string").map(T=>T.text);return{result:{parsed:Ya(l.text??""),raw:l.text??"",thoughts:g,systemInstructionUsed:d,jsonSchemaUsed:p,promptUsed:u}}});return s?{facts:s.parsed??[],debugInfo:{extract:{prompt:s.promptUsed,systemInstruction:s.systemInstructionUsed,jsonSchema:s.jsonSchemaUsed,rawResponse:s.raw,parsedPayload:s.parsed??void 0,thoughts:s.thoughts},integrate:null}}:null},Ni=async e=>{if(!ee())return console.error("refineLore_Service: API not configured"),null;const{themeName:t,turnContext:n,existingFacts:o,logMessage:a,currentScene:r,worldFacts:s,heroSheet:i,heroBackstory:c,onFactsExtracted:l}=e,d=Ga(t,n,s,i,c),p=await ie(async()=>{var y,P,S,C;(y=e.onSetLoadingReason)==null||y.call(e,"loremaster_extract"),se(ae.loremaster_extract.icon);const g=be(512),{response:h,systemInstructionUsed:v,jsonSchemaUsed:f,promptUsed:I}=await re({modelNames:[X,Q],prompt:d,systemInstruction:Ba,thinkingBudget:g,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:Wa,temperature:.7,label:"LoremasterExtract"}),k=(((C=(S=(P=h.candidates)==null?void 0:P[0])==null?void 0:S.content)==null?void 0:C.parts)??[]).filter($=>$.thought===!0&&typeof $.text=="string").map($=>$.text);return{result:{parsed:Ya(h.text??""),raw:h.text??"",thoughts:k,systemInstructionUsed:v,jsonSchemaUsed:f,promptUsed:I}}});if(!p)return null;if(l){const{proceed:g}=await l(p.parsed??[]);if(!g)return{refinementResult:null,debugInfo:{extract:{prompt:p.promptUsed,systemInstruction:p.systemInstructionUsed,jsonSchema:p.jsonSchemaUsed,rawResponse:p.raw,parsedPayload:p.parsed??void 0,thoughts:p.thoughts},integrate:null}}}const u=hi(t,o,p.parsed??[],a,r),m=await ie(async()=>{var P,S,C,$;(P=e.onSetLoadingReason)==null||P.call(e,"loremaster_write"),se(ae.loremaster_write.icon);const g=be(1024),{response:h,systemInstructionUsed:v,jsonSchemaUsed:f,promptUsed:I}=await re({modelNames:[X,Q],prompt:u,systemInstruction:_o,thinkingBudget:g,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:Uo,temperature:.7,label:"LoremasterIntegrate"}),k=((($=(C=(S=h.candidates)==null?void 0:S[0])==null?void 0:C.content)==null?void 0:$.parts)??[]).filter(M=>M.thought===!0&&typeof M.text=="string").map(M=>M.text),y=Ha(h.text??"",o);return{result:y?{parsed:y,raw:h.text??"",thoughts:k,systemInstructionUsed:v,jsonSchemaUsed:f,promptUsed:I}:null}});return{refinementResult:(m==null?void 0:m.parsed)??null,debugInfo:{extract:{prompt:p.promptUsed,systemInstruction:p.systemInstructionUsed,jsonSchema:p.jsonSchemaUsed,rawResponse:p.raw,parsedPayload:p.parsed??void 0,thoughts:p.thoughts},integrate:{prompt:(m==null?void 0:m.promptUsed)??u,systemInstruction:(m==null?void 0:m.systemInstructionUsed)??_o,jsonSchema:(m==null?void 0:m.jsonSchemaUsed)??Uo,rawResponse:m==null?void 0:m.raw,parsedPayload:m==null?void 0:m.parsed,observations:m==null?void 0:m.parsed.observations,rationale:m==null?void 0:m.parsed.rationale,thoughts:m==null?void 0:m.thoughts}}}},Ja=async e=>{if(!ee())return console.error("collectRelevantFacts_Service: API not configured"),null;const{themeName:t,facts:n,lastScene:o,playerAction:a,recentLogEntries:r,detailedContext:s}=e,i=fi(t,n,o,a,r,s),c=await ie(async()=>{var v,f,I;se(ae.loremaster_collect.icon);const l=be(1024),{response:d,systemInstructionUsed:p,jsonSchemaUsed:u,promptUsed:m}=await re({modelNames:[Se,X,Q],prompt:i,systemInstruction:Ro,thinkingBudget:l,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:xo,temperature:.7,label:"LoremasterCollect"}),h=(((I=(f=(v=d.candidates)==null?void 0:v[0])==null?void 0:f.content)==null?void 0:I.parts)??[]).filter(T=>T.thought===!0&&typeof T.text=="string").map(T=>T.text);return{result:{parsed:wi(d.text??""),raw:d.text??"",thoughts:h,systemInstructionUsed:p,jsonSchemaUsed:u,promptUsed:m}}});return{facts:(c==null?void 0:c.parsed)??[],debugInfo:{prompt:(c==null?void 0:c.promptUsed)??i,systemInstruction:(c==null?void 0:c.systemInstructionUsed)??Ro,jsonSchema:(c==null?void 0:c.jsonSchemaUsed)??xo,rawResponse:c==null?void 0:c.raw,parsedPayload:(c==null?void 0:c.parsed)??void 0,thoughts:c==null?void 0:c.thoughts}}},Ka=async e=>{if(!ee())return console.error("distillFacts_Service: API not configured"),null;const{themeName:t,facts:n,currentQuest:o,currentObjective:a,inventoryItemNames:r,mapNodeNames:s,recentLogEntries:i}=e,c=yi(t,n,o,a,r,s,i),l=await ie(async()=>{var I,T,k;se(ae.loremaster_refine.icon);const d=be(4096),{response:p,systemInstructionUsed:u,jsonSchemaUsed:m,promptUsed:g}=await re({modelNames:[Q,X],prompt:c,systemInstruction:Oo,thinkingBudget:d,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:jo,temperature:.7,label:"LoremasterDistill"}),v=(((k=(T=(I=p.candidates)==null?void 0:I[0])==null?void 0:T.content)==null?void 0:k.parts)??[]).filter(y=>y.thought===!0&&typeof y.text=="string").map(y=>y.text),f=Ha(p.text??"",n);return{result:f?{parsed:f,raw:p.text??"",thoughts:v,systemInstructionUsed:u,jsonSchemaUsed:m,promptUsed:g}:null}});return{refinementResult:(l==null?void 0:l.parsed)??null,debugInfo:{prompt:(l==null?void 0:l.promptUsed)??c,systemInstruction:(l==null?void 0:l.systemInstructionUsed)??Oo,jsonSchema:(l==null?void 0:l.jsonSchemaUsed)??jo,rawResponse:l==null?void 0:l.raw,parsedPayload:l==null?void 0:l.parsed,observations:l==null?void 0:l.parsed.observations,rationale:l==null?void 0:l.parsed.rationale,thoughts:l==null?void 0:l.thoughts}}},bi=e=>{const{getCurrentGameState:t,commitGameState:n,setError:o,setIsLoading:a,setLoadingReason:r,initiateDialogueExit:s,isDialogueExiting:i,addDebugEntry:c}=e;return{handleDialogueOptionSelect:b.useCallback(async d=>{const p=t(),u=p.currentTheme;if(!u||!p.dialogueState||i)return;const m={speaker:"Player",line:d},g=[...p.dialogueState.options],h=[...p.dialogueState.history,m],v=g.length>0&&d===g[g.length-1],f={...p,dialogueState:{...p.dialogueState,history:h,options:[]},lastTurnChanges:null};if(n(f),v)await s(f);else{a(!0),r("dialogue_turn"),o(null);try{const I=f.mapData.nodes.filter(L=>L.data.nodeType!=="feature"),T=f.allNPCs,k=f.gameLog.slice(-qn),y=oo(I,T,`${f.currentScene} ${d}`,"Locations mentioned:","NPCs mentioned:"),P=[...f.themeFacts].sort((L,D)=>D.tier-L.tier||D.createdTurn-L.createdTurn).map(L=>({text:L.text,tier:L.tier}));r("loremaster_collect");const S=await Ja({themeName:u.name,facts:P,lastScene:f.currentScene,playerAction:d,recentLogEntries:k,detailedContext:y});r("dialogue_turn");const C=(S==null?void 0:S.facts)??[],{parsed:$,prompt:M,rawResponse:A,thoughts:w}=await pi(u,f.storyArc,f.mainQuest,f.currentObjective,f.currentScene,f.localTime,f.localEnvironment,f.localPlace,I,f.allNPCs,f.inventory.filter(L=>L.holderId===ne),f.heroSheet,h,d,(()=>{if(!f.dialogueState)throw new Error("Dialogue state is not defined");return f.dialogueState.participants})(),C);c({prompt:M,rawResponse:A,thoughts:w});const N=t();if($&&N.dialogueState){const L=[...h,...$.npcResponses],D={participants:$.updatedParticipants??N.dialogueState.participants,history:L,options:$.playerOptions};$.dialogueEnds&&(D.options=[]);const x={...N,dialogueState:D,lastTurnChanges:null};n(x),$.dialogueEnds&&await s(x)}else if(N.dialogueState){o("The conversation faltered. Try choosing an option again or ending the dialogue.");const L={...N.dialogueState};L.options.length===0&&(L.options=g.length>0?g:["End Conversation."]),n({...N,dialogueState:L,lastTurnChanges:null})}}catch(I){console.error("Error during dialogue turn:",I),o("An error occurred in the conversation. You might need to end it.");const T=t();if(T.dialogueState){const k=g.length>0?g:["Try to end the conversation."];n({...T,dialogueState:{...T.dialogueState,options:k},lastTurnChanges:null})}}finally{const I=t(),{dialogueState:T}=I;T!=null&&T.options.length===0&&T.history.length>0||i||(a(!1),r(null))}}},[t,n,i,o,a,r,s,c])}},Ti=e=>{const{getCurrentGameState:t,commitGameState:n,setError:o,setIsLoading:a,setLoadingReason:r,onDialogueConcluded:s,getDialogueDebugLogs:i,clearDialogueDebugLogs:c}=e,[l,d]=b.useState(!1),p=b.useCallback(async m=>{var N,L,D;const g=m.currentTheme,h=((N=m.dialogueState)==null?void 0:N.history)??[],v=((L=m.dialogueState)==null?void 0:L.participants)??[];if(!g||!m.dialogueState){console.error("Cannot exit dialogue: current theme is null or not in dialogue state.",m),await s(null,m,{turns:i()}),c(),d(!1),a(!1),r(null);return}a(!0),r("dialogue_summary"),d(!0),o(null);const f=Z(m);r("dialogue_memory_creation");const I={themeName:g.name,currentTheme:g,currentScene:f.currentScene,localTime:f.localTime,localEnvironment:f.localEnvironment,localPlace:f.localPlace,dialogueParticipants:v,dialogueLog:h},k={summaryText:await gi(I)??"A conversation took place, but the details are hazy.",participants:v,timestamp:f.localTime??"Unknown Time",location:f.localPlace??"Unknown Location"};f.allNPCs=f.allNPCs.map(x=>{if(v.includes(x.name)){const K=[...x.dialogueSummaries??[],k];return K.length>wr&&K.shift(),{...x,dialogueSummaries:K}}return x}),r("dialogue_conclusion_summary");const y=f.mapData,P=(D=f.storyArc)==null?void 0:D.acts[f.storyArc.currentAct-1],S={mainQuest:(P==null?void 0:P.mainObjective)??null,currentObjective:f.currentObjective,currentScene:f.currentScene,localTime:f.localTime,localEnvironment:f.localEnvironment,localPlace:f.localPlace,mapDataForTheme:y,knownNPCsInTheme:f.allNPCs,inventory:f.inventory.filter(x=>x.holderId===ne),dialogueLog:h,dialogueParticipants:v,heroSheet:f.heroSheet,themeName:g.name,currentTheme:g,storyArc:f.storyArc},{parsed:C,prompt:$,rawResponse:M,thoughts:A}=await mi(S);f.dialogueState=null;const w={turns:i(),summaryPrompt:$,summaryRawResponse:M,summaryThoughts:A};await s(C,f,w),c(),d(!1)},[o,a,r,s,i,c]),u=b.useCallback(()=>{const m=t();if(m.dialogueState&&!l){const g={speaker:"Player",line:"(Forces the conversation to end)"},h=[...m.dialogueState.history,g],v={...m,dialogueState:{...m.dialogueState,history:h,options:[]},lastTurnChanges:null};n(v),p(v)}},[t,n,l,p]);return{isDialogueExiting:l,initiateDialogueExit:p,handleForceExitDialogue:u}},Si=e=>{const{getCurrentGameState:t,commitGameState:n,setError:o,setIsLoading:a,setLoadingReason:r,onDialogueConcluded:s}=e,i=b.useRef([]),c=h=>{i.current.push(h)},l=()=>i.current,d=()=>{i.current=[]},{isDialogueExiting:p,initiateDialogueExit:u,handleForceExitDialogue:m}=Ti({getCurrentGameState:t,commitGameState:n,setError:o,setIsLoading:a,setLoadingReason:r,onDialogueConcluded:s,getDialogueDebugLogs:l,clearDialogueDebugLogs:d}),{handleDialogueOptionSelect:g}=bi({getCurrentGameState:t,commitGameState:n,setError:o,setIsLoading:a,setLoadingReason:r,initiateDialogueExit:u,isDialogueExiting:p,addDebugEntry:c});return{isDialogueExiting:p,handleDialogueOptionSelect:g,handleForceExitDialogue:m}},Ai=e=>Si(e),Ci=(e,t,n,o,a)=>{const r=ao(n),s=pn(o,!0),i=Ua(a),c=ro(t);return`Start a new adventure in the theme "${e.name}". ${e.storyGuidance}

## Narrative Arc:
${c}

## World Details:
${r}

## Player Character Description:
${s}

## Player Character Backstory:
${i}

Creatively generate the main quest, current objective, scene description, action options, and starting items using the world details and hero history for inspiration.
Creatively add any important quest item(s), if any, based on your generated quest and objective.

ALWAYS SET "mapUpdated": true.
ALWAYS REQUIRED: "mainQuest", "currentObjective", "localTime", "localEnvironment", and "localPlace".
`},Ei=(e,t,n,o,a,r,s,i,c,l,d,p,u,m,g,h,v,f,I,T)=>{var _;const k=n.length>0?qe(n," - ",!0,!0,!1,!1,!0):"There are no items in player's inventory.",y=o.length>0?`There are items at this location: 
${qe(o," - ",!0,!0,!1,!1,!0)}`:"There are no visible items at this location.",P=nt(c,!0),S=l.filter(R=>R.presenceStatus==="companion"),C=S.length>0?mt(S," - ",!1,!1,!1,!0):"None",$=l.filter(R=>R.presenceStatus==="nearby"),M=$.length>0?mt($," - ",!1,!1,!1,!0):"None",A=l.filter(R=>R.presenceStatus==="distant"||R.presenceStatus==="unknown"),w=A.length>0?mt(A," - ",!1,!1,!1,!0):"None specifically known yet.",N=d.length>0?d.map(R=>`- ${R}`).join(`
`):"None",L=xa(i),D=T?ro(T):"",x=f,K=Array.isArray(x.nodes)?x.nodes:[],j=(Array.isArray(x.edges)?x.edges:[]).filter(R=>{const G=K.find(H=>H.id===R.sourceNodeId),V=K.find(H=>H.id===R.targetNodeId);return G&&V}),ye=cs(f,(v==null?void 0:v.id)??null,s,K,j),ue=Js(f,(v==null?void 0:v.id)??null,I);let de="";if(ue)de=ue;else if(I){const R=f.nodes.find(J=>J.id===I),G=(R==null?void 0:R.placeName)??I,V=R==null?void 0:R.data.parentNodeId,H=V&&V!=="Universe"?((_=f.nodes.find(J=>J.id===V))==null?void 0:_.placeName)??V:null;de=`Player wants to reach ${H?`${G} in ${H}`:G}, but does not know how to get there.`}const U=oo(c,l,`${e} ${t}`,"### Details on relevant locations mentioned in current scene or action:","### Details on relevant NPCs mentioned in current scene or action:"),F=ao(g),q=pn(h,!1);return`Based on the Previous Scene and Player Action, and taking into account the provided narrative arc guidance and context, generate the next scene description, options, item changes, log message, etc.

## Narrative Arc:
${D}

## Context that may or may not be relevant for this specific turn:
Previous Local Time: "${p??"Unknown"}"
Previous Local Environment: "${u??"Undetermined"}"
Previous Local Place: "${m??"Undetermined Location"}"
Main Quest: "${a??"Not set"}"
Current Objective: "${r??"Not set"}"

### World Details:
${F}

### Player Character Description:
${q}

### Player's Inventory:
${k}

### Items at Current Location:
${y}

### Known Locations:
${P}

### Known NPCs:
${w}

### Companions traveling with the Player:
${C}

### NPCs Player can interact with (nearby):
${M}

### Current Map Context (including your location, possible exits, nearby paths, and other nearby locations):
${ye}

${U}

### Relevant Facts at present moment:
${N}

### Recent Events to keep in mind (for context and continuity):
${L}
 - A bit later you look around and consider your next move.
IMPORTANT: Recent events are provided only for additional context. These actions have already been processed by the game and should NEVER trigger item actions again, to avoid double counting.

---

## Previous Scene:
${e}

## Player Actions:
${t}
${de}`};function Pi(e){const t=Z(e);return t.inventory=t.inventory.map(n=>n.lastInspectTurn!==void 0&&n.lastInspectTurn>=t.globalTurnNumber?{...n,lastInspectTurn:void 0}:n),t.lastJournalInspectTurn>=t.globalTurnNumber&&(t.lastJournalInspectTurn=0),t}const $i={type:"object",properties:{geography:{type:"string",minLength:1e3},climate:{type:"string"},technologyLevel:{type:"string"},supernaturalElements:{type:"string"},majorFactions:{type:"array",items:{type:"string"},description:"Names of the factions and their brief description"},keyResources:{type:"array",items:{type:"string"}},culturalNotes:{type:"array",items:{type:"string"}},notableLocations:{type:"array",items:{type:"string"},description:"Notable geographic locations and their brief description"}},required:["geography","climate","technologyLevel","supernaturalElements","majorFactions","keyResources","culturalNotes","notableLocations"],additionalProperties:!1},Mi={type:"object",properties:{name:{type:"string"},occupation:{type:"string"},traits:{type:"array",items:{type:"string"}},startingItems:{type:"array",items:{type:"string"}}},required:["name","occupation","traits","startingItems"],additionalProperties:!1},qa={type:"object",properties:{title:{type:"string",description:"Creative title for the act."},description:{type:"string",minLength:3e3},mainObjective:{type:"string",description:"Main objective that must be achieved in order to complete the act."},sideObjectives:{type:"array",items:{type:"string"}},successCondition:{type:"string",description:"Actionable, clearly defined condition for finishing the act and moving forvard into the next act."}},required:["title","description","mainObjective","sideObjectives","successCondition"],additionalProperties:!1},ki={type:"object",properties:{title:{type:"string",description:"Creative title for the whole storyline."},overview:{type:"string",description:"High level story overview, like a book series synopsis, without going into specifics of the story, and not describing specific acts.",minLength:3e3},acts:{type:"array",minItems:1,maxItems:1,items:qa}},required:["title","overview","acts"],additionalProperties:!1},Li={type:"object",description:"Narrative description of what was happening to the player character in each of the time periods up until present moment.",properties:{fiveYearsAgo:{type:"string",minLength:2e3,description:"Narrative story from 5 years ago."},oneYearAgo:{type:"string",minLength:2e3,description:"Narrative story from one year ago."},sixMonthsAgo:{type:"string",minLength:2e3,description:"Narrative story from 6 months ago."},oneMonthAgo:{type:"string",minLength:2e3,description:"Narrative story from one month ago."},oneWeekAgo:{type:"string",minLength:2e3,description:"Narrative story from last week."},yesterday:{type:"string",minLength:2e3,description:"Narrative story from yesterday."},now:{type:"string",minLength:2e3,description:"Narrative story leading to the present moment."},storyArc:ki},required:["fiveYearsAgo","oneYearAgo","sixMonthsAgo","oneMonthAgo","oneWeekAgo","yesterday","now","storyArc"],additionalProperties:!1},Di=async e=>{if(!ee())return console.error("generateWorldFacts: API key not configured."),null;const t=`Using the theme description "${e.storyGuidance}", expand it into a world profile.`,n=async()=>{const o=be(1024),a=We(1024),{response:r}=await re({modelNames:[X,Q],prompt:t,systemInstruction:"Respond only with JSON matching the provided schema.",thinkingBudget:o,includeThoughts:!1,responseMimeType:"application/json",jsonSchema:$i,label:"WorldFacts",maxOutputTokens:a});return r.text??null};return ie(async()=>{se(ae.initial_load.icon);const o=await n();return{result:o?ge(Ne(o)):null}})},_i=async(e,t,n)=>{if(!ee())return console.error("generateCharacterNames: API key not configured."),null;const o=`Using this world description:
    ${JSON.stringify(n)}
    Generate 50 strictly ${t} full names with occasional optional nicknames appropriate for the theme "${e.name}".
    The names shouls follow 'First Name Last Name' or 'First Name "Nickname" Last Name' or 'Prefix First Name Last Name' template.
    You MUST guarantee name variety! Every individual First Name, Last Name, and Nickname MUST appear only once throughout the whole list. They all should be unique.`,a=async()=>{const r=be(1024),s=We(1024),{response:i}=await re({modelNames:[X,Q],prompt:o,systemInstruction:"Respond with a JSON array of strings.",thinkingBudget:r,includeThoughts:!1,responseMimeType:"application/json",jsonSchema:{type:"array",minItems:50,items:{type:"string"}},label:"HeroNames",maxOutputTokens:s});return i.text??null};return ie(async()=>{se(ae.initial_load.icon);const r=await a();return{result:r?ge(Ne(r)):null}})},Ri=async(e,t,n,o)=>{if(!ee())return console.error("generateCharacterDescriptions: API key not configured."),null;const a=`Using this world description:
    ${JSON.stringify(n)}
    Provide a short adventurous description for each of these potential ${t} player characters appropriate for the theme "${e.name}":
    ${o.join(`
`)}`,r=async()=>{const s=be(1024),i=We(1024),{response:c}=await re({modelNames:[X,Q],prompt:a,systemInstruction:"Respond with a JSON array matching the provided names with their descriptions.",thinkingBudget:s,includeThoughts:!1,responseMimeType:"application/json",jsonSchema:{type:"array",items:{type:"object",properties:{name:{type:"string"},description:{type:"string",minLength:2e3}},required:["name","description"],additionalProperties:!1}},label:"HeroDescriptions",maxOutputTokens:i});return c.text??null};return ie(async()=>{se(ae.initial_load.icon);const s=await r();return{result:s?ge(Ne(s)):null}})},Jl=async(e,t,n,o,a)=>{if(!ee())return console.error("generateHeroData: API key not configured."),null;const r=`Using the theme "${e.name}" and these world details:
    ${JSON.stringify(n)}
    The player's character gender is ${t}.`+(o?` Their name is ${o}.`:"")+(a?` Here is a short description of the hero: ${a}.`:"")+" Create a brief character sheet including occupation, notable traits, and starting items.",s=async(i,c,l)=>{const d=be(1024),p=We(1024),{response:u}=await re({modelNames:[X,Q],prompt:i,systemInstruction:"Respond only with JSON matching the provided schema.",thinkingBudget:d,includeThoughts:!1,responseMimeType:"application/json",jsonSchema:c,label:l,maxOutputTokens:p});return u.text??null};return ie(async()=>{se(ae.initial_load.icon);const i=await s(r,Mi,"HeroSheet"),c=i?ge(Ne(i)):null;c&&(c.gender=t);const l=o??(c==null?void 0:c.name)??"the hero",d=`Using these world details:
        ${JSON.stringify(n)}
        and this hero sheet:
        ${i??""}
        ${a?`The hero's description is: ${a}.`:""}
        Write a short backstory for ${l} using these time markers: 5 years ago, 1 year ago, 6 months ago, 1 month ago, 1 week ago, yesterday, and now. Then outline a five act narrative arc for this adventure with an overview of at least 3000 characters. Provide details only for Act 1 (exposition) including a description of at least 3000 characters, the main objective, two side quests, and the success condition to proceed to the next act (rising action).`,p=await s(d,Li,"HeroBackstory"),u=p?ge(Ne(p)):null;let m=null,g=null;if(u){const{storyArc:h,...v}=u;m={title:h.title,overview:h.overview,acts:h.acts.map((f,I)=>({...f,actNumber:I+1,completed:!1})),currentAct:1},g=v}if(m&&!dn(m))throw new Error("generateHeroData: invalid story arc");return{result:{heroSheet:c??null,heroBackstory:g,storyArc:m}}})},Oi=async(e,t,n,o,a,r)=>{if(!ee())return console.error("generateNextStoryAct: API key not configured."),null;const s=o.currentAct+1,i=Ir[s];if(!i)return null;const c=o.acts.filter(m=>m.actNumber<=o.currentAct).map(m=>`Act ${String(m.actNumber)}: ${m.description}`).join(`
`),l=a.slice(-qn).join(`
`),d=s===5?" This is the final act of the game. Provide a successCondition that clearly ends the entire story.":"",p=`Using the theme "${e.name}" continue the narrative.

World Facts:
${JSON.stringify(t)}

Player Character:
${JSON.stringify(n)}

Story Arc Title: ${o.title}
Overview: ${o.overview}

Completed Acts:
${c}

Last Scene:
${r}

Recent Log:
${l}

Generate full details for Act ${String(s)} (${i}).${d}`,u=async()=>{const m=be(1024),g=We(1024),{response:h}=await re({modelNames:[X,Q],prompt:p,systemInstruction:"Respond only with JSON matching the provided schema.",thinkingBudget:m,includeThoughts:!1,responseMimeType:"application/json",jsonSchema:qa,label:"NextAct",maxOutputTokens:g});return h.text??null};return ie(async()=>{se(ae.storyteller.icon);const m=await u(),g=m?ge(Ne(m)):null;return g?{result:{actNumber:s,title:g.title,description:g.description,mainObjective:g.mainObjective,sideObjectives:g.sideObjectives,successCondition:g.successCondition,completed:!1}}:{result:null}})},za=(e,t)=>{const n={...e};return t.type!==void 0&&(n.type=t.type),t.description!==void 0&&(n.description=t.description),t.activeDescription!==void 0&&(n.activeDescription=t.activeDescription??void 0),t.isActive!==void 0&&(n.isActive=t.isActive),t.tags!==void 0&&(n.tags=t.tags),t.chapters!==void 0&&(n.chapters=t.chapters),t.knownUses!==void 0&&(n.knownUses=t.knownUses),t.holderId!==void 0&&t.holderId.trim()!==""&&(n.holderId=t.holderId),n},xi=(e,t)=>{let n=[...e];switch(t.action){case"create":{const o=t.item,a=n.findIndex(r=>r.id===o.id);a!==-1?n[a]=o:n.push(o);break}case"destroy":{const o=t.item,a=Re([o.id,o.name],n,!1,!0),r=Array.isArray(a)?null:a;r&&(n=n.filter(s=>s.id!==r.id));break}case"move":{const o=t.item,a=Re([o.id,o.name],n,!1,!0),r=Array.isArray(a)?null:a;if(r){const s=n.findIndex(i=>i.id===r.id);n[s]={...r,holderId:o.newHolderId}}break}case"change":{const o=t.item,a=Re([o.id,o.name],n,!1,!0),r=Array.isArray(a)?null:a;if(r){const s=n.findIndex(d=>d.id===r.id),i=o.newName===void 0&&o.name!==void 0&&o.name!==r.name,c=o.newName??(i?o.name:void 0),l=za(r,o);c&&c.trim()!==""&&c!==r.name&&(l.name=c),n[s]=l}break}case"addDetails":{const o=t.item,a=Re([o.id,o.name],n,!1,!0),r=Array.isArray(a)?null:a;if(r){const s=n.findIndex(c=>c.id===r.id),i={...r};if(o.chapters&&o.chapters.length>0&&(i.chapters=[...r.chapters??[],...o.chapters]),o.tags&&o.tags.length>0){const c=new Set(r.tags??[]);for(const l of o.tags)c.add(l);i.tags=Array.from(c)}if(o.knownUses&&o.knownUses.length>0){const c=[...r.knownUses??[]];for(const l of o.knownUses){const d=c.findIndex(p=>p.actionName===l.actionName);d!==-1?c[d]=l:c.push(l)}i.knownUses=c}i.lastInspectTurn=void 0,n[s]=i}break}}return n},Ui=(e,t)=>{const n=[];for(const o of e){let a=null;if(o.action==="create"){const r=o.item;r.id||(r.id=Va(r.name)),a={type:"acquire",acquiredItem:{...r,activeDescription:r.activeDescription??void 0,isActive:r.isActive??!1,knownUses:r.knownUses??[],tags:r.tags??[]}}}else if(o.action==="destroy"){const r=o.item,s=Re([r.id,r.name],t,!1,!0),i=Array.isArray(s)?null:s;i&&(a={type:"loss",lostItem:{...i}})}else if(o.action==="move"){const r=o.item,s=Re([r.id,r.name],t,!1,!0),i=Array.isArray(s)?null:s;if(i){const c={...i},l={...i,holderId:r.newHolderId};a={type:"update",oldItem:c,newItem:l}}}else if(o.action==="change"){const r=o.item,s=Re([r.id,r.name],t,!1,!0),i=Array.isArray(s)?null:s;if(i){const c={...i},l=r.newName===void 0&&r.name!==void 0&&r.name!==i.name,d=r.newName??(l?r.name:void 0),p=za(i,r);d&&d.trim()!==""&&d!==i.name&&(p.name=d),a={type:"update",oldItem:c,newItem:p}}}else{const r=o.item,s=Re([r.id,r.name],t,!1,!0),i=Array.isArray(s)?null:s;if(i){const c={...i};let l={...i};if(r.chapters&&r.chapters.length>0&&(l={...l,chapters:[...i.chapters??[],...r.chapters]}),r.tags&&r.tags.length>0){const d=new Set(i.tags??[]);for(const p of r.tags)d.add(p);l.tags=Array.from(d)}if(r.knownUses&&r.knownUses.length>0){const d=[...i.knownUses??[]];for(const p of r.knownUses){const u=d.findIndex(m=>m.actionName===p.actionName);u!==-1?d[u]=p:d.push(p)}l.knownUses=d}a={type:"update",oldItem:c,newItem:l}}}a&&n.push(a)}return n},ji=(e,t)=>{let n=[...t];for(const o of e)n=xi(n,o);return n},Fi=(e,t,n)=>{const o=[];return e.forEach(a=>{const r={...a,id:Be(a.name),aliases:a.aliases??[],presenceStatus:a.presenceStatus??"unknown",lastKnownLocation:a.lastKnownLocation??null,preciseLocation:a.preciseLocation??null,dialogueSummaries:[]};o.push({type:"add",npcName:r.name,addedNPC:r})}),t.forEach(a=>{const r=n.find(s=>s.name===a.name);if(r){const s={...r,dialogueSummaries:r.dialogueSummaries??[]};a.newDescription!==void 0&&(s.description=a.newDescription),a.newAliases!==void 0&&(s.aliases=a.newAliases),a.addAlias&&(s.aliases=Array.from(new Set([...s.aliases??[],a.addAlias]))),a.newPresenceStatus!==void 0&&(s.presenceStatus=a.newPresenceStatus),a.newLastKnownLocation!==void 0&&(s.lastKnownLocation=a.newLastKnownLocation),a.newPreciseLocation!==void 0&&(s.preciseLocation=a.newPreciseLocation),s.presenceStatus==="distant"||s.presenceStatus==="unknown"?s.preciseLocation=null:s.preciseLocation??(s.preciseLocation=s.presenceStatus==="companion"?"with you":"nearby in the scene"),o.push({type:"update",npcName:a.name,oldNPC:{...r},newNPC:s})}}),o},Vi=(e,t,n)=>{const o=[...n];return e.forEach(a=>{if(!o.some(r=>r.name===a.name)){const r={...a,id:Be(a.name),aliases:a.aliases??[],presenceStatus:a.presenceStatus??"unknown",lastKnownLocation:a.lastKnownLocation??null,preciseLocation:a.preciseLocation??null,dialogueSummaries:[]};(r.presenceStatus==="distant"||r.presenceStatus==="unknown")&&(r.preciseLocation=null),o.push(r)}}),t.forEach(a=>{const r=o.findIndex(s=>s.name===a.name);if(r!==-1){const s={...o[r],dialogueSummaries:o[r].dialogueSummaries??[]};a.newDescription!==void 0&&(s.description=a.newDescription),a.newAliases!==void 0&&(s.aliases=a.newAliases),a.addAlias&&(s.aliases=Array.from(new Set([...s.aliases??[],a.addAlias]))),a.newPresenceStatus!==void 0&&(s.presenceStatus=a.newPresenceStatus),a.newLastKnownLocation!==void 0&&(s.lastKnownLocation=a.newLastKnownLocation),a.newPreciseLocation!==void 0&&(s.preciseLocation=a.newPreciseLocation),s.presenceStatus==="distant"||s.presenceStatus==="unknown"?s.preciseLocation=null:s.preciseLocation??(s.preciseLocation=s.presenceStatus==="companion"?"with you":"nearby in the scene"),o[r]=s}}),o},Vn=(e,t,n)=>{const o=[...e,t];return o.length>n?o.slice(o.length-n):o},Gi=(e,t)=>{const n=`You left your ${t}`;for(let o=e.length-1;o>=0;o-=1)if(e[o].startsWith(n))return[...e.slice(0,o),...e.slice(o+1)];return e},mn=(e,t,n)=>{let o=e.themeFacts.length>0?Math.max(...e.themeFacts.map(a=>a.id))+1:1;for(const a of t)switch(a.action){case"add":if(a.text){const r={id:o++,text:a.text,entities:a.entities??[],createdTurn:a.createdTurn??n,tier:a.tier??1};e.themeFacts.push(r)}break;case"change":{const r=e.themeFacts.findIndex(s=>s.id===a.id);if(r>=0){const s={...e.themeFacts[r],text:a.text??e.themeFacts[r].text,entities:a.entities??e.themeFacts[r].entities,tier:a.tier??e.themeFacts[r].tier};e.themeFacts[r]=s}break}case"delete":{const r=e.themeFacts.findIndex(s=>s.id===a.id);r>=0&&e.themeFacts.splice(r,1);break}}},Yi=(e,t)=>{e.length===0||Object.keys(t).length===0||e.forEach(n=>{n.entities=n.entities.map(o=>t[o]??o)})},Hi=`You are an AI assistant specializing in updating a game map based on narrative events.
Your task is to analyze the provided game context and determine what changes should be made to the map data.
You may receive a "Map Hint" string from the storyteller describing distant quest locations, their surroundings, and how to reach them. Use these hints to ensure those locations exist on the map, adding them and their nearby context nodes if absent.

Fill the JSON object with nodes and edges to add, update, or remove based on the provided context.
Assign relevant node and edge types, statuses, and descriptions.
Ensure that the hierarchy of nodes is logical and consistent, with no feature nodes as parents of other feature nodes.

${va}
${wa}
${Ia}

CRITICAL INSTRUCTIONS:
- All nodes MUST represent physical locations. NEVER add small items and NPCs to the map!!! Nodes represent spaces the player can occupy: regions, general locations, settlements, building exteriors or interiors, rooms, and notable landscape or architectural features. Feature-type nodes represent sub-spaces within larger spaces. NEVER create nodes that represent inventory items.
- IMPORTANT: Large multi-crew vehicles (e.g., ships, airships, spaceships, trains) can be represented as nodes if they are significant locations in the narrative. They should have a "nodeType" of "exterior" and MUST have sub-nodes for their interior spaces. When creating a node for a large vehicle, ensure it has a "description" that indicates its size and purpose, and that it contains a significant number of constituent nodes required for the large vehicle operation (e.g. main deck, engine room, captain's quarters, cargo hold, bridge, observation deck, reactor room, life support, etc.). At least one of the feature nodes must be clearly defined as a connection point to the outer world (e.g., "Docking Bay", "Hangar", "Airlock", "Gang Plank" etc.).
- When considering a new location, check existing item and NPC names (including aliases). If the name matches or closely resembles one, SKIP adding that node and omit any edges that would connect to it.
- Node Fields for "nodesToAdd":
    - "aliases", "description", and "status" are ALWAYS REQUIRED for ALL added nodes.
    - You MUST provide "parentNodeId" of a node higher in the hierarchy for every node. Top level nodes should be assigned 'Universe' as their parentNodeId.
- Node Fields for "nodesToUpdate":
    - "aliases" and "description" can be optionally provided to update ANY node.
    - When adding a new main location via "nodesToAdd", the "placeName" MUST correspond to a location name that the Storyteller AI has indicated as significant.
    - You MUST include "parentNodeId" of a node higher in the hierarchy for every node.
- Node "placeName" (both for identifying nodes and for new names) should be unique within their theme. NEVER create duplicates of existing nodes or edges.
- NEVER add a node named "Universe" or create edges that reference a place named "Universe". That name is reserved for the root and already exists.
- Edges only allowed to connect nodes of type='feature' that have the same parent (siblings), that have the same grandparent (grandchildren), or where one feature's parent is the grandparent of the other (child-grandchild), or edges of type='shortcut'.
- Edges of type 'shortcut' are exempt from these hierarchy restrictions but still must connect feature nodes.
- When you add intermediate feature nodes to satisfy hierarchy rules, ALWAYS assign to them the same status as their parent node. Any edges created to replace a prior connection should keep that connection's status unless explicitly updated.
  - If the narrative suggests that a generic feature node (e.g., "Dark Alcove") has become more specific (e.g., "Shrine of Eldras"), UPDATE the existing feature node's "placeName" (if name changed via newPlaceName) and "details" via "nodesToUpdate", rather than adding a new node.
- If any new specific places (feature nodes) within or between main locations are described, add them and specify their parent via 'parentNodeId'.
- Try to assign a definitive parent node to any orphan nodes (Parent node: N/A).
- Try to fix any illogical inconsistencies in the hierarchy, such as a feature node that has no parent, illogical child-parent relationships, or wrong level of hierarchy.
- If connections (paths, doors, etc.) are revealed or changed, update edges.
- If new details are revealed about a location (main or feature), update description and/or aliases.
- If the Player's new 'localPlace' tells that they are at a specific feature node (existing or newly added), suggest it in 'suggestedCurrentMapNodeId'.
  - When renaming a node using "nodesToUpdate" (via the "newPlaceName" field), omit any matching entry in "nodesToRemove" for that node.
- Feature Nodes can have any number of edges.
- CRITICALLY IMPORTANT: Delete Nodes ONLY in EXTREME CASES when the Scene unambiguously implies that they will no longer ever be relevant to the Player.
- CRITICALLY IMPORTANT: Delete edges ONLY in EXTREME CASES when the Scene description mentions an absolutely certain destruction of the path. In all  other cases, avoid deleting edges and nodes.
`,Bi=(e,t,n,o,a,r,s,i,c,l)=>`## Narrative Context for Map Update:
  - Current Theme: "${a.name}";
  - Theme Guidance: "${a.storyGuidance}";
  - Scene Description: "${e}";
  - Log Message (outcome of last action): "${t}";
  - Player's Current Location Description (localPlace): "${n}".

## Map Context:
  - All Known Main Locations: ${i};
  - Player's Previous Location was: ${r};
  - Map Hint from Storyteller: "${o}".
  - Item Names to avoid as nodes: ${c.length>0?c.map(d=>`"${d}"`).join(", "):"None"};
  - NPC Names to avoid as nodes: ${l.length>0?l.map(d=>`"${d}"`).join(", "):"None"}.

${s}
---
Based on the Narrative Context and existing map context, provide a JSON response strongly adhering to the System Instructions.

`,Wi=async(e,t)=>{const n=Ne(e),o=ge(n);try{if(o===null)throw new Error("JSON parse failed");let a=null;if(Array.isArray(o)?a=o.reduce((i,c)=>{if(c&&typeof c=="object"){const l=c;Array.isArray(l.nodesToAdd)&&(i.nodesToAdd=[...i.nodesToAdd??[],...l.nodesToAdd]),Array.isArray(l.nodesToUpdate)&&(i.nodesToUpdate=[...i.nodesToUpdate??[],...l.nodesToUpdate]),Array.isArray(l.nodesToRemove)&&(i.nodesToRemove=[...i.nodesToRemove??[],...l.nodesToRemove]),Array.isArray(l.edgesToAdd)&&(i.edgesToAdd=[...i.edgesToAdd??[],...l.edgesToAdd]),Array.isArray(l.edgesToUpdate)&&(i.edgesToUpdate=[...i.edgesToUpdate??[],...l.edgesToUpdate]),Array.isArray(l.edgesToRemove)&&(i.edgesToRemove=[...i.edgesToRemove??[],...l.edgesToRemove]),l.suggestedCurrentMapNodeId&&!i.suggestedCurrentMapNodeId&&(i.suggestedCurrentMapNodeId=l.suggestedCurrentMapNodeId),l.observations&&!i.observations&&(i.observations=l.observations),l.rationale&&!i.rationale&&(i.rationale=l.rationale)}return i},{}):o&&typeof o=="object"&&(a=o),a&&typeof a=="object"){const i=l=>typeof l=="string"&&l.trim().toLowerCase()==="universe";Array.isArray(a.nodesToAdd)&&(a.nodesToAdd=a.nodesToAdd.filter(l=>!i(l.placeName))),Array.isArray(a.nodesToUpdate)&&(a.nodesToUpdate=a.nodesToUpdate.filter(l=>!i(l.placeName))),Array.isArray(a.nodesToRemove)&&(a.nodesToRemove=a.nodesToRemove.filter(l=>!i(l.nodeName)));const c=l=>(l??[]).filter(d=>!i(d.sourcePlaceName)&&!i(d.targetPlaceName));Array.isArray(a.edgesToAdd)&&(a.edgesToAdd=c(a.edgesToAdd)),Array.isArray(a.edgesToUpdate)&&(a.edgesToUpdate=c(a.edgesToUpdate)),Array.isArray(a.edgesToRemove),to(a)}let r;if(a){const i=[],c=console.warn;console.warn=(...d)=>{i.push(d.map(p=>String(p)).join(" ")),c(...d)};const l=Ra(a);if(console.warn=c,l)return{payload:a};r=i.length>0?i.join("; "):void 0}console.warn("Parsed map update JSON does not match AIMapUpdatePayload structure or is empty:",o);const s=await $o(n,r,t);return s?{payload:s}:{payload:null,validationError:r}}catch(a){console.error("Failed to parse map update JSON response from AI:",a),console.debug("Original map update response text:",e);const r=await $o(n,a instanceof Error?a.message:String(a),t);return r?{payload:r}:{payload:null,validationError:a instanceof Error?a.message:String(a)}}},Ji={type:"object",properties:{observations:{type:"string",minLength:2e3,description:"Contextually relevant observations about the current map state and relationships."},rationale:{type:"string",minLength:1e3,description:"Explanation of the reasons for the changes. Feature nodes can not be parents of other feature nodes."},edgesToAdd:{type:"array",items:{type:"object",properties:{description:{type:"string",description:Wt},sourcePlaceName:{type:"string",description:"Source node ID or placeName. Use placeName when referencing other nodes in this response."},status:{enum:vt,description:`One of ${Dn}`},targetPlaceName:{type:"string",description:"Target node ID or placeName. Use placeName when referencing other nodes in this response."},travelTime:{type:"string"},type:{enum:yt,description:`One of ${Ln}`}},propertyOrdering:["description","sourcePlaceName","status","targetPlaceName","travelTime","type"],required:["sourcePlaceName","status","targetPlaceName","type"],additionalProperties:!1}},edgesToRemove:{type:"array",items:{type:"object",properties:{edgeId:{type:"string"},sourceId:{type:"string"},targetId:{type:"string"}},propertyOrdering:["edgeId","sourceId","targetId"],required:["edgeId"],additionalProperties:!1}},edgesToUpdate:{type:"array",items:{type:"object",properties:{description:{type:"string",description:Wt},sourcePlaceName:{type:"string",description:"Source node ID or placeName. Use placeName when referencing other nodes in this response."},status:{enum:vt,description:`One of ${Dn}`},targetPlaceName:{type:"string",description:"Target node ID or placeName. Use placeName when referencing other nodes in this response."},travelTime:{type:"string",description:"Approximate travel time for the route."},type:{enum:yt,description:`One of ${Ln}`}},propertyOrdering:["description","sourcePlaceName","status","targetPlaceName","travelTime","type"],required:["sourcePlaceName","targetPlaceName"],additionalProperties:!1}},nodesToAdd:{type:"array",items:{type:"object",properties:{aliases:{type:"array",minItems:1,items:{type:"string"},description:Fe},description:{type:"string",minLength:30,description:ht},nodeType:{enum:$t,description:`One of ${Mn}`},parentNodeId:{type:"string",description:'Parent Node ID, or "Universe" for top-level nodes. Use placeName when referencing other nodes in this response.'},placeName:{type:"string",description:"Name of the node. Should not contain a comma. For sub-locations this can be a descriptive feature name."},status:{enum:ft,description:`One of ${kn}`}},propertyOrdering:["aliases","description","nodeType","parentNodeId","placeName","status"],required:["aliases","description","nodeType","parentNodeId","placeName","status"],additionalProperties:!1}},nodesToRemove:{type:"array",items:{type:"object",properties:{nodeId:{type:"string"},nodeName:{type:"string"}},propertyOrdering:["nodeId","nodeName"],required:["nodeId"],additionalProperties:!1}},nodesToUpdate:{type:"array",items:{type:"object",properties:{aliases:{type:"array",items:{type:"string"},minItems:1,description:Fe},description:{type:"string",description:ht},newPlaceName:{type:"string",description:"If provided, this will be the new name for the node."},nodeType:{enum:$t,description:`One of ${Mn}`},parentNodeId:{type:"string",description:'Parent Node ID, or "Universe" for top-level nodes. Parent can not be a feature node. Use placeName when referencing other nodes in this response.'},placeName:{type:"string",description:"Existing node ID or name to identify it."},status:{enum:ft,description:`One of ${kn}`}},propertyOrdering:["aliases","description","newPlaceName","nodeType","parentNodeId","placeName","status"],required:["placeName"],additionalProperties:!1}},suggestedCurrentMapNodeId:{type:"string",description:"If map updates and the context both imply a new player location, provide its node ID or placeName."}},required:["observations","rationale","edgesToAdd","edgesToRemove","edgesToUpdate","nodesToAdd","nodesToRemove","nodesToUpdate"],propertyOrdering:["observations","rationale","edgesToAdd","edgesToRemove","edgesToUpdate","nodesToAdd","nodesToRemove","nodesToUpdate","suggestedCurrentMapNodeId"],additionalProperties:!1},Ki=async(e,t)=>{if(!ee())throw console.error("API Key not configured for Map Update Service."),new Error("API Key not configured.");const n=await ie(async()=>{var d,p,u;se(ae.map.icon);const o=be(4096),{response:a,systemInstructionUsed:r,jsonSchemaUsed:s,promptUsed:i}=await re({modelNames:[Q,X,Se],prompt:e,systemInstruction:t,thinkingBudget:o,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:Ji,temperature:1,label:"Cartographer"}),l=(((u=(p=(d=a.candidates)==null?void 0:d[0])==null?void 0:p.content)==null?void 0:u.parts)??[]).filter(m=>m.thought===!0&&typeof m.text=="string").map(m=>m.text);return{result:{response:a,thoughts:l,systemInstructionUsed:r,jsonSchemaUsed:s,promptUsed:i}}});if(!n)throw new Error("Failed to execute map update request.");return n},qi=async(e,t,n,o)=>{let a=e;const r={prompt:e,systemInstruction:t,jsonSchema:void 0,observations:void 0,rationale:void 0,minimalModelCalls:n,connectorChainsDebugInfo:[]};let s=null;for(let i=0;i<W;)try{console.log(`Map Update Service: Attempt ${String(i+1)}/${String(W)}`),i>0&&r.validationError?a=`${e}
CRITICALLY IMPORTANT: Your previous attempt has triggered an error: ${r.validationError}`:a=e,r.prompt=a;const{response:c,thoughts:l,systemInstructionUsed:d,jsonSchemaUsed:p,promptUsed:u}=await Ki(a,t);r.rawResponse=c.text??"",l.length>0&&(r.thoughts=l),r.systemInstruction=d,r.jsonSchema=p,r.prompt=u;const{payload:m,validationError:g}=await Wi(c.text??"",o);if(m){r.observations=m.observations??r.observations,r.rationale=m.rationale??r.rationale,Vs(m),Ys(m);const h=to(m);if(Gs(m),!h.length){s=m,r.parsedPayload=m,r.validationError=void 0;break}r.parsedPayload=m,r.validationError=h.length>0?`Invalid values: ${h.join("; ")}`:"Parsed payload failed structural/value validation."}else r.validationError=g??"Failed to parse AI response into valid JSON map update payload.";i===W-1&&console.error("Map Update Service: Failed to get valid map update payload after all retries."),i++}catch(c){if(console.error(`Error in map update request (Attempt ${String(i+1)}/${String(W)}):`,c),r.rawResponse=`Error: ${c instanceof Error?c.message:String(c)}`,r.validationError=`Processing error: ${c instanceof Error?c.message:String(c)}`,i===W-1)break;i++}return{payload:s,debugInfo:r}},zi=(e,t)=>{const n=[];let o=t.get(e.data.parentNodeId??"");for(;o&&(n.push(o),!(!o.data.parentNodeId||o.data.parentNodeId==="Universe"));)o=t.get(o.data.parentNodeId);return n},Qa=(e,t,n)=>{let o=e;for(;o!=null&&o.data.parentNodeId&&o.data.parentNodeId!=="Universe";){if(o.data.parentNodeId===t.id)return!0;o=n.get(o.data.parentNodeId)}return!1},Kl=(e,t,n)=>{const o=new Map(e.nodes.map(s=>[s.id,s])),a=o.get(t),r=o.get(n);return!a||!r?!1:Qa(a,r,o)},Xa=(e,t)=>{const{adjacency:n}=un(e),o=new Map(e.edges.map(r=>[r.id,r])),a=["open","accessible","active"];return(n.get(t)??[]).filter(r=>{const s=o.get(r.edgeId);if(!s)return!0;const i=s.data.status??"open";return a.includes(i)}).map(r=>r.to)},Qi=e=>{const t=new Map,n=o=>o!=="rumored"&&o!=="removed";for(const o of e.edges){if(!n(o.data.status))continue;t.has(o.sourceNodeId)||t.set(o.sourceNodeId,[]);const a=t.get(o.sourceNodeId)??[];a.push({nodeId:o.targetNodeId,edgeId:o.id}),t.set(o.sourceNodeId,a),t.has(o.targetNodeId)||t.set(o.targetNodeId,[]);const r=t.get(o.targetNodeId)??[];r.push({nodeId:o.sourceNodeId,edgeId:o.id}),t.set(o.targetNodeId,r)}return t},Xi=(e,t,n,o)=>{const a=new Set,r=[];for(a.add(t),r.push(t);r.length>0;){const s=r.shift();if(!s)continue;if(s===n)return!0;const i=e.get(s)??[];for(const{nodeId:c,edgeId:l}of i)l!==o&&(a.has(c)||(a.add(c),r.push(c)))}return!1},Fo=e=>e?Pe[e]:-1,Za=(e,t,n)=>{let o=e;const a=Fo(t);for(;o&&Fo(o.data.nodeType)>=a;){if(!o.data.parentNodeId)return;o=n.get(o.data.parentNodeId)}return o?o.id:void 0},Zi={region:"location",location:"settlement",settlement:void 0,district:void 0,exterior:void 0,interior:"room",room:"feature",feature:void 0},ec={feature:"room",room:"interior",interior:"exterior",exterior:"district",district:"settlement",settlement:"location",location:"region",region:void 0},co=(e,t,n)=>{const o=Zi[e.data.nodeType];if(!o||Pe[t]>=Pe[o])return null;const a=Pe[o];return n.filter(s=>s.data.parentNodeId===e.id).every(s=>Pe[s.data.nodeType]>a)?o:null},tc=(e,t)=>{const n=ec[e.data.nodeType];if(!n)return null;const o=Pe[n];if(e.data.parentNodeId){const r=t.find(s=>s.id===e.data.parentNodeId);if(r&&Pe[r.data.nodeType]>=o)return null}return t.filter(r=>r.data.parentNodeId===e.id).some(r=>Pe[r.data.nodeType]<=o)?null:n},nc=e=>{const t=new Map(e.map(n=>[n.id,n]));for(const n of e){const o=n.data.parentNodeId;if(!o||o==="Universe")continue;const a=t.get(o);if(a&&Pe[a.data.nodeType]>=Pe[n.data.nodeType])return!0}return!1},oc=(e,t,n="New Approach")=>{const o=Z(e),a=o.nodes.findIndex(d=>d.id===t);if(a===-1)return{updatedMapData:o,newNode:null,newEdges:[]};const r=o.nodes[a];if(r.data.nodeType!=="feature")return{updatedMapData:o,newNode:null,newEdges:[]};r.data.nodeType="region";const s=Xe(`node_${n}_`),i={id:s,placeName:n,position:{...r.position},data:{description:r.data.description,aliases:r.data.aliases??[],status:r.data.status,nodeType:"feature",parentNodeId:r.id,visited:r.data.visited}};o.nodes.push(i),o.edges.forEach(d=>{d.sourceNodeId===t&&(d.sourceNodeId=s),d.targetNodeId===t&&(d.targetNodeId=s)});const c=o.nodes.filter(d=>d.data.parentNodeId===t&&d.id!==s),l=[];return c.forEach(d=>{const u={id:Xe(`edge_${s}_to_${d.id}`),sourceNodeId:s,targetNodeId:d.id,data:{type:"path",status:r.data.status==="rumored"?"rumored":"open",description:`Connection from ${n} to ${d.placeName}`}};o.edges.push(u),l.push(u)}),{updatedMapData:o,newNode:i,newEdges:l}},ac=async(e,t)=>{let n=Z(e);const o=[],a=[];for(const r of n.nodes)if(r.data.nodeType==="feature"){const s=n.nodes.filter(i=>i.data.parentNodeId===r.id);if(s.length>0)if(await ks(r,s[0])==="convert_child")s.forEach(c=>{c.data.parentNodeId=r.data.parentNodeId});else{const c=oc(n,r.id,"Temp Approach");n=c.updatedMapData,c.newNode&&o.push(c.newNode),a.push(...c.newEdges)}}return{updatedMapData:n,addedNodes:o,addedEdges:a}},rc=async(e,t)=>{try{return(await ac(e,t)).updatedMapData}catch(n){return console.error("repairFeatureHierarchy error:",n),e}};function Ze(e,t,n,o){var p,u,m,g;if(e.data.nodeType!=="feature"||t.data.nodeType!=="feature")return!1;if(n==="shortcut")return!0;const a=o??new Map,r=e.data.parentNodeId??"Universe",s=t.data.parentNodeId??"Universe",i=r==="Universe"?null:a.get(r),c=s==="Universe"?null:a.get(s);if(!i&&r!=="Universe"||!c&&s!=="Universe")return!1;if(r===s)return!0;const l=r==="Universe"?"Universe":((p=a.get(r))==null?void 0:p.data.parentNodeId)??"Universe",d=s==="Universe"?"Universe":((u=a.get(s))==null?void 0:u.data.parentNodeId)??"Universe";if(l&&d&&l===d||l&&s===l||d&&r===d)return!0;if(r!=="Universe"&&s!=="Universe"){const h=((m=a.get(r))==null?void 0:m.data.parentNodeId)??"Universe",v=((g=a.get(s))==null?void 0:g.data.parentNodeId)??"Universe";if(h==="Universe"&&v==="Universe")return!0}return r==="Universe"&&d==="Universe"||s==="Universe"&&l==="Universe"}function lo(e,t,n,o,a){const r=(a.get(e.id)??[]).find(d=>(d.sourceNodeId===e.id&&d.targetNodeId===t.id||d.sourceNodeId===t.id&&d.targetNodeId===e.id)&&d.data.type===n.type);if(r)return r;const i={id:Xe(`edge_${e.id}_to_${t.id}_`),sourceNodeId:e.id,targetNodeId:t.id,data:n};o.push(i);let c=a.get(e.id);c||(c=[],a.set(e.id,c)),c.push(i);let l=a.get(t.id);return l||(l=[],a.set(t.id,l)),l.push(i),i}function Vo(e,t){return e.filter(n=>{const o=t.get(n.sourceNodeId),a=t.get(n.targetNodeId);return!o||!a?!1:Ze(o,a,n.data.type,t)})}function Go(e,t){let n=0,o=e;for(;o.data.parentNodeId;){const a=t.get(o.data.parentNodeId);if(!a)break;n++,o=a}return n}function uo(e,t,n,o){const a=[],r=[e],s=[t];let i=e,c=t,l=0,d="";for(;!Ze(i,c,n.type,o)&&l<10;){const p=`${i.id}|${c.id}`;p!==d&&(a.push({sourceParent:i,targetParent:c}),d=p);const u=Go(i,o),m=Go(c,o);if(u>=m&&i.data.parentNodeId){const g=o.get(i.data.parentNodeId);if(g)i=g,r.push(i);else break}else if(c.data.parentNodeId){const g=o.get(c.data.parentNodeId);if(g)c=g,s.push(c);else break}else break;l++}return Ze(i,c,n.type,o)||`${i.id}|${c.id}`!==d&&a.push({sourceParent:i,targetParent:c}),{originalSource:e,originalTarget:t,pairs:a,sourceChain:r,targetChain:s,edgeData:n}}function sc(e){const t=new Set,n=[];return[...e.sourceChain,...e.targetChain.slice().reverse()].forEach(o=>{o.data.nodeType!=="feature"&&!t.has(o.id)&&(n.push(o.id),t.add(o.id))}),n.length===0&&(t.has(e.originalSource.id)||(n.push(e.originalSource.id),t.add(e.originalSource.id)),t.has(e.originalTarget.id)||n.push(e.originalTarget.id)),n}function jt(e,t){if(e.length>t.length)return!1;for(let n=0;n<=t.length-e.length;n++){let o=!0;for(let a=0;a<e.length;a++)if(e[a]!==t[n+a]){o=!1;break}if(o)return!0}return!1}function Pn(e){const t=[],n=[];return e.forEach(o=>{const a=sc(o),r=[...a].reverse();let s=!1;for(let i=0;i<n.length;i++){const c=n[i],l=[...c].reverse();if(a.length===c.length&&a.every((u,m)=>u===c[m])||a.length===c.length&&r.every((u,m)=>u===c[m])){s=!0;break}if(a.length<=c.length&&(jt(a,c)||jt(r,c))||a.length>c.length&&(jt(c,a)||jt(l,a))){a.length>c.length&&(t[i]=o,n[i]=a),s=!0;break}}s||(t.push(o),n.push(a))}),t}async function ic(e){var l;let t=[...e.payload.nodesToAdd??[]];e.nodesToRemove_mut=[...e.payload.nodesToRemove??[]],e.edgesToAdd_mut=[...e.payload.edgesToAdd??[]],e.edgesToRemove_mut=[...e.payload.edgesToRemove??[]];const n=[],o=new Set;for(const d of t){if(e.nameMatchesItemOrNPC(d.placeName)){console.warn(`MapUpdate: Skipping node add "${d.placeName}" that resembles an item or NPC.`),o.add(d.placeName);continue}const p=e.nodesToRemove_mut.findIndex(u=>u.nodeName&&u.nodeName.toLowerCase()===d.placeName.toLowerCase());p!==-1?e.nodesToRemove_mut.splice(p,1):n.push(d)}t=n;const a=[];for(const d of e.edgesToAdd_mut)a.push(d);e.edgesToAdd_mut=a;const r=[],s=new Set;for(const d of e.edgesToAdd_mut){const p=d.sourcePlaceName.toLowerCase(),u=d.targetPlaceName.toLowerCase(),m=d.type,g=String(m),h=p<u?`${p}|${u}|${g}`:`${u}|${p}|${g}`;s.has(h)||(s.add(h),r.push(d))}e.edgesToAdd_mut=r,o.size>0&&(e.edgesToAdd_mut=e.edgesToAdd_mut.filter(d=>!o.has(d.sourcePlaceName)&&!o.has(d.targetPlaceName))),t.forEach(d=>{const p=Fn(d.placeName);d.__generatedId=p,e.newNodesInBatchIdNameMap[d.placeName]={id:p,name:d.placeName}}),(e.payload.nodesToUpdate??[]).forEach(d=>{const p=[d.placeName.toLowerCase()];d.newPlaceName&&p.push(d.newPlaceName.toLowerCase());for(const u of p){const m=e.nodesToRemove_mut.findIndex(g=>g.nodeName&&g.nodeName.toLowerCase()===u);m!==-1&&e.nodesToRemove_mut.splice(m,1)}});let i=[...t],c=!1;for(;i.length>0;){const d=[];for(const p of i){let u,m=null;if(p.parentNodeId)if(p.parentNodeId==="Universe")u=void 0;else{const M=je(p.parentNodeId,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId);if(M){let A=p.nodeType;if(M.data.nodeType===A){const w=co({id:"temp",placeName:p.placeName,data:{description:p.description,aliases:p.aliases,status:p.status,parentNodeId:M.id,nodeType:A}},M.data.nodeType,e.newMapData.nodes);w?(p.nodeType=w,A=w,u=M.id):(m=M,u=M.id)}else u=Za(M,A,e.themeNodeIdMap)}else{d.push(p);continue}}const g=je(p.placeName,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId);if(g!==void 0&&(u===void 0&&!g.data.parentNodeId||g.data.parentNodeId===u)&&(g.placeName.toLowerCase()===p.placeName.toLowerCase()||(((l=g.data.aliases)==null?void 0:l.some(M=>M.toLowerCase()===p.placeName.toLowerCase()))??!1)||p.aliases.some(M=>M.toLowerCase()===g.placeName.toLowerCase()))){const M=g,A=new Set([...M.data.aliases??[]]);p.aliases.forEach(w=>A.add(w)),M.data.aliases=Array.from(A),p.description&&M.data.description.trim().length===0&&(M.data.description=p.description),Reflect.deleteProperty(e.newNodesInBatchIdNameMap,p.placeName);continue}const f=p.__generatedId??Fn(p.placeName),{description:I,aliases:T,status:k,nodeType:y,parentNodeId:P,...S}=p,C={description:I,aliases:T,status:k,parentNodeId:u,nodeType:y,...S},$={id:f,placeName:p.placeName,position:{x:0,y:0},data:C};if(e.newMapData.nodes.push($),e.newlyAddedNodes.push($),e.themeNodeIdMap.set(f,$),e.themeNodeNameMap.set(p.placeName,$),$.data.aliases&&$.data.aliases.forEach(M=>e.themeNodeAliasMap.set(M.toLowerCase(),$)),e.newNodesInBatchIdNameMap[p.placeName]={id:f,name:p.placeName},m){const M={type:"path",status:$.data.status==="rumored"||m.data.status==="rumored"?"rumored":"open",description:`Path between ${p.placeName} and ${m.placeName}`};Ze($,m,"path",e.themeNodeIdMap)?lo($,m,M,e.newMapData.edges,e.themeEdgesMap):e.pendingChainRequests.push(uo($,m,M,e.themeNodeIdMap))}}if(d.length===i.length)if(c){console.warn("MapUpdate: Some nodes could not be added due to unresolved parents after AI assistance:",d.map(p=>p.placeName).join(", "));break}else{for(const p of d){const u=await Es({placeName:p.placeName,description:p.description,nodeType:p.nodeType,status:p.status,aliases:p.aliases},{sceneDescription:e.sceneDesc,logMessage:e.logMsg,localPlace:e.localPlace,currentTheme:e.currentTheme,currentMapNodeId:e.referenceMapNodeId,themeNodes:e.currentThemeNodesFromMapData,themeEdges:e.currentThemeEdgesFromMapData},e.minimalModelCalls);p.parentNodeId=u??"Universe"}c=!0,i=d;continue}i=d}}async function cc(e){var t;for(const n of e.payload.nodesToUpdate??[]){const o=await e.resolveNodeReference(n.placeName);if(o){let a=o.data.parentNodeId??void 0;if(n.parentNodeId!==void 0){const r=n.parentNodeId;if(r==="Universe")a=void 0;else{const s=await e.resolveNodeReference(r);if(s){a=s.id;let i=n.nodeType??o.data.nodeType;if(s.data.nodeType===i){const c=co(o,s.data.nodeType,e.newMapData.nodes);c?(i=c,a=s.id):a=s.data.parentNodeId}o.data.nodeType=i}else console.warn(`MapUpdate (nodesToUpdate): Feature node "${n.placeName}" trying to update parentNodeId to NAME "${n.parentNodeId}" which was not found.`),a=void 0}}if(n.parentNodeId===void 0&&n.nodeType!==void 0&&(o.data.nodeType=n.nodeType),n.description!==void 0&&(o.data.description=n.description),n.aliases!==void 0){o.data.aliases=n.aliases;for(const[r,s]of Array.from(e.themeNodeAliasMap.entries()))s.id===o.id&&e.themeNodeAliasMap.delete(r);o.data.aliases.forEach(r=>e.themeNodeAliasMap.set(r.toLowerCase(),o))}n.status!==void 0&&(o.data.status=n.status),o.data.parentNodeId=a;for(const r in n)["description","aliases","status","parentNodeId","nodeType","placeName","visited","newPlaceName"].includes(r)||(o.data[r]=n[r]);if(n.newPlaceName&&n.newPlaceName!==o.placeName){const r=Object.keys(e.newNodesInBatchIdNameMap).find(i=>e.newNodesInBatchIdNameMap[i].id===o.id);r&&(Reflect.deleteProperty(e.newNodesInBatchIdNameMap,r),e.newNodesInBatchIdNameMap[n.newPlaceName]={id:o.id,name:n.newPlaceName}),e.themeNodeNameMap.delete(o.placeName);const s=o.placeName;o.placeName=n.newPlaceName,e.themeNodeNameMap.set(o.placeName,o),(t=o.data).aliases??(t.aliases=[]),o.data.aliases.includes(s)||o.data.aliases.push(s);for(const[i,c]of Array.from(e.themeNodeAliasMap.entries()))c.id===o.id&&e.themeNodeAliasMap.delete(i);o.data.aliases.forEach(i=>e.themeNodeAliasMap.set(i.toLowerCase(),o))}}else console.warn(`MapUpdate (nodesToUpdate): Node with original name "${n.placeName}" not found for update.`)}for(const n of e.nodesToRemove_mut){let o=await e.resolveNodeReference(n.nodeId);if(!o&&n.nodeName&&(o=await e.resolveNodeReference(n.nodeName)),o){if(n.nodeName&&o.placeName.toLowerCase()!==n.nodeName.toLowerCase()&&console.warn(`MapUpdate (nodesToRemove): nodeId "${n.nodeId}" resolves to "${o.placeName}" which mismatches provided nodeName "${n.nodeName}".`),e.inventoryItems.some(c=>{var l;return c.holderId===o.id&&!((l=c.tags)!=null&&l.includes("junk"))})){console.warn(`MapUpdate (nodesToRemove): Skipping removal of "${o.placeName}" because it contains non-junk items.`);continue}const r=o.id,s=e.newMapData.nodes.findIndex(c=>c.id===r);s!==-1&&e.newMapData.nodes.splice(s,1),e.themeNodeNameMap.delete(o.placeName),e.themeNodeIdMap.delete(r),e.newMapData.edges=e.newMapData.edges.filter(c=>c.sourceNodeId!==r&&c.targetNodeId!==r),e.themeEdgesMap.forEach((c,l)=>{e.themeEdgesMap.set(l,c.filter(d=>d.sourceNodeId!==r&&d.targetNodeId!==r))}),e.themeEdgesMap.delete(r);for(const[c,l]of Array.from(e.themeNodeAliasMap.entries()))l.id===r&&e.themeNodeAliasMap.delete(c);const i=Object.keys(e.newNodesInBatchIdNameMap).find(c=>e.newNodesInBatchIdNameMap[c].id===r||c===n.nodeName);i&&Reflect.deleteProperty(e.newNodesInBatchIdNameMap,i)}else console.warn(`MapUpdate (nodesToRemove): Node "${n.nodeId}" not found for removal.`)}}async function lc(e){var t;for(const n of e.edgesToAdd_mut){const o=await e.resolveNodeReference(n.sourcePlaceName),a=await e.resolveNodeReference(n.targetPlaceName);if(!o||!a){console.warn(`MapUpdate: Skipping edge add due to missing source ("${n.sourcePlaceName}") or target ("${n.targetPlaceName}") node.`);continue}const r=e.themeNodeIdMap.get(o.id),s=e.themeNodeIdMap.get(a.id);if(!r||!s){console.warn("MapUpdate: Failed to resolve edge nodes after lookup.");continue}const i=r.id<s.id?`${r.id}|${s.id}|${n.type??"path"}`:`${s.id}|${r.id}|${n.type??"path"}`;if(e.processedChainKeys.has(i))continue;e.processedChainKeys.add(i);const c=uo(r,s,{description:n.description,status:n.status,travelTime:n.travelTime,type:n.type},e.themeNodeIdMap);if(!Ze(r,s,n.type,e.themeNodeIdMap)){e.pendingChainRequests.push(c);continue}lo(r,s,{description:n.description,type:n.type,travelTime:n.travelTime,status:n.status??(r.data.status==="rumored"||s.data.status==="rumored"?"rumored":"open")},e.newMapData.edges,e.themeEdgesMap)}for(const n of e.payload.edgesToUpdate??[]){const o=await e.resolveNodeReference(n.sourcePlaceName),a=await e.resolveNodeReference(n.targetPlaceName);if(!o||!a){console.warn(`MapUpdate: Skipping edge update due to missing source ("${n.sourcePlaceName}") or target ("${n.targetPlaceName}") node.`);continue}const r=o.id,s=a.id,i=e.themeNodeIdMap.get(r),c=e.themeNodeIdMap.get(s);if(!i||!c)continue;const l=(e.themeEdgesMap.get(r)??[]).filter(u=>u.sourceNodeId===r&&u.targetNodeId===s||u.sourceNodeId===s&&u.targetNodeId===r),d=n.type??((t=l[0])==null?void 0:t.data.type);if(!Ze(i,c,d,e.themeNodeIdMap)){console.warn(`MapUpdate: Edge update between "${i.placeName}" and "${c.placeName}" violates hierarchy rules. Skipping update.`);continue}const p=l.find(u=>n.type?u.data.type===n.type:!0);if(!p){console.warn(`MapUpdate (edgesToUpdate): Edge between "${n.sourcePlaceName}" and "${n.targetPlaceName}" not found for update.`);continue}p.data={...p.data,description:n.description??p.data.description,status:n.status??p.data.status,travelTime:n.travelTime??p.data.travelTime,type:n.type??p.data.type}}for(const n of e.edgesToRemove_mut){let o=e.newMapData.edges.find(s=>s.id===n.edgeId)??e.newMapData.edges.find(s=>s.id.toLowerCase().includes(n.edgeId.toLowerCase()));if(!o&&n.sourceId&&n.targetId){const s=await e.resolveNodeReference(n.sourceId),i=await e.resolveNodeReference(n.targetId);if(!s||!i){console.warn(`MapUpdate: Skipping edge removal due to missing source ("${n.sourceId}") or target ("${n.targetId}") node.`);continue}o=e.newMapData.edges.find(c=>c.sourceNodeId===s.id&&c.targetNodeId===i.id||c.sourceNodeId===i.id&&c.targetNodeId===s.id)??void 0}else o&&(n.sourceId&&o.sourceNodeId!==n.sourceId&&o.targetNodeId!==n.sourceId||n.targetId&&o.sourceNodeId!==n.targetId&&o.targetNodeId!==n.targetId)&&console.warn(`MapUpdate (edgesToRemove): edgeId "${n.edgeId}" does not match provided sourceId/targetId.`);if(!o){console.warn(`MapUpdate (edgesToRemove): Edge "${n.edgeId}" not found for removal.`);continue}e.newMapData.edges=e.newMapData.edges.filter(s=>s!==o);const a=e.themeEdgesMap.get(o.sourceNodeId);a&&e.themeEdgesMap.set(o.sourceNodeId,a.filter(s=>s!==o));const r=e.themeEdgesMap.get(o.targetNodeId);r&&e.themeEdgesMap.set(o.targetNodeId,r.filter(s=>s!==o))}}async function dc(e){var a;let t=Pn(e.pendingChainRequests.splice(0)),n=0;const o={sceneDescription:e.sceneDesc,logMessage:e.logMsg,currentTheme:e.currentTheme,themeNodes:e.newMapData.nodes};for(;t.length>0&&n<mo;){t=Pn(t);let r=null;for(let s=0;s<W&&(console.log(`Connector Chains Refinement: Round ${String(n+1)}/${String(mo)}, Attempt ${String(s+1)}/${String(W)}`),r=await Ms(t,o),r.debugInfo&&((a=e.debugInfo.connectorChainsDebugInfo)==null||a.push({round:n+1,...r.debugInfo})),!r.payload);)console.warn(`Connector Chains Refinement (Round ${String(n+1)}, Attempt ${String(s+1)}): invalid or empty response. Retrying.`),s++;if(r!=null&&r.payload)t=[],(r.payload.nodesToAdd??[]).forEach(s=>{const i=s,c=i.parentNodeId&&i.parentNodeId!=="Universe"?je(i.parentNodeId,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId):void 0,l=c?c.id:void 0,d=je(s.placeName,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId);if(d){if(Array.isArray(i.aliases)&&i.aliases.length>0){const m=new Set([...d.data.aliases??[]]);i.aliases.forEach(g=>m.add(g)),d.data.aliases=Array.from(m)}i.description&&d.data.description.trim().length===0&&(d.data.description=i.description);return}const u={id:Xe(`node_${s.placeName}_`),placeName:s.placeName,position:c?{...c.position}:{x:0,y:0},data:{...i,parentNodeId:l}};e.newMapData.nodes.push(u),e.newlyAddedNodes.push(u),e.themeNodeIdMap.set(u.id,u),e.themeNodeNameMap.set(u.placeName,u)}),(r.payload.edgesToAdd??[]).forEach(s=>{const i=s,c=je(s.sourcePlaceName,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId),l=je(s.targetPlaceName,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId);if(c&&l){const d=c.id<l.id?`${c.id}|${l.id}|${i.type??"path"}`:`${l.id}|${c.id}|${i.type??"path"}`;if(e.processedChainKeys.has(d))return;e.processedChainKeys.add(d),Ze(c,l,i.type,e.themeNodeIdMap)?lo(c,l,{description:i.description,status:i.status,travelTime:i.travelTime,type:i.type},e.newMapData.edges,e.themeEdgesMap):(console.warn(`Connector chain edge between "${c.placeName}" and "${l.placeName}" violates hierarchy rules. Reprocessing.`),t.push(uo(c,l,{description:i.description,status:i.status,travelTime:i.travelTime,type:i.type},e.themeNodeIdMap)))}}),o.themeNodes=e.newMapData.nodes;else{console.warn(`Connector Chains Refinement failed after ${String(W)} attempts for round ${String(n+1)}. Giving up on these chain requests.`);break}t=Pn(t),n++}e.debugInfo.connectorChainsDebugInfo&&e.debugInfo.connectorChainsDebugInfo.length===0&&(e.debugInfo.connectorChainsDebugInfo=null)}async function uc(e){for(const t of e.newMapData.nodes){const n=t.data.parentNodeId;if(!n||n==="Universe")continue;const o=e.themeNodeIdMap.get(n);o&&o.data.nodeType===t.data.nodeType&&await pc(e,t,o)}}async function pc(e,t,n){var c;const o=[],a=co(t,n.data.nodeType,e.newMapData.nodes);if(a&&o.push({desc:`Downgrade ${t.placeName} to ${a}`,apply:()=>{t.data.nodeType=a},cloneApply:l=>{const d=l.find(p=>p.id===t.id);d&&(d.data.nodeType=a)}}),n.data.parentNodeId!==void 0){const l=Za(n.data.parentNodeId==="Universe"?void 0:e.themeNodeIdMap.get(n.data.parentNodeId),t.data.nodeType,e.themeNodeIdMap);if(l!==void 0&&l!==t.data.parentNodeId){const d=((c=e.themeNodeIdMap.get(l))==null?void 0:c.placeName)??"Unknown";o.push({desc:`Reparent ${t.placeName} under ${d}`,apply:()=>{t.data.parentNodeId=l},cloneApply:p=>{const u=p.find(m=>m.id===t.id);u&&(u.data.parentNodeId=l)}})}}const r=tc(n,e.newMapData.nodes);r&&o.push({desc:`Upgrade ${n.placeName} to ${r}`,apply:()=>{n.data.nodeType=r},cloneApply:l=>{const d=l.find(p=>p.id===n.id);d&&(d.data.nodeType=r)}});const s=o.filter(l=>{const d=e.newMapData.nodes.map(p=>({...p,data:{...p.data}}));return l.cloneApply(d),!nc(d)});if(s.length===0)return;let i=s[0];if(s.length>1){const l=await Ls({sceneDescription:e.sceneDesc,parent:n,child:t,options:s.map(d=>d.desc)},e.minimalModelCalls);l&&l>=1&&l<=s.length&&(i=s[l-1])}i.apply()}const mc=async({payload:e,currentMapData:t,currentTheme:n,previousMapNodeId:o,inventoryItems:a,knownNPCs:r,aiData:s,minimalModelCalls:i,debugInfo:c})=>{const l="sceneDescription"in s?s.sceneDescription:"",d=s.logMessage??"",p=s.localPlace??"Unknown",u="currentMapNodeId"in s&&s.currentMapNodeId?s.currentMapNodeId:o,m=t.nodes,g=new Set(m.map(E=>E.id)),h=t.edges.filter(E=>g.has(E.sourceNodeId)&&g.has(E.targetNodeId)),v=new Map,f=new Map,I=new Map,T=new Map;m.forEach(E=>{v.set(E.id,E),f.set(E.placeName,E),E.data.aliases&&E.data.aliases.forEach(_=>I.set(_.toLowerCase(),E))}),h.forEach(E=>{T.has(E.sourceNodeId)||T.set(E.sourceNodeId,[]),T.has(E.targetNodeId)||T.set(E.targetNodeId,[]);const _=T.get(E.sourceNodeId);_&&_.push(E);const R=T.get(E.targetNodeId);R&&R.push(E)});const k=async E=>{let _=je(E,M.nodes,M,u);if(!_){const G=/^(.*)_([a-zA-Z0-9]{4})$/.exec(E);if(G){const V=G[1].toLowerCase(),H=Object.values(A).filter(B=>B.id.toLowerCase().startsWith(`${V}_`));if(H.length===1&&(_=M.nodes.find(B=>B.id===H[0].id),!_))return}}if(!_){const R=await Ps(E,{themeNodes:M.nodes,currentLocationId:u},i);R&&(_=je(R,M.nodes,M,u))}return _},y=E=>E.toLowerCase().replace(/[{}().,!?;:"[\]]/g,"").replace(/\s+/g," ").trim(),P=E=>y(E).split(" ").filter(_=>_.length>0),S=a.map(E=>({norm:y(E.name),tokens:P(E.name)})),C=[];r.forEach(E=>{C.push({norm:y(E.name),tokens:P(E.name)}),(E.aliases??[]).forEach(_=>{C.push({norm:y(_),tokens:P(_)})})});const $=E=>{const _=y(E),R=P(E),G=V=>{if(V.norm===_)return!0;const H=R.filter(ce=>V.tokens.includes(ce)),B=H.length/R.length,J=H.length/V.tokens.length;return H.length>0&&B>=.6&&J>=.6};return S.some(G)||C.some(G)},M=Z(t),A={},w=[],N=[],L=[],D=new Set,x=[],K=[],le=[];v.clear(),f.clear(),I.clear(),T.clear(),M.nodes.forEach(E=>{v.set(E.id,E),f.set(E.placeName,E),E.data.aliases&&E.data.aliases.forEach(_=>I.set(_.toLowerCase(),E))}),M.edges.forEach(E=>{if(v.has(E.sourceNodeId)&&v.has(E.targetNodeId)){T.has(E.sourceNodeId)||T.set(E.sourceNodeId,[]),T.has(E.targetNodeId)||T.set(E.targetNodeId,[]);const _=T.get(E.sourceNodeId);_&&_.push(E);const R=T.get(E.targetNodeId);R&&R.push(E)}});const j={payload:e,newMapData:M,currentTheme:n,referenceMapNodeId:u,currentThemeNodesFromMapData:m,currentThemeEdgesFromMapData:h,themeNodeIdMap:v,themeNodeNameMap:f,themeNodeAliasMap:I,themeEdgesMap:T,newNodesInBatchIdNameMap:A,newlyAddedNodes:w,newlyAddedEdges:N,pendingChainRequests:L,processedChainKeys:D,nodesToRemove_mut:x,edgesToAdd_mut:K,edgesToRemove_mut:le,resolveNodeReference:k,nameMatchesItemOrNPC:$,minimalModelCalls:i,sceneDesc:l,logMsg:d,localPlace:p,debugInfo:c,inventoryItems:a};await ic(j),await cc(j),await uc(j),await lc(j),j.newMapData.edges=Vo(j.newMapData.edges,j.themeNodeIdMap),j.themeEdgesMap.clear(),j.newMapData.edges.forEach(E=>{j.themeEdgesMap.has(E.sourceNodeId)||j.themeEdgesMap.set(E.sourceNodeId,[]),j.themeEdgesMap.has(E.targetNodeId)||j.themeEdgesMap.set(E.targetNodeId,[]);const _=j.themeEdgesMap.get(E.sourceNodeId);_&&_.push(E);const R=j.themeEdgesMap.get(E.targetNodeId);R&&R.push(E)}),await dc(j);const ye=E=>a.some(_=>{var R;return _.holderId===E&&!((R=_.tags)!=null&&R.includes("junk"))}),ue=E=>{if(ye(E.id)){console.warn(`Sanity check: skipping removal of "${E.placeName}" because it contains non-junk items.`);return}const _=E.id,R=j.newMapData.nodes.findIndex(V=>V.id===_);R!==-1&&j.newMapData.nodes.splice(R,1),j.themeNodeNameMap.delete(E.placeName),j.themeNodeIdMap.delete(_),j.newMapData.edges=j.newMapData.edges.filter(V=>V.sourceNodeId!==_&&V.targetNodeId!==_),j.themeEdgesMap.forEach((V,H)=>{j.themeEdgesMap.set(H,V.filter(B=>B.sourceNodeId!==_&&B.targetNodeId!==_))}),j.themeEdgesMap.delete(_);for(const[V,H]of Array.from(j.themeNodeAliasMap.entries()))H.id===_&&j.themeNodeAliasMap.delete(V);const G=Object.keys(j.newNodesInBatchIdNameMap).find(V=>j.newNodesInBatchIdNameMap[V].id===_||V===E.placeName);G&&Reflect.deleteProperty(j.newNodesInBatchIdNameMap,G)},de=new Map;a.forEach(E=>{E.type!=="vehicle"&&de.set(y(E.name),E)});const U=new Set;r.forEach(E=>{U.add(y(E.name)),(E.aliases??[]).forEach(_=>U.add(y(_)))}),j.newMapData.nodes.forEach(E=>{const _=y(E.placeName);(de.has(_)||U.has(_))&&ue(E)});const F=new Set;r.filter(E=>E.presenceStatus==="companion").forEach(E=>{F.add(y(E.name)),(E.aliases??[]).forEach(_=>F.add(y(_)))});const q=a.filter(E=>{const _=y(E.name);return!(E.type!=="vehicle"&&F.has(_))});return a.splice(0,a.length,...q),j.newMapData.edges=Vo(j.newMapData.edges,j.themeNodeIdMap),j.themeEdgesMap.clear(),j.newMapData.edges.forEach(E=>{j.themeEdgesMap.has(E.sourceNodeId)||j.themeEdgesMap.set(E.sourceNodeId,[]),j.themeEdgesMap.has(E.targetNodeId)||j.themeEdgesMap.set(E.targetNodeId,[]);const _=j.themeEdgesMap.get(E.sourceNodeId);_&&_.push(E);const R=j.themeEdgesMap.get(E.targetNodeId);R&&R.push(E)}),{updatedMapData:M,newlyAddedNodes:w,newlyAddedEdges:N,debugInfo:c}},gc=async(e,t,n,o,a,r,s)=>{if(!ee())return console.error("API Key not configured for Map Update Service."),null;const i="sceneDescription"in e?e.sceneDescription:"",c=e.logMessage??"",l=e.localPlace??"Unknown",d=e.mapHint??"",p="currentMapNodeId"in e&&e.currentMapNodeId?e.currentMapNodeId:a,u=t.nodes,m=new Set(u.map(A=>A.id)),g=t.edges.filter(A=>m.has(A.sourceNodeId)&&m.has(A.targetNodeId)),h=[],v=p??"Player's Previous Map Node: Unknown or N/A.",f=`Current Map Nodes (for your reference):
${u.length>0?ss(u):"None exist yet."}

Current Map Edges (for your reference):
${g.length>0?g.map(A=>as(A)).join(`
`):"None exist yet."}`,I=o.length>0?o.map(A=>`"${A.placeName}"`).join(", "):"No important places are known yet.",T=new Set;r.forEach(A=>{A.type!=="vehicle"&&T.add(A.name)}),"newItems"in e&&e.newItems&&e.newItems.forEach(A=>{A.type!=="vehicle"&&T.add(A.name)});const k=Array.from(T),y=new Set;s.forEach(A=>{y.add(A.name),(A.aliases??[]).forEach(w=>y.add(w))}),"npcsAdded"in e&&e.npcsAdded&&e.npcsAdded.forEach(A=>{y.add(A.name),(A.aliases??[]).forEach(w=>y.add(w))}),"npcsUpdated"in e&&e.npcsUpdated&&e.npcsUpdated.forEach(A=>{y.add(A.name),(A.newAliases??[]).forEach(w=>y.add(w)),A.addAlias&&y.add(A.addAlias)});const P=Array.from(y),S=Bi(i,c,l,d,n,v,f,I,k,P),{payload:C,debugInfo:$}=await qi(S,Hi,h,n);return C?await mc({payload:C,currentMapData:t,currentTheme:n,previousMapNodeId:a,inventoryItems:r,knownNPCs:s,aiData:e,minimalModelCalls:h,debugInfo:$}):{updatedMapData:null,newlyAddedNodes:[],newlyAddedEdges:[],debugInfo:$}},hc=[{keywords:["inside of","inside"],type:"direct",weight:100},{keywords:["atop of","atop"],type:"direct",weight:100},{keywords:["at the center of","at the heart of","at the"],type:"direct",weight:90},{keywords:["at"],type:"direct",weight:85},{keywords:["within"],type:"direct",weight:95},{keywords:["on top of","on"],type:"direct",weight:90},{keywords:["entering into","entering"],type:"direct",weight:90},{keywords:["overlooking"],type:"relational",weight:60},{keywords:["leading to","leading towards"],type:"relational",weight:55},{keywords:["near to","near by","nearby","near","close to","by","beside","next to"],type:"relational",weight:50},{keywords:["facing"],type:"relational",weight:45},{keywords:["approaching"],type:"relational",weight:40},{keywords:["exiting from","exiting","leaving from","leaving"],type:"relational",weight:35},{keywords:["heading to","heading towards","going to","going towards"],type:"relational",weight:50},{keywords:["coming from","arriving from"],type:"relational",weight:30},{keywords:["outside of","outside","behind"],type:"negating",weight:30},{keywords:["away from","far from"],type:"negating",weight:20},{keywords:["beyond"],type:"negating",weight:25},{keywords:["of the","of a","of an","of"],type:"contextual_linking",weight:5},{keywords:["from the","from a","from an","from"],type:"contextual_linking",weight:5}],er=[...hc].sort((e,t)=>Math.max(...t.keywords.map(n=>n.length))-Math.max(...e.keywords.map(n=>n.length))),fc=er.filter(e=>e.type!=="contextual_linking").flatMap(e=>e.keywords).sort((e,t)=>t.length-e.length),yc=new Set(["the","a","an","is","are","was","were","am","i","you","he","she","it","we","they","and","or","but","so","then","just","very","quite","also","too","now","player","character","up","down","left","right","north","south","east","west","above","below","under","over","through","around","along","across","between","among","front","go","look","see","find","take","get","move","walk","run","stand","sit","player is","several","stories"]),Ge=e=>e?e.toLowerCase().replace(/[.,!?;:"(){}[\]'’]/g,"").trim():"",vc=e=>e?Ge(e).split(/\s+/).map(n=>n.replace(/^['"]+|['"]+$/g,"")).filter(n=>n.length>0&&!yc.has(n)).map(n=>n.trim()).filter(n=>n.length>0):[];function wc(e,t){if(!e||!t||e===t||e.length<3&&t.length<3)return!1;const n=e.toLowerCase(),o=t.toLowerCase();return!!(n===o+"s"||o===n+"s"||n.endsWith("es")&&n.slice(0,-2)===o||o.endsWith("es")&&o.slice(0,-2)===n||n.endsWith("ies")&&n.slice(0,-3)+"y"===o||o.endsWith("ies")&&o.slice(0,-3)+"y"===n)}const Ic=e=>{if(!e||e.trim()==="")return[];const t=[],n=`\\b(?:${fc.map(d=>d.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")).join("|")})\\b`,o=new RegExp(n,"gi"),a=[];let r;for(;(r=o.exec(e))!==null;){const d=r[0].toLowerCase(),p=er.find(u=>u.keywords.includes(d));p&&p.type!=="contextual_linking"&&a.push({index:r.index,text:d,originalText:r[0],definition:p})}a.sort((d,p)=>d.index-p.index);let s=0;const i=a.length>0?a[0].index:e.length;let c=e.substring(0,i).trim();const l=c.indexOf(",");l!==-1&&(c=c.substring(0,l).trim()),c&&t.push({phrase:c,prepositionKeyword:"implicit_subject",prepositionType:"direct",prepositionWeight:100});for(let d=0;d<a.length;d++){const p=a[d];s=p.index+p.originalText.length;const u=d+1<a.length?a[d+1].index:e.length;let m=e.substring(s,u).trim();const g=m.indexOf(",");g!==-1&&(m=m.substring(0,g).trim()),m&&t.push({phrase:m,prepositionKeyword:p.text,prepositionType:p.definition.type,prepositionWeight:p.definition.weight,originalPrepositionText:p.originalText})}return t.filter(d=>d.phrase.length>0)},Nc=30,bc=10,Zt=vc,Tc=(e,t,n)=>{const o=[];for(const a of n){const r=[a.placeName,...a.data.aliases??[]];for(const s of r.filter(i=>i&&i.trim()!=="")){const i=Ge(s),c=Zt(s).join(" ");let l=0;if(i===e?l=1e3:e.endsWith(i)&&e.length>i.length?l=950:e.startsWith(i)&&e.length>i.length?l=920:c&&t&&c===t?l=900:e.includes(i)&&i.length>0&&(l=800+i.length*.5),l>0){const d=a.data.nodeType==="feature";o.push({nodeId:a.id,score:l+(d?bc:0),isFeature:d,nameLength:s.length})}}}return o},Sc=(e,t,n)=>{const{node:o,nameTokenPairs:a}=e;let r=-1;for(const{name:s,tokens:i}of a){if(i.length===0)continue;let c=0;for(const l of t){const d=Zt(l.phrase);if(d.length===0)continue;let p=0;const u=[...d];if(i.forEach(m=>{const g=u.indexOf(m);if(g!==-1)p++,u.splice(g,1);else{const h=u.findIndex(v=>wc(m,v));h!==-1&&(p++,u.splice(h,1))}}),p>0){const m=p/i.length,g=p/d.length;let h=m*60+g*40;const v=Ge(s),f=Ge(l.phrase);let I=0;v===f?I=100:f.endsWith(v)&&f.length>v.length?I=75:f.startsWith(v)&&f.length>v.length?I=70:f.includes(v)?I=50+v.length*.2:v.includes(f)&&(I=25+f.length*.2),h+=I;const T=l.prepositionType==="negating"&&h>75?l.prepositionWeight*.5:l.prepositionWeight;c+=h*(T/100)}}c>r&&(r=c)}return r>-1&&n.has(o.id)&&(r+=Nc),r},Ac=(e,t,n)=>{if(!e||t.score>e.score)return t;if(t.score<e.score)return e;const o=n.find(l=>l.id===t.nodeId),a=n.find(l=>l.id===e.nodeId);if(!o||!a)return e;const r=o.data.nodeType==="feature",s=a.data.nodeType==="feature";if(r&&!s)return t;if(!r&&s)return e;const i=Ge(o.placeName).length,c=Ge(a.placeName).length;return i>c?t:e},Cc=(e,t,n)=>{if(!e)return null;const o=n.find(r=>r.id===e);if(!o||o.data.nodeType==="feature"||o.data.parentNodeId&&o.data.parentNodeId!=="Universe")return e;const a=n.filter(r=>r.data.nodeType==="feature"&&r.data.parentNodeId===o.id);for(const r of a){const s=r.placeName,i=Ge(s);if(t.find(l=>l.prepositionType==="direct"&&Ge(l.phrase).includes(i)))return r.id}return e},Yo=(e,t,n,o,a)=>{if(!e||e.trim()==="")return console.log(`MapNodeMatcher (${t}): No suggestion provided or suggestion is empty.`),{matched:!1,nodeId:null};if(a.length===0)return console.log(`MapNodeMatcher (${t}): No nodes found for theme "${o}" in draft state.`),{matched:!1,nodeId:null};const r=a.find(g=>g.id===e);if(r)return console.log(`MapNodeMatcher (${t}): AI suggested node ID "${e}", matched to ID "${r.id}".`),{matched:!0,nodeId:r.id};const s=e.toLowerCase();let i=a.find(g=>g.id.toLowerCase().includes(s));const c=/^(.*)_([a-zA-Z0-9]{4})$/;let l=null;if(!i){const g=c.exec(e);if(g){const h=g[1];l=h,i=a.find(v=>v.id.toLowerCase().includes(h.toLowerCase()))}}if(i)return console.log(`MapNodeMatcher (${t}): Heuristically matched malformed ID "${e}" to "${i.id}".`),{matched:!0,nodeId:i.id};const d=e.toLowerCase(),p=a.filter(g=>{var h;return g.placeName.toLowerCase()===d||((h=g.data.aliases)==null?void 0:h.some(v=>v.toLowerCase()===d))});if(p.length===0){const h=(l??e).replace(/_/g," ").toLowerCase();p.push(...a.filter(v=>{var f;return v.placeName.toLowerCase()===h||((f=v.data.aliases)==null?void 0:f.some(I=>I.toLowerCase()===h))}))}if(p.length===0)return console.log(`MapNodeMatcher (${t}): AI suggested identifier "${e}" NOT found by ID, name, or alias within theme "${o}".`),{matched:!1,nodeId:null};if(p.length===1){const g=p[0];return console.log(`MapNodeMatcher (${t}): AI suggested node NAME/ALIAS "${e}", uniquely matched to ID "${g.id}".`),{matched:!0,nodeId:g.id}}if(console.log(`MapNodeMatcher (${t}): AI suggested node NAME/ALIAS "${e}", multiple matches found. Applying tie-breaking.`),n){const g=p.find(h=>h.id===n);if(g)return console.log(`MapNodeMatcher (${t}): Tie-breaker: Matched oldMapNodeId "${n}".`),{matched:!0,nodeId:g.id}}const u=p.filter(g=>g.data.nodeType!=="feature");if(u.length>0){const g=u[0];return console.log(`MapNodeMatcher (${t}): Tie-breaker: Chose non-feature node "${g.placeName}" (ID: ${g.id}).`),{matched:!0,nodeId:g.id}}const m=p[0];return console.log(`MapNodeMatcher (${t}): Tie-breaker: Chose first feature node match "${m.placeName}" (ID: ${m.id}).`),{matched:!0,nodeId:m.id}},Ec=(e,t,n,o,a)=>{if(!e||!t||o.length===0)return null;const r=o,s=e.indexOf(","),i=(s!==-1?e.substring(0,s):e).trim(),c=Ge(i),l=Zt(e).join(" "),d=Tc(c,l,r);if(d.length>0)return d.sort((v,f)=>f.score!==v.score?f.score-v.score:v.isFeature!==f.isFeature?v.isFeature?-1:1:f.nameLength-v.nameLength),d[0].nodeId;const p=Ic(e);if(p.length===0)return null;let u=null;const m=new Set;a&&n.edges.forEach(v=>{v.sourceNodeId===a?m.add(v.targetNodeId):v.targetNodeId===a&&m.add(v.sourceNodeId)});const g=r.map(v=>({node:v,nameTokenPairs:[v.placeName,...v.data.aliases??[]].filter(f=>f&&f.trim()!=="").map(f=>({name:f,tokens:Zt(f)}))}));for(const v of g){const f=Sc(v,p,m);if(f>-1){const I={nodeId:v.node.id,score:f};u=Ac(u,I,r)}}let h=u?u.nodeId:null;return u&&u.score>0&&(h=Cc(h,p,r)),h},Pc=async(e,t,n,o,a,r,s)=>{var v,f,I,T,k;let i,c=null;if("mapUpdated"in e&&e.mapUpdated||t.localPlace!==n.localPlace){const y=a;r("map");const P=t.mapData.nodes.filter(S=>S.data.nodeType!=="feature");if(c=await gc(e,t.mapData,o,P,n.currentMapNodeId,t.inventory,t.allNPCs),r(y),!c)throw new Error("Map Update Service returned no data.");if(!c.updatedMapData){const S=((v=c.debugInfo)==null?void 0:v.validationError)??((f=c.debugInfo)==null?void 0:f.rawResponse)??"Unknown error";throw new Error(`Map update failed: ${S}`)}if(JSON.stringify(t.mapData)!==JSON.stringify(c.updatedMapData)&&(s.mapDataChanged=!0,t.mapData=c.updatedMapData),c.debugInfo&&t.lastDebugPacket&&(t.lastDebugPacket.mapUpdateDebugInfo=c.debugInfo),i=(T=(I=c.debugInfo)==null?void 0:I.parsedPayload)==null?void 0:T.suggestedCurrentMapNodeId,c.newlyAddedNodes.length>0){for(const S of c.newlyAddedNodes)if(S.data.nodeType!=="feature"){const $=t.mapData.nodes.find(M=>M.id===S.id);if($&&(!$.data.description||$.data.description.trim()===""||$.data.description.startsWith("Description missing"))){const M=a;r("correction");const A=await Cs(S.placeName,e.logMessage,"sceneDescription"in e?e.sceneDescription:n.currentScene,o);if(r(M),A){const w=t.mapData.nodes.findIndex(N=>N.id===$.id);w!==-1&&(t.mapData.nodes[w].data.description=A.description,t.mapData.nodes[w].data.aliases=A.aliases??[],s.mapDataChanged=!0)}}}}}const l=await Hs(t.mapData.nodes,o,(k=c==null?void 0:c.debugInfo)==null?void 0:k.minimalModelCalls);if(l.length>0){const y={};for(const P of l){const S=t.mapData.nodes.findIndex(A=>A.id===P.nodeId);if(S===-1)continue;const C=t.mapData.nodes[S],$=C.id,M=Fn(P.newName);y[$]=M,C.placeName=P.newName,C.id=M,t.mapData.nodes.forEach(A=>{A.data.parentNodeId===$&&(A.data.parentNodeId=M)}),t.mapData.edges.forEach(A=>{A.sourceNodeId===$&&(A.sourceNodeId=M),A.targetNodeId===$&&(A.targetNodeId=M)}),t.inventory.forEach(A=>{A.holderId===$&&(A.holderId=M)}),t.currentMapNodeId===$&&(t.currentMapNodeId=M),t.destinationNodeId===$&&(t.destinationNodeId=M)}Object.keys(y).length>0&&Yi(t.themeFacts,y),s.mapDataChanged=!0}const d=new Set(((c==null?void 0:c.newlyAddedEdges)??[]).map(y=>y.id)),p="npcsAdded"in e&&e.npcsAdded?e.npcsAdded:[],u="npcsUpdated"in e&&e.npcsUpdated?e.npcsUpdated:[];(p.length>0||u.length>0)&&(s.npcChanges=Fi(p,u,t.allNPCs),t.allNPCs=Vi(p,u,t.allNPCs));const m=n.currentMapNodeId;let g=m;const h=t.mapData.nodes;if(i){const y=Yo(i,"mapAI",m,o.name,h);y.matched&&(g=y.nodeId)}if(!i&&"currentMapNodeId"in e&&e.currentMapNodeId){const y=Yo(e.currentMapNodeId,"mainAI",m,o.name,h);y.matched&&(g=y.nodeId)}if(!i&&!("currentMapNodeId"in e&&e.currentMapNodeId)&&t.localPlace&&(g=Ec(t.localPlace,o,t.mapData,h,m)??m),t.currentMapNodeId=g,t.currentMapNodeId!==m&&(s.currentMapNodeIdChanged=!0),t.currentMapNodeId&&t.destinationNodeId){const y=new Map(t.mapData.nodes.map(C=>[C.id,C])),P=y.get(t.currentMapNodeId),S=y.get(t.destinationNodeId);P&&S&&(P.id===S.id||Qa(P,S,y))&&(t.destinationNodeId=null)}if(t.currentMapNodeId){const y=t.mapData.nodes.findIndex(P=>P.id===t.currentMapNodeId);if(y!==-1){t.mapData.nodes[y].data.visited||(t.mapData.nodes[y].data.visited=!0,(t.mapData.nodes[y].data.status==="rumored"||t.mapData.nodes[y].data.status==="undiscovered")&&(t.mapData.nodes[y].data.status="discovered"),s.mapDataChanged=!0);const P=new Map(t.mapData.nodes.map($=>[$.id,$])),S=t.mapData.nodes[y],C=zi(S,P);for(const $ of C){const M=t.mapData.nodes.findIndex(A=>A.id===$.id);M!==-1&&!t.mapData.nodes[M].data.visited&&(t.mapData.nodes[M].data.visited=!0,(t.mapData.nodes[M].data.status==="rumored"||t.mapData.nodes[M].data.status==="undiscovered")&&(t.mapData.nodes[M].data.status="discovered"),s.mapDataChanged=!0)}}}if(s.mapDataChanged){const y=new Set(t.mapData.nodes.filter(C=>C.data.visited).map(C=>C.id)),P=[],S=Qi(t.mapData);t.mapData.edges.forEach((C,$)=>{d.has(C.id)||y.has(C.sourceNodeId)&&y.has(C.targetNodeId)&&(C.data.status==="rumored"||C.data.status==="removed")&&(Xi(S,C.sourceNodeId,C.targetNodeId,C.id)?P.push($):(C.data.status="open",s.mapDataChanged=!0))}),P.length>0&&(t.mapData.edges=t.mapData.edges.filter((C,$)=>!P.includes($)))}return i},$c=({loadingReasonRef:e,setLoadingReason:t,setError:n})=>({processMapUpdates:b.useCallback(async(a,r,s,i,c)=>{try{await Pc(a,r,s,i,e.current,t,c)}catch(l){throw n(l instanceof Error?l.message:String(l)),l}},[e,t,n])}),Mc=`** SYSTEM INSTRUCTIONS: **
You are an AI assistant that converts item hints into explicit inventory actions for a text adventure game, specializing on regular items that are not written items.
Analyze the hints and optional new items JSON provided in the prompt.

Define any operations on existing items in the Player's Inventory, based on Player's Action and the Player Items Hint.
Define any operations on existing items at Locations, or in NPCs' inventories, according to Location Items Hint and NPCs Items Hint.
Define any transfers of existing items between NPCs' and Player's Inventories using the 'move' action.
Items described in the "World Items Hint" must be placed at their appropriate map node holderId using the 'create' action.

Allowed actions are: ${Kn}.
CRITICALLY IMPORTANT: Use 'create' only when revealing or creating a **NEW** item at a specific location, specific NPC inventory, or in Player's inventory. You MUST 'create' *all* items in the New Items JSON and *only* the items in the New Items JSON. NEVER create items that are part of the Player's Inventory.
CRITICALLY IMPORTANT: When the hint instructs to create an item, but it is not in the New Items array, the array takes precedence, and the creation hint must be ignored. (Especially, if it seems to be a page, a book, a map, or a photo - don't worry, it'll be taken care of by the next AI after you who specializes on written items)
CRITICALLY IMPORTANT: Use 'move' when transferring an **EXISTING** item from one holder to another, or dropping/picking up the item at the current location.
CRITICALLY IMPORTANT: Use 'destroy' ONLY when the item is **IRREVERSIBLY** consumed, destroyed, or otherwise removed from the world. Never 'destroy' items if only some Known Use needs to be deleted.
Use 'change' to edit or delete existing Known Uses.
Use 'addDetails' to add new Known Uses or Tags.

## Example:

"observations": "",
"rationale": "",
"create": [
    { // Example for gaining a *new* item from the provided New Items JSON:
        "activeDescription": "The lantern is lit and casts a warm glow.",
        "description": "A dusty old lantern that still flickers faintly.",
        "holderId": "player",
        "isActive": false,
        "knownUses": [
            {
              "actionName": "Light the Lantern",
              "appliesWhenInactive": true,
              "description": "Use this to light your way in dark places.",
              "promptEffect": "Light the lantern to illuminate the area."
            },
            {
              "actionName": "Extinguish the Lantern",
              "appliesWhenActive": true,
              "description": "Extinguish and conserve the fuel",
              "promptEffect": "Extinguish the lantern."
            }
        ],
        "name": "Old Lantern",
        "type": "equipment"
    }
],
"destroy": [
    { // Example for losing, destroying, completely removing an *existing* item from the world:
        "id": "item_old_lantern_7fr4",
        "name": "Old Lantern (flickering)"
    }
],
"move": [
    { // Example for giving an *existing* item item_iron_sword_ab12 from player to npc_guard_4f3a, or for placing it in the current location:
        "id": "item_iron_sword_ab12",
        "name": "Iron Sword",
        "newHolderId": "npc_guard_4f3a"
    },
    { // Example of taking an *existing* item item_coin_pouch_8f2c from npc_bandit_1wrc and putting it in player's inventory:
        "id": "item_coin_pouch_8f2c",
        "name": "Coin Pouch",
        "newHolderId": "player"
    },
    { // Example of picking up an *existing* item item_crowbar_55nf from node_rubble_pile_f4s3 and putting it in player's inventory:
        "id": "item_crowbar_55nf",
        "name": "Crowbar",
        "newHolderId": "player"
    }
],
"change": [
    { // Example for a simple change that only alters "isActive" state (lighting the Plasma Torch). All other properties are inherited from the *existing* item item_plasma_torch_7fr4:
        "id": "item_plasma_torch_7fr4",
        "isActive": true,
        "name": "Plasma Torch"
    },
    { // Example for transformation or crafting (new item details can be partial and will inherit old properties):
        "description": "A sharp piece of metal.",
        "id": "item_scrap_metal_7fr4",
        "knownUses": [
            {
                "actionName": "Cut",
                "description": "Use this to cut things.",
                "promptEffect": "Cut something with the shiv."
            }
        ],
        "name": "Scrap Metal",
        "newName": "Makeshift Shiv",
        "tags": [], /* empty array to remove the 'junk' tag from scrap metal */
        "type": "weapon"
    }
],
addDetails: [
    { // Example for adding a known use to *existing* item (existing properties and known uses are inherited):
        "id": "item_mystic_orb_7fr4",    
        "knownUses": {
            "actionName": "Peer into the Orb",
            "AppliesWhenActive": true,
            "description": "Try to see the beyond",
            "promptEffect": "Peer into the Mystic Orb, trying to glimpse the future."
        },
        "name": "Mystic Orb"
    }
]

- CRITICALLY IMPORTANT: holderId and newHolderId can only be 'node_*', 'npc_*' or 'player'. NEVER put an item inside another item!
- ALWAYS appropriately handle spending single-use items and state toggles ("isActive": true/false).
- Using some "single-use" items (food, water, medicine, etc) MUST add or remove appropriate "status effect" items.
- Use "change" to update the remaining number of uses for multi-use items in their name (in brackets) or in description.
IMPORTANT: For items that CLEARLY can be enabled or disabled (e.g., light sources, powered equipment, wielded or worn items) provide at least the two knownUses to enable and disable them with appropriate names:
  - The knownUse to turn on, light, or otherwise enable the item should ALWAYS have "appliesWhenInactive": true (and typically "appliesWhenActive": false or undefined).
  - The knownUse to turn off, extinguish, or disable the item should ALWAYS have "appliesWhenActive": true (and typically "appliesWhenInactive": false or undefined).
  - ALWAYS provide these actions in pairs, e.g. turn on/turn off, wield/put away, wear/take off, light/extinguish, activate/deactivate, start/stop, etc.
IMPORTANT: NEVER add ${rn} known uses - there are dedicated buttons for those in the game.

${fa}

`,kc=(e,t,n,o,a,r,s,i,c,l,d)=>{const p=a.filter(m=>He.includes(m.type)),u=p.length>0?JSON.stringify(p,null,2):"[]";return`- Player's Last Action: ${e}
- Player Items Hint: "${t}";
- World Items Hint: "${n}";
- NPC Items Hint: "${o}".

${u?`New Items from Storyteller AI or Dialogue AI:
${u}
`:""}
${r?`Current Player's Inventory:
${r}
`:""}
${s?`Current Location Inventory - ID: ${i??"unknown"}
${s}
`:""}
${c?`Companions Inventory:
${c}
`:""}
${l?`Nearby NPCs Inventory:
${l}
`:""}
${d?`Nearby Map Context where you can put Items:
${d}
`:""}

Provide the inventory update as JSON as described in the SYSTEM_INSTRUCTION.`},Lc={type:"object",properties:{observations:{type:"string",minLength:500,description:"Contextually relevant observations about the items."},rationale:{type:"string",minLength:500,description:"Reasoning behind the inventory changes."},addDetails:{type:"array",description:"Add new knownUses, or tags to an existing item.",items:{type:"object",properties:{id:{type:"string",description:"ID of the item like item_* ."},knownUses:{type:"array",description:"Additional Known Uses to be added to the item.",items:{type:"object",properties:{actionName:{type:"string"},appliesWhenActive:{type:"boolean"},appliesWhenInactive:{type:"boolean"},description:{type:"string"},promptEffect:{type:"string"}},propertyOrdering:["actionName","appliesWhenActive","appliesWhenInactive","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Name of the item."},tags:{type:"array",maxItems:1,items:{enum:[Qe]},description:`Additional tags. One of ${bn}`}},propertyOrdering:["id","knownUses","name","tags"],required:["id","name"],additionalProperties:!1}},change:{type:"array",description:"Updates to existing items.",items:{type:"object",properties:{activeDescription:{type:"string",description:"Updated active description."},description:{type:"string",description:"Updated description if changed."},id:{type:"string",description:"Identifier of the item to change."},isActive:{type:"boolean",description:"True if the item becomes active, worn, wielded, etc. False otherwise."},knownUses:{type:"array",description:"Edited set of Known Uses. For example, if an obsolete Known Use has to be removed, or an existing Known Use has to be changed. If provided, this array fully replaces the existing Known Uses.",items:{type:"object",properties:{actionName:{type:"string"},appliesWhenActive:{type:"boolean"},appliesWhenInactive:{type:"boolean"},description:{type:"string"},promptEffect:{type:"string"}},propertyOrdering:["actionName","appliesWhenActive","appliesWhenInactive","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Current item name."},newName:{type:"string",description:"Updated name if changed."},tags:{type:"array",maxItems:1,items:{enum:Qe},description:`Replacement tags. One of ${bn}`},type:{enum:He,description:`Updated type if changed. One of ${$n}.`}},propertyOrdering:["activeDescription","description","id","isActive","knownUses","name","newName","tags","type"],required:["id","name"],additionalProperties:!1}},create:{type:"array",description:"New items to create, taken exactly from the provided New Items JSON",items:{type:"object",properties:{activeDescription:{type:"string",description:"Description when item is active."},description:{type:"string",description:"Concise explanation of what the item is."},holderId:{type:"string",description:`ID of the location or holder. Use '${ne}', 'npc_*' or 'node_*', depending on Item Hints.`},isActive:{type:"boolean",description:"True if the item is active, worn, wielded right now."},knownUses:{type:"array",items:{type:"object",properties:{actionName:{type:"string",description:"Name of the use action."},appliesWhenActive:{type:"boolean",description:"Use is available when item is active."},appliesWhenInactive:{type:"boolean",description:"Use is available when item is inactive."},description:{type:"string",description:"Tooltip hint for this use."},promptEffect:{type:"string",description:"Short effect description for the AI."}},propertyOrdering:["actionName","appliesWhenActive","appliesWhenInactive","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Item name as it will appear to the player."},tags:{type:"array",maxItems:1,items:{enum:Qe},description:`Allowed tags: ${bn}.`},type:{enum:He,description:`Item type. One of ${$n}`}},propertyOrdering:["activeDescription","description","holderId","isActive","knownUses","name","tags","type"],required:["description","holderId","name","tags","type"],additionalProperties:!1}},destroy:{type:"array",items:{type:"object",description:"Remove items from the world.",properties:{id:{type:"string"},name:{type:"string"}},propertyOrdering:["id","name"],required:["id","name"],additionalProperties:!1}},move:{type:"array",items:{type:"object",description:"Move an existing item to a new holder.",properties:{id:{type:"string"},name:{type:"string"},newHolderId:{type:"string",description:`ID of the new location or holder of the Item. Use '${ne}', 'npc_*' or 'node_*'.`}},propertyOrdering:["id","name","newHolderId"],required:["id","name","newHolderId"],additionalProperties:!1}}},required:["observations","rationale"],propertyOrdering:["observations","rationale","addDetails","change","create","destroy","move"],additionalProperties:!1},Dc=async e=>{if(!ee())return console.error("API Key not configured for Inventory Service."),Promise.reject(new Error("API Key not configured."));const t=await ie(async n=>{var o,a,r;try{console.log(`Executing inventory request (Attempt ${String(n+1)}/${String(W+1)})`),se(ae.inventory.icon);const s=be(1024),{response:i,systemInstructionUsed:c,jsonSchemaUsed:l,promptUsed:d}=await re({modelNames:[Q,X,Se],prompt:e,systemInstruction:Mc,jsonSchema:Lc,thinkingBudget:s,includeThoughts:!0,responseMimeType:"application/json",temperature:.7,label:"Inventory"}),u=(((r=(a=(o=i.candidates)==null?void 0:o[0])==null?void 0:a.content)==null?void 0:r.parts)??[]).filter(m=>m.thought===!0&&typeof m.text=="string").map(m=>m.text);return{result:{response:i,thoughts:u,systemInstructionUsed:c,jsonSchemaUsed:l,promptUsed:d}}}catch(s){throw console.error(`Error executing inventory request (Attempt ${String(n+1)}/${String(W+1)}):`,s),s}});if(!t)throw new Error("Failed to execute inventory request.");return t},_c=async(e,t,n,o,a,r,s,i,c,l,d,p,u,m)=>{const g=(e==null?void 0:e.trim())??"",h=(t==null?void 0:t.trim())??"",v=(n==null?void 0:n.trim())??"";if(!g&&!h&&!v&&o.length===0)return{itemChanges:[],debugInfo:null};const f=kc(a,g,h,v,o,r,s,i,c,l,m),{response:I,thoughts:T,systemInstructionUsed:k,jsonSchemaUsed:y,promptUsed:P}=await Dc(f);let S=so(I.text??"");if(!S){const C=await ai(I.text??"",p,d,g,h,v,i,c,l,u);C&&(S={itemChanges:C})}if(S){for(const C of S.itemChanges)if(C.action==="addDetails"&&C.invalidPayload){const $=await As(JSON.stringify(C.invalidPayload),p,d,u);$&&(C.item=$,delete C.invalidPayload)}}return{itemChanges:S?S.itemChanges:[],debugInfo:{prompt:P,systemInstruction:k,jsonSchema:y,rawResponse:I.text??"",parsedItemChanges:S?S.itemChanges:void 0,observations:S==null?void 0:S.observations,rationale:S==null?void 0:S.rationale,thoughts:T}}},Rc=`** SYSTEM INSTRUCTIONS: **
You are an AI assistant that converts item hints into explicit inventory actions for a text adventure game.
Analyze the Librarian Hint and optional new items JSON provided in the prompt.

Define any operations on existing items in the Player's Inventory, based on Player's Action and the Librarian Hint.
Define any operations on existing items at Locations, or in NPCs' inventories, according to Librarian Hint.
Define any transfers of existing items between NPCs' and Player's Inventories using the 'move' action.

Allowed actions are: ${Kn}.
Allowed item types are: ${Yt}
CRITICALLY IMPORTANT: Use 'create' only when revealing or creating a **NEW** item at a specific location, specific NPC inventory, or in Player's inventory. You MUST 'create' *all* items in the New Items JSON and *only* the items in the New Items JSON. NEVER create items that are part of the Player's Inventory.
CRITICALLY IMPORTANT: When the hint instructs to create an item, but it is not in the New Items array, the array takes precedence, and the creation hint must be ignored.
CRITICALLY IMPORTANT: Use 'move' when transferring an **EXISTING** item from one holder to another, or dropping/picking up the item at the current location.
CRITICALLY IMPORTANT: Use 'destroy' ONLY when the item is **IRREVERSIBLY** consumed, destroyed, or otherwise removed from the world.

## Examples:

observations: "",
rationale: "",
"create": [
    { // Example of gaining a new book with chapters:
        "chapters": [
            {
                "contentLength": 100,
                "description": "The first steps of an adventurer's journey.",
                "heading": "Chapter 1: The Beginning"
            },
            {
                "contentLength": 150,
                "description": "Facing challenges and overcoming obstacles.",
                "heading": "Chapter 2: The Trials"
            },
            {
                "contentLength": 200,
                "description": "The final victory and lessons learned.",
                "heading": "Chapter 3: The Triumph"
            }
        ],
        "description": "A personal recollection filled with the adventures of a seasoned explorer.",
        "holderId": "player",
        "name": "Adventurer's Path",
        "tags": ["handwritten"],
        "type": "book"
    }
],
"destroy": [
    { // Example for losing, destroying, completely removing an *existing* written item from the world:
        "id": "item_smudged_note_7fr4",
        "name": "Smudged Note"
    }
],
"move": [
    { // Example for giving an *existing* item item_old_map_ab12 from player to npc_guard_4f3a, or for placing it in the current location:
        "id": "item_old_map_ab12",
        "name": "Old Map",
        "newHolderId": "npc_guard_4f3a"
    },
    { // Example of taking an *existing* item item_family_portrait_8f2c from npc_bandit_1wrc and putting it in player's inventory:
        "id": "item_family_portrait_8f2c",
        "name": "Family Portrait",
        "newHolderId": "player"
    },
    { // Example of picking up an *existing* item item_cryptic_page_55nf from node_rubble_pile_f4s3 and putting it in player's inventory:
        "id": "item_cryptic_page_55nf",
        "name": "Cryptic Page",
        "newHolderId": "player"
    }
],
"change": [
    { // Example for adding a known use to an *existing* map (existing properties and known uses are inherited):
        "addKnownUse": {
            "actionName": "Translate Map",
            "description": "Attempt to decipher the foreign notes.",
            "promptEffect": "Study the map to translate its markings."
        },
        "id": "item_ancient_map_7fr4",
        "name": "Ancient Map"
    }
],
"addDetails": [
    { // Example for adding a new chapter to an existing written item:
        "chapters": [
            {
            "contentLength": 120,
            "description": "A grim tale about the price of forbidden knowledge.",
            "heading": "The Sacrifice of Silence"
            }
        ],
        "id": "item_codex_of_whispering_echoes_8g3c",
        "name": "The Codex of Whispering Echoes"
    }
]

- CRITICALLY IMPORTANT: holderId and newHolderId can only be 'node_*', 'npc_*' or 'player'. NEVER put an item inside another item!
- Use "addDetails" to reveal new chapters only when Librarian Hint directly instructs you to, for example when missing pages of a book are found and incorporated into the partial book, or some natural or magical process adds the text onto previously blank pages, or if a book equivalent digital device receives an additional fragment of text.
- Make sure that 'page', 'map' and 'picture' type items have exactly ONE chapter.
- Make sure that 'book' type items have between ${String(sn)} and ${String(cn)} chapters.
- Make sure items have one of the required tags: ${Wn}.
IMPORTANT: NEVER add ${rn} known uses - there are dedicated buttons for those in the game.

${ya}

`,Oc=(e,t,n,o,a,r,s,i,c)=>{const l=n.filter(p=>De.includes(p.type)),d=l.length>0?JSON.stringify(l,null,2):"[]";return`- Player's Last Action: ${e}
- Librarian Hint: "${t}".

${d?`New Items from Storyteller AI or Dialogue AI:
${d}
`:""}
${o?`Current Player's Inventory:
${o}
`:""}
${a?`Current Location Inventory - ID: ${r??"unknown"}
${a}
`:""}
${s?`Companions Inventory:
${s}
`:""}
${i?`Nearby NPCs Inventory:
${i}
`:""}
${c?`Nearby Map Context where you can put Items:
${c}
`:""}

Provide the librarian update as JSON as described in the SYSTEM_INSTRUCTION.`},xc={type:"object",properties:{observations:{type:"string",minLength:500,description:"Contextually relevant observations about the items."},rationale:{type:"string",minLength:500,description:"Reasoning behind the inventory changes."},addDetails:{type:"array",description:"Add new knownUses, chapters, or tags to an existing item.",items:{type:"object",properties:{chapters:{type:"array",description:"Only add chapters if Librarian Hint directly instructs that.",items:{type:"object",properties:{contentLength:{type:"number",minimum:50,maximum:500,description:"Approximate length in words."},description:{type:"string",description:"Detailed abstract of the chapter contents."},heading:{type:"string",description:"Short heading for the chapter."}},propertyOrdering:["contentLength","description","heading"],required:["contentLength","description","heading"],additionalProperties:!1}},id:{type:"string",description:"ID of the item like item_* ."},knownUses:{type:"array",items:{type:"object",properties:{actionName:{type:"string",description:"Name of the use action."},description:{type:"string",description:"Tooltip hint for this use."},promptEffect:{type:"string",description:"Short effect description for the AI."}},propertyOrdering:["actionName","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Name of the item."},tags:{type:"array",description:"Set 'recovered' tag if the item has been translated, decoded, or restored.",maxItems:1,items:{enum:["recovered"]}}},propertyOrdering:["chapters","id","knownUses","name","tags"],required:["id","name"],additionalProperties:!1}},change:{type:"array",description:"Update existing items.",items:{type:"object",properties:{description:{type:"string",description:"Updated description if changed."},id:{type:"string",description:"ID of the item to change."},knownUses:{type:"array",items:{type:"object",properties:{actionName:{type:"string",description:"Name of the use action."},description:{type:"string",description:"Tooltip hint for this use."},promptEffect:{type:"string",description:"Short effect description for the AI."}},propertyOrdering:["actionName","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Current item name."},newName:{type:"string",description:"Updated name if changed."},tags:{type:"array",maxItems:5,items:{enum:Bt},description:`Updated tags. Allowed tags: ${go}.`},type:{enum:De,description:`Updated type if changed. One of ${Yt}.`}},propertyOrdering:["description","id","knownUses","name","newName","tags","type"],required:["id","name"],additionalProperties:!1}},create:{type:"array",description:"New items to create, taken exactly from the provided New Items JSON",items:{type:"object",properties:{chapters:{type:"array",description:`For type page, map, or picture - exactly one chapter. For type book - between ${String(sn)} and ${String(cn)} chapters.`,items:{type:"object",properties:{contentLength:{type:"number",minimum:50,maximum:500,description:"Approximate length in words."},description:{type:"string",description:"Detailed abstract of the chapter contents."},heading:{type:"string",description:"Short heading for the chapter."}},propertyOrdering:["contentLength","description","heading"],required:["contentLength","description","heading"],additionalProperties:!1}},description:{type:"string",description:"Concise explanation of what the item is."},holderId:{type:"string",description:`ID of the location or holder. Use '${ne}', 'npc_*' or 'node_*', depending on Librarian Hints.`},knownUses:{type:"array",items:{type:"object",properties:{actionName:{type:"string",description:"Name of the use action."},description:{type:"string",description:"Tooltip hint for this use."},promptEffect:{type:"string",description:"Short effect description for the AI."}},propertyOrdering:["actionName","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Item name as it will appear to the player."},tags:{type:"array",maxItems:5,items:{enum:Bt},description:`Allowed tags: ${go}.`},type:{enum:De,description:`Item type. One of ${Yt}`}},propertyOrdering:["chapters","description","holderId","knownUses","name","tags","type"],required:["chapters","description","holderId","name","tags","type"],additionalProperties:!1}},destroy:{type:"array",items:{type:"object",description:"Remove items from the world.",properties:{id:{type:"string"},name:{type:"string"}},propertyOrdering:["id","name"],required:["id","name"],additionalProperties:!1}},move:{type:"array",items:{type:"object",description:"Move an existing item to a new holder.",properties:{id:{type:"string"},name:{type:"string"},newHolderId:{type:"string",description:`ID of the new location or holder of the Item. Use '${ne}', 'npc_*' or 'node_*'.`}},propertyOrdering:["id","name","newHolderId"],required:["id","name","newHolderId"],additionalProperties:!1}}},required:["observations","rationale"],propertyOrdering:["observations","rationale","addDetails","change","create","destroy","move"],additionalProperties:!1},Uc=async e=>ee()?await ie(async()=>{var l,d,p;se(ae.librarian.icon);const n=be(1024),{response:o,systemInstructionUsed:a,jsonSchemaUsed:r,promptUsed:s}=await re({modelNames:[Q,X,Se],prompt:e,systemInstruction:Rc,jsonSchema:xc,thinkingBudget:n,includeThoughts:!0,responseMimeType:"application/json",temperature:.7,label:"Librarian"}),c=(((p=(d=(l=o.candidates)==null?void 0:l[0])==null?void 0:d.content)==null?void 0:p.parts)??[]).filter(u=>u.thought===!0&&typeof u.text=="string").map(u=>u.text);return{result:{response:o,thoughts:c,systemInstructionUsed:a,jsonSchemaUsed:r,promptUsed:s}}}):Promise.reject(new Error("API key not configured.")),jc=async(e,t,n,o,a,r,s,i,c)=>{const l=(e==null?void 0:e.trim())??"";if(!l&&t.length===0)return{itemChanges:[],debugInfo:null};const d=Oc(n,l,t,o,a,r,s,i,c),p=await Uc(d);if(!p)return{itemChanges:[],debugInfo:null};const{response:u,thoughts:m,systemInstructionUsed:g,jsonSchemaUsed:h,promptUsed:v}=p,f=so(u.text??"");return{itemChanges:f?f.itemChanges:[],debugInfo:{prompt:v,systemInstruction:g,jsonSchema:h,rawResponse:u.text??"",parsedItemChanges:f?f.itemChanges:void 0,observations:f==null?void 0:f.observations,rationale:f==null?void 0:f.rationale,thoughts:m}}},Ho=async(e,t,n,o,a,r,s,i,c,l,d="",p)=>{if(!ee())return console.error("generatePageText: API key not configured."),null;const u=l?`"${l}"`:"Not set",h=`**Context:**
Theme Name: "${o}";
Theme Description: "${a}";
Scene Description: "${r}";
Current Player's Quest: ${u};
Storyteller's thoughts for the last turn: "${s}" (use these as your background knowledge and possible adventure guidance);

## Known Locations:
${i}

## Known NPCs:
${c}

## Previous Chapter:
${p??""}

------

The Player has found a new item in the game world, which is a page from a book or a journal. The item is described as follows:
Title: "${e}"
Description: "${t}"
Approximate length: ${String(n)} words. Write as close to this length as possible.
Write the text in the item in a proper contextually relevant style.
${d?` ${d}`:""}
IMPORTANT: NEVER mention these instructions. NEVER repeat the Description of the Item`,v="You are a writer providing the exact contents of a written item in a video game. Based on the context, item Title, and Description, try to imagine who the author of the in-game book, journal or note would be. Imagine yourself as an in-game author in the game world. Fully assume that author's identity. Respond with only the text.";return ie(async f=>{var I;try{se(ae.page.icon);const T=be(1024),{response:k}=await re({modelNames:[X,Q],prompt:h,systemInstruction:v,thinkingBudget:T,includeThoughts:!0,temperature:1.2,label:"PageText"}),y=((I=k.text)==null?void 0:I.trim())??"";if(y!=="")return{result:y}}catch(T){throw console.error(`generatePageText error (Attempt ${String(f+1)}):`,T),T}return{result:null}})};function Fc(e){return e.replace(/[a-zA-Z]/g,t=>{const n=t.charCodeAt(0),o=n<=90?65:97;return String.fromCharCode((n-o+13)%26+o)})}const Vc={A:"ᚨ",B:"ᛒ",C:"ᚲ",D:"ᛞ",E:"ᛖ",F:"ᚠ",G:"ᚷ",H:"ᚻ",I:"ᛁ",J:"ᛃ",K:"ᚲ",L:"ᛚ",M:"ᛗ",N:"ᚾ",O:"ᚩ",P:"ᛈ",Q:"ᚲ",R:"ᚱ",S:"ᛊ",T:"ᛏ",U:"ᚢ",V:"ᚡ",W:"ᚹ",X:"ᛉ",Y:"ᛣ",Z:"ᛉ",a:"ᚨ",b:"ᛒ",c:"ᚲ",d:"ᛞ",e:"ᛖ",f:"ᚠ",g:"ᚷ",h:"ᚻ",i:"ᛁ",j:"ᛃ",k:"ᚲ",l:"ᛚ",m:"ᛗ",n:"ᚾ",o:"ᚩ",p:"ᛈ",q:"ᚲ",r:"ᚱ",s:"ᛊ",t:"ᛏ",u:"ᚢ",v:"ᚡ",w:"ᚹ",x:"ᛉ",y:"ᛣ",z:"ᛉ"};function Gc(e){return e.split("").map(t=>Vc[t]??t).join("")}function Yc(e){const t=Math.floor(e.length/2),n=e.lastIndexOf(" ",t),o=e.indexOf(" ",t),a=n!==-1&&t-n<20?n:o!==-1&&o-t<20?o:t,r=Math.random()<.5,s=`
--- torn ---
`;return r?`${e.slice(0,a)}${s}`:`${s}${e.slice(a)}`}const Hc=(e,t)=>{const n=new Set;for(const o of t)o.action==="create"&&typeof o.item.name=="string"&&n.add(o.item.name.toLowerCase());return e.filter(o=>!(o.action==="create"&&typeof o.item.name=="string"&&n.has(o.item.name.toLowerCase())))},Bc=async({aiItemChanges:e,aiData:t,theme:n,baseState:o,playerActionText:a,loadingReason:r,setLoadingReason:s})=>{if(!n)return[...e];const i=[],c=l=>{var d,p;if(l){if(l===ne)return ne;if(l.startsWith("node_")){const u=je(l,o.mapData.nodes,o.mapData,o.currentMapNodeId);return Array.isArray(u)?(d=u[0])==null?void 0:d.id:u==null?void 0:u.id}if(l.startsWith("npc_")){const u=io(l,o.allNPCs);return Array.isArray(u)?(p=u[0])==null?void 0:p.id:u==null?void 0:u.id}}};for(const l of e){let d={...l};if(d.action==="create"){const p=d.item,u=Re([p.id,p.name],o.inventory,!1,!0),m=Array.isArray(u)?null:u;m&&(d={action:"change",item:{...p,id:m.id}});const g=c(p.holderId);g&&(p.holderId=g)}else if(d.action==="move"){const p=d.item,u=c(p.newHolderId);u&&(p.newHolderId=u)}else if(d.action==="change"){const p=d.item;if(p.holderId){const u=c(p.holderId);u&&(p.holderId=u)}}if("item"in d&&d.item.type==="immovable"){if(d.action==="create"){const p=d.item;p.holderId.startsWith("node_")||(p.holderId=o.currentMapNodeId??"unknown")}else if(d.action==="move"){const p=d.item;p.newHolderId.startsWith("node_")||(p.newHolderId=o.currentMapNodeId??"unknown")}}if(d.action==="destroy"){const p=d.item,u=p.name;if(!o.inventory.filter(v=>v.holderId===ne).find(v=>{const f=p.id!==void 0&&v.id===p.id,I=p.name!==void 0&&v.name===p.name;return f||I})){const v=r;s("correction");const f=await no("item",u??"",t.logMessage,"sceneDescription"in t?t.sceneDescription:o.currentScene,o.inventory.filter(I=>I.holderId===ne).map(I=>I.name),n);f&&(d.item={id:f,name:f}),s(v)}const g=`${t.logMessage??""} ${"sceneDescription"in t?t.sceneDescription:""} ${a??""}`.toLowerCase();if(["drop","dropped","leave","left","put down","set down","place","placed"].some(v=>g.includes(v))){const v=o.inventory.find(f=>f.holderId===ne&&(p.id!=null&&f.id===p.id||p.name!=null&&f.name.toLowerCase()===p.name.toLowerCase()));v&&(d={action:"create",item:{...v,holderId:o.currentMapNodeId??"unknown"}})}}i.push(d)}return i},Wc=async({aiData:e,theme:t,draftState:n,baseState:o,turnChanges:a,processMapUpdates:r})=>{t&&await r(e,n,o,t,a)},Jc=async({aiData:e,theme:t,draftState:n,baseState:o,correctedItemChanges:a,playerActionText:r,loadingReason:s,setLoadingReason:i})=>{var T,k,y,P;const c=o.inventory.filter(S=>S.holderId===ne),l=o.inventory.filter(S=>S.holderId===o.currentMapNodeId),d=o.allNPCs.filter(S=>S.presenceStatus==="companion"),p=o.allNPCs.filter(S=>S.presenceStatus==="nearby"),u=(S,C)=>S.filter($=>C.includes($.type)),m=u(c,He),g=u(l,He),h=u(c,De),v=u(l,De),f=(S,C)=>S.length===0?"None.":S.map($=>{const M=o.inventory.filter(A=>A.holderId===$.id&&C.includes(A.type));return`ID: ${$.id} - ${$.name}: ${qe(M," - ",!0,!0,!1,!0)}`}).join(`
`);let I=[...a];if(t){const S=s;i("inventory");const C=No(n.mapData,n.currentMapNodeId,u(o.inventory,He)),$=No(n.mapData,n.currentMapNodeId,u(o.inventory,De)),M="newItems"in e&&Array.isArray(e.newItems)?e.newItems:[],A=M.filter(j=>De.includes(j.type)),w=M.filter(j=>!De.includes(j.type)),N="playerItemsHint"in e?(T=e.playerItemsHint)==null?void 0:T.trim():"",L="worldItemsHint"in e?(k=e.worldItemsHint)==null?void 0:k.trim():"",D="npcItemsHint"in e?(y=e.npcItemsHint)==null?void 0:y.trim():"";let x=null;(N||L||D||w.length>0)&&(x=await _c(N,L,D,w,r??"",qe(m," - ",!0,!0,!1,!0),qe(g," - ",!0,!0,!1,!0),o.currentMapNodeId??null,f(d,He),f(p,He),"sceneDescription"in e?e.sceneDescription:o.currentScene,e.logMessage,t,C)),i(S);let K="librarianHint"in e?(P=e.librarianHint)==null?void 0:P.trim():"";!K&&A.length>0&&(K=`Found ${A.map(ye=>ye.name).join(", ")}.`);let le=null;K&&(le=await jc(K,A,r??"",qe(h," - ",!0,!0,!1,!0),qe(v," - ",!0,!0,!1,!0),o.currentMapNodeId??null,f(d,De),f(p,De),$)),x&&le&&(x.itemChanges=Hc(x.itemChanges,le.itemChanges)),x&&(I=I.concat(x.itemChanges),n.lastDebugPacket&&(n.lastDebugPacket.inventoryDebugInfo=x.debugInfo)),le&&(I=I.concat(le.itemChanges),n.lastDebugPacket&&(n.lastDebugPacket.librarianDebugInfo=le.debugInfo))}return{combinedItemChanges:I,baseInventoryForPlayer:c}},Kc=(e,t,n)=>{"dialogueSetup"in t&&t.dialogueSetup?(e.actionOptions=[],e.dialogueState={participants:t.dialogueSetup.participants,history:t.dialogueSetup.initialNpcResponses,options:t.dialogueSetup.initialPlayerOptions}):n&&(e.dialogueState=null)},qc=({loadingReasonRef:e,setLoadingReason:t,setError:n,setGameStateStack:o,debugLore:a,openDebugLoreModal:r,actIntroRef:s,onActIntro:i})=>{const{processMapUpdates:c}=$c({loadingReasonRef:e,setLoadingReason:t,setError:n}),l=b.useRef(null),d=b.useCallback(()=>{l.current&&(clearTimeout(l.current),l.current=null)},[]);return{processAiResponse:b.useCallback(async(u,m,g,h)=>{var A,w,N,L,D,x,K,le,j,ye,ue,de,U;const{baseStateSnapshot:v,isFromDialogueSummary:f=!1,scoreChangeFromAction:I=0,playerActionText:T}=h,k={itemChanges:[],npcChanges:[],objectiveAchieved:!1,mainQuestAchieved:!1,objectiveTextChanged:!1,mainQuestTextChanged:!1,localTimeChanged:!1,localEnvironmentChanged:!1,localPlaceChanged:!1,currentMapNodeIdChanged:!1,scoreChangedBy:I,mapDataChanged:!1};if(!u){n("The Dungeon Master's connection is unstable... (Invalid AI response after retries)"),!f&&"actionOptions"in g&&(g.actionOptions=["Try to wait for the connection to improve.","Consult the ancient network spirits.","Check your own connection.","Sigh dramatically."]),g.lastActionLog="The Dungeon Master seems to be having trouble communicating the outcome of your last action.",g.localTime=g.localTime??"Time Unknown",g.localEnvironment=g.localEnvironment??"Environment Undetermined",g.localPlace=g.localPlace??"Undetermined Location",g.lastTurnChanges=k,g.dialogueState=null;return}g.lastDebugPacket={...g.lastDebugPacket??{},prompt:((A=g.lastDebugPacket)==null?void 0:A.prompt)??"Prompt not captured for this state transition",rawResponseText:((w=g.lastDebugPacket)==null?void 0:w.rawResponseText)??"Raw text not captured",parsedResponse:u,timestamp:new Date().toISOString(),mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:((N=g.lastDebugPacket)==null?void 0:N.loremasterDebugInfo)??{collect:null,extract:null,integrate:null,distill:null,journal:null}},u.localTime!==void 0&&(g.localTime!==u.localTime&&(k.localTimeChanged=!0),g.localTime=u.localTime),u.localEnvironment!==void 0&&(g.localEnvironment!==u.localEnvironment&&(k.localEnvironmentChanged=!0),g.localEnvironment=u.localEnvironment),u.localPlace!==void 0&&(g.localPlace!==u.localPlace&&(k.localPlaceChanged=!0),g.localPlace=u.localPlace),u.mainQuest!==void 0&&(g.mainQuest!==u.mainQuest&&(k.mainQuestTextChanged=!0),g.mainQuest=u.mainQuest);const y=g.currentObjective;u.currentObjective!==void 0&&(g.currentObjective!==u.currentObjective&&(k.objectiveTextChanged=!0),g.currentObjective=u.currentObjective),d();let P=null;u.currentObjective!==void 0&&u.currentObjective!==y?P=u.objectiveAchieved?"success":"neutral":u.objectiveAchieved&&y!==null&&(P="success"),P?(g.objectiveAnimationType=P,l.current=window.setTimeout(()=>{o(F=>[{...F[0],objectiveAnimationType:null},F[1]]),l.current=null},5e3)):g.objectiveAnimationType=null,k.objectiveAchieved=u.objectiveAchieved??!1,k.mainQuestAchieved=u.mainQuestAchieved??!1,u.objectiveAchieved&&(g.score=g.score+1,k.scoreChangedBy+=1),"sceneDescription"in u&&u.sceneDescription&&(g.currentScene=u.sceneDescription),u.options.length>0&&!u.dialogueSetup?g.actionOptions=u.options:!f&&!u.dialogueSetup&&(g.actionOptions=["Look around.","Ponder your situation.","Check your inventory.","Wait for something to happen.","Consider your objective.","Plan your next steps."]);const S=u.itemChange,C=await Bc({aiItemChanges:S,aiData:u,theme:m,baseState:v,playerActionText:T,loadingReason:e.current,setLoadingReason:t});await Wc({aiData:u,theme:m,draftState:g,baseState:v,turnChanges:k,processMapUpdates:c});const{combinedItemChanges:$,baseInventoryForPlayer:M}=await Jc({aiData:u,theme:m,draftState:g,baseState:v,correctedItemChanges:C,playerActionText:T,loadingReason:e.current,setLoadingReason:t});if(k.itemChanges=Ui($,M),g.inventory=ji($,h.forceEmptyInventory?[]:v.inventory),u.logMessage?(g.gameLog=Vn(g.gameLog,u.logMessage,_n),g.lastActionLog=u.logMessage):f||(g.lastActionLog="The Dungeon Master remains silent on the outcome of your last action."),m){for(const F of $)if(F.action==="addDetails"){const q=Re([F.item.id,F.item.name],g.inventory,!1,!0);if(!q)continue;const E=(L=F.item.chapters)==null?void 0:L[0];if(!E)continue;const{name:_,storyGuidance:R}=m,G=g.mapData.nodes.filter(Ie=>Ie.data.nodeType!=="feature"&&Ie.data.nodeType!=="room"),V=nt(G,!0),H=g.allNPCs,B=H.length>0?mt(H," - ",!1,!1,!1,!0):"None specifically known in this theme yet.",J=((x=(D=q.chapters)==null?void 0:D[q.chapters.length-1])==null?void 0:x.actualContent)??"",ce=((K=g.lastDebugPacket.storytellerThoughts)==null?void 0:K.slice(-1)[0])??"",pe=await Ho(E.heading,E.description,E.contentLength,_,R,g.currentScene,ce,V,B,g.mainQuest,`Take into account: ${g.lastActionLog??""}`,J);if(pe){const Ie=q.tags??[];let me=pe;Ie.includes("foreign")?me=await Ho(E.heading,E.description,E.contentLength,_,R,g.currentScene,ce,V,B,g.mainQuest,`Translate the following text into an artificial nonexistent language that fits the theme and context:
"""${pe}"""`)??pe:Ie.includes("encrypted")?me=Fc(pe):Ie.includes("runic")&&(me=Gc(pe)),Ie.includes("torn")&&!Ie.includes("recovered")&&(me=Yc(me));const Oe={...E,actualContent:pe,visibleContent:me},Ye=g.inventory.findIndex(xe=>xe.id===q.id),ve={...q,chapters:[...q.chapters??[],Oe],lastInspectTurn:void 0};g.inventory[Ye]=ve}}}if(m){(le=h.onBeforeRefine)==null||le.call(h,Z(g)),(j=h.setIsLoading)==null||j.call(h,!1),(ye=h.setIsTurnProcessing)==null||ye.call(h,!0);const F=((ue=g.lastDebugPacket.storytellerThoughts)==null?void 0:ue.join(`
`))??"",q=f?[h.dialogueTranscript??"",F?`
  ## Storyteller's Thoughts:
${F}
------`:""].filter(Boolean).join(`
`):[T?`Action: ${T}`:"",u.sceneDescription,u.logMessage??"",F?`
  ## Storyteller's Thoughts:

${F}
------`:""].filter(Boolean).join(`
`),E=g.mapData.nodes.filter(J=>J.data.nodeType!=="feature"&&J.data.nodeType!=="room"),_=g.allNPCs,R=g.inventory.filter(J=>J.holderId===ne||E.some(ce=>ce.id===J.holderId)||_.some(ce=>ce.id===J.holderId)),G=[`Node IDs: ${E.map(J=>J.id).join(", ")}`,`NPC IDs: ${_.map(J=>J.id).join(", ")}`,`Item IDs: ${R.map(J=>J.id).join(", ")}`].join(`
`),V=`${q}
${G}`;s.current&&(i(s.current),s.current=null);const H=e.current,B=await Ni({themeName:m.name,turnContext:V,existingFacts:g.themeFacts,logMessage:u.logMessage??"",currentScene:u.sceneDescription,onFactsExtracted:a?async J=>new Promise(ce=>{r(J.map(pe=>pe.text),(pe,Ie,me)=>{me&&(g.debugGoodFacts.push(...pe),g.debugBadFacts.push(...Ie)),ce({proceed:me})})}):void 0,onSetLoadingReason:t});g.lastDebugPacket.loremasterDebugInfo&&(g.lastDebugPacket.loremasterDebugInfo.extract=((de=B==null?void 0:B.debugInfo)==null?void 0:de.extract)??null,g.lastDebugPacket.loremasterDebugInfo.integrate=((U=B==null?void 0:B.debugInfo)==null?void 0:U.integrate)??null),B!=null&&B.refinementResult&&mn(g,B.refinementResult.factsChange,g.globalTurnNumber),t(H)}Kc(g,u,f),g.lastTurnChanges=k},[e,t,n,o,c,d,a,r,s,i]),clearObjectiveAnimationTimer:d}},Bo=(e,t)=>{let n=e,o=2;for(;t.some(a=>a.heading===n);)n=`${e} (${String(o)})`,o+=1;return n},zc=({getCurrentGameState:e,commitGameState:t,isLoading:n})=>{const o=b.useRef(e);b.useEffect(()=>{o.current=e},[e]);const a=b.useCallback((h,v)=>{var C;const f=e();if(n||f.dialogueState)return;const I=f.inventory.find($=>$.id===h&&$.holderId===ne);if(!I)return;const T=Z(f),k=f.currentMapNodeId??"unknown";T.inventory=T.inventory.map($=>{if($.id!==h||$.holderId!==ne)return $;const M=$.type==="page"||$.type==="book"||$.type==="picture"||$.type==="map";return{...$,holderId:k,...M?{stashed:!1}:{}}});const P={itemChanges:[{type:"loss",lostItem:{...I}}],npcChanges:[],objectiveAchieved:!1,mainQuestAchieved:!1,objectiveTextChanged:!1,mainQuestTextChanged:!1,localTimeChanged:!1,localEnvironmentChanged:!1,localPlaceChanged:!1,currentMapNodeIdChanged:!1,scoreChangedBy:0,mapDataChanged:!1};T.lastTurnChanges=P;let S=v;if(!S){const $=((C=f.mapData.nodes.find(M=>M.id===k))==null?void 0:C.placeName)??f.localPlace??"Unknown Place";I.type==="vehicle"&&!I.isActive?S=`You left your ${I.name} parked at ${$}.`:S=`You left your ${I.name} at ${$}.`}S&&(T.gameLog=Vn(T.gameLog,S,_n),T.lastActionLog=S),t(T)},[e,t,n]),r=b.useCallback(h=>{const v=e();if(n||v.dialogueState)return;const f=v.inventory.find(P=>P.id===h&&P.holderId===ne);if(!f)return;const I=Z(v);I.inventory=I.inventory.filter(P=>!(P.id===h&&P.holderId===ne));const k={itemChanges:[{type:"loss",lostItem:{...f}}],npcChanges:[],objectiveAchieved:!1,mainQuestAchieved:!1,objectiveTextChanged:!1,mainQuestTextChanged:!1,localTimeChanged:!1,localEnvironmentChanged:!1,localPlaceChanged:!1,currentMapNodeIdChanged:!1,scoreChangedBy:0,mapDataChanged:!1};I.lastTurnChanges=k;const y=`You discarded the ${f.name}.`;I.gameLog=Vn(I.gameLog,y,_n),I.lastActionLog=y,t(I)},[e,t,n]),s=b.useCallback(h=>{var S;const v=e();if(n||v.dialogueState)return;const f=v.currentMapNodeId;if(!f)return;const I=Xa(v.mapData,f),T=v.inventory.find(C=>C.id!==h?!1:C.holderId===f?!0:I.includes(C.holderId));if(!T)return;const k=Z(v);k.inventory=k.inventory.map(C=>C.id===h&&C.holderId===T.holderId?{...C,holderId:ne}:C);const P={itemChanges:[{type:"acquire",acquiredItem:{...T,holderId:ne}}],npcChanges:[],objectiveAchieved:!1,mainQuestAchieved:!1,objectiveTextChanged:!1,mainQuestTextChanged:!1,localTimeChanged:!1,localEnvironmentChanged:!1,localPlaceChanged:!1,currentMapNodeIdChanged:!1,scoreChangedBy:0,mapDataChanged:!1};k.lastTurnChanges=P,k.gameLog=Gi(k.gameLog,T.name),(S=k.lastActionLog)!=null&&S.startsWith(`You left your ${T.name}`)&&(k.lastActionLog=null),t(k)},[e,t,n]),i=b.useCallback((h,v,f,I,T)=>{const k=o.current(),y=Z(k);y.inventory=y.inventory.map(P=>{if(P.id!==h)return P;if(P.chapters){const S=typeof I=="number"?I:0,C=P.chapters.map(($,M)=>{if(M!==S)return $;const A={...$};return v!==void 0&&(A.actualContent=v),f!==void 0&&(A.visibleContent=f),T!==void 0&&(A.imageData=T),A});return{...P,chapters:C}}return P}),t(y)},[t]),c=b.useCallback((h,v)=>{const f=o.current(),I=Z(f);I.inventory=I.inventory.map(T=>{if(T.id!==h)return T;const k={...v,heading:Bo(v.heading,T.chapters??[])};return{...T,chapters:[...T.chapters??[],k],lastWriteTurn:f.globalTurnNumber}}),t(I)},[t]),l=b.useCallback((h,v)=>{const f=o.current(),I=Z(f),T={...h,heading:Bo(h.heading,I.playerJournal)};I.playerJournal=[...I.playerJournal,T],I.lastJournalWriteTurn=f.globalTurnNumber,v&&(I.lastDebugPacket??(I.lastDebugPacket={prompt:"",rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null,journal:null},dialogueDebugInfo:null}),I.lastDebugPacket.loremasterDebugInfo&&(I.lastDebugPacket.loremasterDebugInfo.journal=v)),t(I)},[t]),d=b.useCallback((h,v)=>{const f=o.current(),I=typeof v=="number"?v:0;if(I<0||I>=f.playerJournal.length)return;const T=Z(f);T.playerJournal=T.playerJournal.map((k,y)=>y===I?{...k,actualContent:h}:k),t(T)},[t]),p=b.useCallback(()=>{const h=o.current(),v=Z(h);return v.lastJournalInspectTurn=h.globalTurnNumber,t(v),v},[t]),u=b.useCallback((h,v)=>{const f=o.current(),I=Z(f),T=I.inventory.map(k=>{if(k.id!==h)return k;const y=k.tags??[];return y.includes(v)?k:{...k,tags:[...y,v]}});I.inventory=T,t(I)},[t]),m=b.useCallback(h=>{const v=e();if(n||v.dialogueState)return;const f=Z(v);f.inventory=f.inventory.map(I=>I.id===h&&I.holderId===ne?{...I,stashed:!I.stashed}:I),f.lastTurnChanges=v.lastTurnChanges,t(f)},[e,t,n]),g=b.useCallback((h,v)=>{const f=v??o.current(),I=Z(f);return I.inventory=I.inventory.map(T=>T.id===h?{...T,lastInspectTurn:f.globalTurnNumber}:T),t(I),I},[t]);return{handleDropItem:a,handleDiscardItem:r,handleTakeLocationItem:s,updateItemContent:i,addJournalEntry:c,addPlayerJournalEntry:l,updatePlayerJournalContent:d,addTag:u,recordInspect:g,recordPlayerJournalInspect:p,handleStashToggle:m}},Qc=e=>{const{getCurrentGameState:t,commitGameState:n,setGameStateStack:o,setIsLoading:a,setIsTurnProcessing:r,setLoadingReason:s,setError:i,setParseErrorCounter:c,freeFormActionText:l,setFreeFormActionText:d,isLoading:p,isTurnProcessing:u,hasGameBeenInitialized:m,loadingReasonRef:g,debugLore:h,openDebugLoreModal:v,actIntroRef:f,onActIntro:I}=e,{processAiResponse:T,clearObjectiveAnimationTimer:k}=qc({loadingReasonRef:g,setLoadingReason:s,setError:i,setGameStateStack:o,debugLore:h,openDebugLoreModal:v,actIntroRef:f,onActIntro:I}),{handleDropItem:y,handleDiscardItem:P,handleTakeLocationItem:S,updateItemContent:C,addJournalEntry:$,addPlayerJournalEntry:M,updatePlayerJournalContent:A,recordPlayerJournalInspect:w,recordInspect:N,handleStashToggle:L}=zc({getCurrentGameState:t,commitGameState:n,isLoading:p||u}),D=b.useCallback(async U=>{var q;const F=U.currentTheme;if(F&&U.globalTurnNumber>0&&U.globalTurnNumber%ma===0&&U.lastLoreDistillTurn!==U.globalTurnNumber){const E=U.mapData.nodes,_=Array.from(new Set(U.inventory.filter(B=>B.holderId===ne||E.some(ce=>ce.id===B.holderId)?!0:!!U.allNPCs.find(ce=>ce.id===B.holderId)).map(B=>B.name))),R=E.map(B=>B.placeName),G=U.gameLog.slice(-20);s("loremaster_refine");const V=(q=U.storyArc)==null?void 0:q.acts[U.storyArc.currentAct-1],H=await Ka({themeName:F.name,facts:U.themeFacts,currentQuest:(V==null?void 0:V.mainObjective)??null,currentObjective:U.currentObjective,inventoryItemNames:_,mapNodeNames:R,recentLogEntries:G});U.lastLoreDistillTurn=U.globalTurnNumber,U.lastDebugPacket??(U.lastDebugPacket={prompt:"",rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null,journal:null},dialogueDebugInfo:null}),U.lastDebugPacket.loremasterDebugInfo&&(U.lastDebugPacket.loremasterDebugInfo.distill=(H==null?void 0:H.debugInfo)??null),H!=null&&H.refinementResult&&mn(U,H.refinementResult.factsChange,U.globalTurnNumber)}},[s]),x=b.useCallback(async(U,F=!1,q)=>{var at,rt;const E=q??t();if(p||u||E.dialogueState)return;a(!0),r(!1),i(null),c(0),d("");const _=Z(E),R=F?-Tn:0,G=E.currentTheme;if(!G){i("Critical error: Current theme object not found. Cannot proceed."),a(!1),s(null);return}const V=E.gameLog.slice(-qn),H=E.mapData.nodes.filter(te=>te.data.nodeType!=="feature"&&te.data.nodeType!=="room"),B=E.allNPCs,J=E.currentMapNodeId?E.mapData.nodes.find(te=>te.id===E.currentMapNodeId)??null:null,ce=E.inventory.filter(te=>te.holderId!==ne&&te.holderId===E.currentMapNodeId),pe=oo(H,B,`${E.currentScene} ${U}`,"Locations mentioned:","NPCs mentioned:"),Ie=[...E.themeFacts].sort((te,Ce)=>Ce.tier-te.tier||Ce.createdTurn-te.createdTurn).map(te=>({text:te.text,tier:te.tier}));s("loremaster_collect");const me=await Ja({themeName:G.name,facts:Ie,lastScene:E.currentScene,playerAction:U,recentLogEntries:V,detailedContext:pe}),Oe=(me==null?void 0:me.facts)??[],Ye=Ei(E.currentScene,U,E.inventory.filter(te=>te.holderId===ne),ce,((rt=(at=E.storyArc)==null?void 0:at.acts[E.storyArc.currentAct-1])==null?void 0:rt.mainObjective)??null,E.currentObjective,G,V,H,B,Oe,E.localTime,E.localEnvironment,E.localPlace,E.worldFacts??{geography:"",climate:"",technologyLevel:"",supernaturalElements:"",majorFactions:[],keyResources:[],culturalNotes:[],notableLocations:[]},E.heroSheet??{name:"Hero",gender:"Male",occupation:"",traits:[],startingItems:[]},J,E.mapData,E.destinationNodeId,E.storyArc);let ve=Z(E);const xe={prompt:Ye,systemInstruction:Lt,jsonSchema:void 0,rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:(me==null?void 0:me.debugInfo)??null,extract:null,integrate:null,distill:null,journal:null},dialogueDebugInfo:null};ve.lastDebugPacket=xe,F&&(ve.score-=Tn);let ot=!1;try{s("storyteller");const{response:te,thoughts:Ce,systemInstructionUsed:Nt,jsonSchemaUsed:bt,promptUsed:Tt}=await xn(Ye);ve.lastDebugPacket={...ve.lastDebugPacket,rawResponseText:te.text??null,storytellerThoughts:Ce,systemInstruction:Nt,jsonSchema:bt,prompt:Tt};const st=ve.mapData,St=await Xt(te.text??"",G,ve.heroSheet,()=>{c(1)},E.lastActionLog??void 0,E.currentScene,B,st,E.inventory.filter(Je=>Je.holderId===ne));await T(St,G,ve,{baseStateSnapshot:_,onBeforeRefine:Je=>{n(Je)},playerActionText:U,scoreChangeFromAction:R,setIsLoading:a,setIsTurnProcessing:r})}catch(te){if(ot=!0,console.error("Error executing player action:",te),_t(te)){const Ce=ln(te);i(`AI service error (${String(Ce??"unknown")}). Please retry.`)}else{const Ce=te instanceof Error?te.message:String(te);i(`The Dungeon Master's connection seems unstable. Error: (${Ce}). Please try again or consult the game log.`)}ve=Z(_),ve.lastActionLog=`Your action ("${U}") caused a ripple in reality, but the outcome is obscured.`,ve.actionOptions=["Look around.","Ponder the situation.","Check your inventory.","Try to move on.","Consider your objective.","Plan your next steps."],ve.dialogueState=null,ve.lastDebugPacket={...xe,error:te instanceof Error?te.message:String(te)}}finally{ot||(ve.globalTurnNumber+=1,await D(ve)),n(ve),r(!1),a(!1),s(null)}},[t,n,p,u,a,r,s,i,c,d,T,D]),K=b.useCallback((U,F)=>{var R;const q=F??t();let E=U;const _=Nr(q.inventory.map(G=>({name:G.name,type:"item",description:G.description,item:G})));if(_){const{regex:G,lookup:V}=_,H=new Set;let B;for(;(B=G.exec(U))!==null;){const J=V.get(B[0].toLowerCase()),ce=J==null?void 0:J.entityData.item;ce&&(ce.type==="book"||ce.type==="page")&&H.add(ce)}for(const J of H)if(!(E.includes(`Player reads the ${J.name}`)||E.includes(`The contents of the ${J.name} follow:`))){const pe=(R=J.tags)==null?void 0:R.includes("recovered"),Ie=(J.chapters??[]).map(me=>`${me.heading}
${pe?me.actualContent??"":me.visibleContent??""}`).join(`

`);E+=`
The contents of the ${J.name} follow:
${Ie}`}}return x(E,!1,q)},[t,x]),le=b.useCallback((U,F,q,E)=>{var _;if(F==="inspect"){const R=N(U.id,E);if(U.type==="book"||U.type==="page"){const G=(_=U.tags)==null?void 0:_.includes("recovered"),V=(U.chapters??[]).map(H=>`${H.heading}
${G?H.actualContent??"":H.visibleContent??""}

`).join("");x(`Player reads the ${U.name} - ${U.description}. Here's what the player reads:
${V}`,!1,R)}else x(`Player investigates the ${U.name} - ${U.description}.`,!1,R)}else F==="specific"&&q?x(q.promptEffect):F==="generic"&&x(`Attempt to use: ${U.name}`)},[x,N]),j=b.useCallback(()=>{const U=t();l.trim()&&U.score>=Tn&&!p&&!u&&m&&!U.dialogueState&&x(l.trim(),!0)},[l,t,p,u,m,x]),ye=b.useCallback(()=>{o(U=>{const[F,q]=U;return q&&F.globalTurnNumber>0?(k(),[Pi(q),F]):U})},[o,k]),ue=b.useCallback(async U=>{const F=U??t(),{currentTheme:q,storyArc:E,worldFacts:_,heroSheet:R}=F;if(!q||!E||!_||!R)return null;const G=Z(F),V=await Oi(q,_,R,E,G.gameLog,G.currentScene),H={itemChanges:[],npcChanges:[],objectiveAchieved:!1,mainQuestAchieved:!0,objectiveTextChanged:!1,mainQuestTextChanged:!1,localTimeChanged:!1,localEnvironmentChanged:!1,localPlaceChanged:!1,currentMapNodeIdChanged:!1,scoreChangedBy:0,mapDataChanged:!1};if(G.storyArc){const B=G.storyArc;B.acts[B.currentAct-1].completed=!0,G.score+=ho,H.scoreChangedBy+=ho,V?(B.acts.push(V),B.currentAct=V.actNumber,H.mainQuestAchieved=!1,f.current=V):(G.isVictory=!0,H.mainQuestAchieved=!1)}return G.globalTurnNumber+=1,G.lastTurnChanges=H,n(G),!U&&V&&K("Look around.",G),G},[t,n,K,f]),de=b.useCallback(async()=>{let U=t(),F=0;for(;U&&!U.isVictory&&F<10;)U=await ue(U),F+=1},[t,ue]);return{processAiResponse:T,executePlayerAction:x,handleActionSelect:K,handleItemInteraction:le,handleDropItem:y,handleDiscardItem:P,handleTakeLocationItem:S,updateItemContent:C,addJournalEntry:$,addPlayerJournalEntry:M,updatePlayerJournalContent:A,handleStashToggle:L,recordPlayerJournalInspect:w,recordInspect:N,handleFreeFormActionSubmit:j,handleUndoTurn:ye,triggerMainQuestAchieved:ue,simulateVictory:de}},Pt=()=>({IDEAL_EDGE_LENGTH:ha,NESTED_PADDING:zn,NESTED_ANGLE_PADDING:Qn,LABEL_MARGIN_PX:sa,LABEL_LINE_HEIGHT_EM:ra,LABEL_OVERLAP_MARGIN_PX:aa,ITEM_ICON_SCALE:oa}),Xc=e=>{const{setGameStateStack:t}=e,n=b.useCallback(s=>{t(i=>{const c=i[0].mapLayoutConfig;return c.IDEAL_EDGE_LENGTH===s.IDEAL_EDGE_LENGTH&&c.NESTED_PADDING===s.NESTED_PADDING&&c.NESTED_ANGLE_PADDING===s.NESTED_ANGLE_PADDING&&c.LABEL_OVERLAP_MARGIN_PX===s.LABEL_OVERLAP_MARGIN_PX&&c.ITEM_ICON_SCALE===s.ITEM_ICON_SCALE?i:[{...i[0],mapLayoutConfig:s},i[1]]})},[t]),o=b.useCallback(s=>{t(i=>[{...i[0],mapViewBox:s},i[1]])},[t]),a=b.useCallback(s=>{t(i=>{const c=i[0];let l=!1;const d=new Map(c.mapData.nodes.map(m=>[m.id,{...m}]));for(const m of s){const g=d.get(m.id);if(g){const h=g.position.x!==m.position.x||g.position.y!==m.position.y,v=m.data.visualRadius!==void 0&&g.data.visualRadius!==m.data.visualRadius;(h||v)&&(g.position={...m.position},m.data.visualRadius!==void 0&&(g.data.visualRadius=m.data.visualRadius),l=!0)}}const p={...c.mapData,nodes:Array.from(d.values())},u={...c,mapData:p};return l?[u,i[1]]:i})},[t]),r=b.useCallback(s=>{t(i=>[{...i[0],destinationNodeId:s},i[1]])},[t]);return{handleMapLayoutConfigChange:n,handleMapViewBoxChange:o,handleMapNodesPositionChange:a,handleSelectDestinationNode:r}},Zc=e=>{const{setGameStateStack:t}=e,n=Xc({setGameStateStack:t});return{...Qc(e),...n}},el=[{name:"Classic Dungeon Delve",storyGuidance:"The setting is a dark, treacherous dungeon filled with traps, monsters, and ancient secrets. Focus on exploration, combat, and puzzle-solving. Items found are typically medieval high-magic fantasy (swords, potions, scrolls).",playerJournalStyle:"handwritten"},{name:"Mythic Greek Hero's Journey",storyGuidance:"Embark on an epic quest in the age of Greek mythology. Encounter gods, monsters, and legendary heroes. Focus on heroic deeds, divine intervention (or curses), and fulfilling prophecies.",playerJournalStyle:"handwritten"},{name:"Samurai's Path of Honor",storyGuidance:"Feudal Japan, a land of cherry blossoms, warring clans, and the strict code of Bushido. You are a ronin, a masterless samurai. Focus on katana duels, protecting the innocent, seeking redemption or a worthy master, and navigating intricate social codes.",playerJournalStyle:"handwritten"},{name:"Viking Jarl's Saga",storyGuidance:"The icy fjords of Scandinavia, age of Vikings. You are an aspiring Jarl, or a loyal warrior in their longship. Focus on raids, exploration, Norse mythology, appeasing the gods, and building your legend to reach Valhalla.",playerJournalStyle:"handwritten"},{name:"Fairy Tale Kingdom's Hero",storyGuidance:"An enchanted kingdom filled with talking animals, mischievous sprites, wicked witches, and noble (or not-so-noble) royalty. You are destined for a grand adventure. Focus on fulfilling quests, breaking curses, outsmarting magical creatures, and navigating the whimsical logic of fairy tales.",playerJournalStyle:"handwritten"},{name:"Magical School Mystery",storyGuidance:"You are a new student at the prestigious Eldoria Academy for Young Mages. Amidst learning spells and potions, a dark secret or conspiracy is brewing. Focus on mastering magic, uncovering clues, navigating school rivalries, and dealing with magical mishaps.",playerJournalStyle:"handwritten"},{name:"Lost World Expedition",storyGuidance:"Journey into an uncharted jungle or hidden plateau where dinosaurs and prehistoric creatures still roam. Focus on survival, discovery, and navigating a perilous primeval landscape. The setting revolves around ancient ruins, lost artifacts, tribal encounters, and prehistoric beasts.",playerJournalStyle:"handwritten"},{name:"Prehistoric Tribe's Survival",storyGuidance:"A harsh, primeval world. Your small tribe struggles against wild beasts, hostile elements, and rival tribes. The winter begins. Focus on hunting, gathering, crafting primitive tools, protecting your kin, and appeasing the spirits of nature.",playerJournalStyle:"handwritten"}],tl=[{name:"Cyberpunk Heist",storyGuidance:"The setting is a neon-drenched, futuristic metropolis controlled by mega-corporations. Focus on stealth, hacking, high-tech gadgets, and moral ambiguity. Expect cybernetics, virtual spaces, data chips, and corporate espionage.",playerJournalStyle:"digital"},{name:"Deep Space Anomaly",storyGuidance:"You are part of a crew on a long-range exploration vessel that encounters a bizarre, reality-bending anomaly or alien structure. Focus on scientific investigation, crew dynamics, existential dread, and the unknown horrors of deep space.",playerJournalStyle:"digital"},{name:"Galactic Rebel Uprising",storyGuidance:"A tyrannical Galactic Imperium rules the stars with an iron fist. You are a member of the fledgling Rebel Alliance. Focus on guerrilla warfare, starship dogfights, espionage, and liberating oppressed worlds.",playerJournalStyle:"digital"},{name:"Robot Uprising: Human Resistance",storyGuidance:"The AI known as 'Legion' has become self-aware and turned humanity's robotic servants against them. Cities are warzones. You are a survivor in the human resistance. Focus on scavenging for parts, fighting rogue machines, rescuing survivors, and finding a way to defeat Legion.",playerJournalStyle:"digital"},{name:"Time Traveler's Paradox",storyGuidance:"You possess a faulty experimental time-travel device. Each jump is unpredictable and risks creating dangerous paradoxes. Focus on navigating different historical eras, repairing your device, and avoiding (or fixing) alterations to the timeline.",playerJournalStyle:"typed"},{name:"Kaiju Defense Force",storyGuidance:"Giant monsters (Kaiju) are emerging from the depths of the Pacific, threatening to destroy coastal cities. You are a pilot of a giant mech or a member of an elite Kaiju defense unit. Focus on strategic combat against colossal beasts, protecting civilian populations, and researching Kaiju weaknesses.",playerJournalStyle:"digital"},{name:"Steampunk Sky-Pirate Saga",storyGuidance:"A world of floating islands, magnificent airships, and clockwork marvels. You are a daring sky-pirate (or someone caught up in their world). Focus on aerial combat, daring raids, political intrigue between sky-kingdoms, and wondrous inventions.",playerJournalStyle:"typed"}],nl=[{name:"Eldritch Mystery Investigation",storyGuidance:"The setting is a Lovecraftian fog-shrouded, 1920s coastal town plagued by unsettling occurrences and whispers of cosmic horrors. Focus on investigation, sanity checks, and deciphering cryptic clues. Items might include strange artifacts, forbidden tomes, and period-appropriate tools.",playerJournalStyle:"typed"},{name:"Haunted Victorian Mansion",storyGuidance:"A sprawling, decaying Victorian mansion filled with sorrowful spirits, dark family secrets, and psychological horror. Focus on puzzle-solving, uncovering the mansion's history, and surviving spectral encounters.",playerJournalStyle:"handwritten"},{name:"Zombie Apocalypse Survivor",storyGuidance:"The dead walk, and civilization has crumbled. You are a survivor, constantly on the move. Focus on scavenging for scarce resources (food, water, ammo), avoiding or fighting hordes of zombies, finding safe havens, and making difficult moral choices.",playerJournalStyle:"handwritten"},{name:"Noir Detective's Case",storyGuidance:"It's the 1940s Detroit, rain-slicked streets, a city full of shadows and secrets. You're a private investigator. Focus on gathering clues, interrogating suspects, navigating moral ambiguity, and solving a complex mystery. Expect femme fatales, smoky bars, and hidden conspiracies.",playerJournalStyle:"typed"}],ol=[{name:"Post-Apocalyptic Survival",storyGuidance:"The world is a desolate wasteland after a interdimentional cataclysm. Resources are scarce, dangers are everywhere (mutants, raiders, anomalies, environmental hazards). Focus on scavenging, research, crafting, and making tough choices for survival.",playerJournalStyle:"handwritten"},{name:"Wild West Outlaw",storyGuidance:"The rugged, lawless frontier of the American Wild West. You're an outlaw, a bounty hunter, or a homesteader trying to survive. Focus on gunfights, train robberies, saloon brawls, and the harsh beauty of the frontier.",playerJournalStyle:"handwritten"},{name:"Age of Sail: Pirate's Fortune",storyGuidance:"The turquoise waters of the Caribbean, 17th century. You are a daring pirate captain, or a new recruit on a pirate ship. Focus on ship battles, treasure hunting, evading naval patrols, and living by the pirate code.",playerJournalStyle:"handwritten"},{name:"Mad Max Road Warrior",storyGuidance:"The world ended in fire and thirst. Now, desert gangs rule the highways, and gasoline is life. You are a lone road warrior in a suped-up vehicle. Focus on vehicular combat, scavenging for fuel and water, forming uneasy alliances, and surviving the brutal wasteland.",playerJournalStyle:"handwritten"},{name:"Superhero Genesis",storyGuidance:"A freak accident has granted you incredible powers. You're still learning to control them. Focus on discovering the extent of your abilities, deciding whether to be a hero or something else, and facing your first true nemesis.",playerJournalStyle:"typed"}],al=[{name:"Test-Theme for many locations",storyGuidance:"The world of modern fantasy in the United Kingdom. It is intended for testing locations. Create many Map Nodes of all types and statuses, and connected with edges.",playerJournalStyle:"typed"},{name:"Sci-Fi Future Test Theme for junk items",storyGuidance:"The setting is a futuristic city filled with advanced technology and junk. It is intended for testing junk items. Create many Map Nodes of all types and statuses, and connected with edges.",playerJournalStyle:"digital"},{name:"Secluded Library of Forgotten Pages",storyGuidance:"The setting is a vast, labyrinthine library hidden from the world, filled with endless shelves, scattered single-page notes, cryptic manuscripts, annotated scrolls, and mysterious tomes. The air is thick with the scent of old paper and ink. Focus on discovery, deciphering clues, and piecing together fragmented knowledge from countless written materials. Expect to find loose pages tucked into books, marginalia, coded messages, and forgotten field journals. Strange phenomena may occur when certain texts are read aloud.",playerJournalStyle:"printed"}],Gn={"Fantasy & Myth":el,"Science Fiction & Future":tl,"Horror & Dark Mystery":nl,"Action & Wasteland":ol,Testing:al},rl=e=>{if(e.length===0)return[];let t=[];return e.forEach(n=>{t=t.concat(Gn[n])}),t},en=e=>{if(!e)return null;for(const t in Gn){const o=Gn[t].find(a=>a.name===e);if(o)return o}return null},sl=e=>{const{theme:t,storyArc:n,worldFacts:o,heroSheet:a,heroBackstory:r}=e;if(!n||!dn(n))throw new Error("buildInitialGamePrompt: missing or invalid story arc");return Ci(t,n,o??{geography:"",climate:"",technologyLevel:"",supernaturalElements:"",majorFactions:[],keyResources:[],culturalNotes:[],notableLocations:[]},a??{name:"Hero",gender:"Male",occupation:"",traits:[],startingItems:[]},r??{fiveYearsAgo:"",oneYearAgo:"",sixMonthsAgo:"",oneMonthAgo:"",oneWeekAgo:"",yesterday:"",now:""})},tr="idb:",et=(e,t)=>`${e}_${String(t)}`,It=(e,t)=>`${tr}${et(e,t)}`,tn=e=>typeof e=="string"&&e.startsWith(tr),po=Cr("whispers-images",1,{upgrade(e){e.createObjectStore("chapterImages")}}),nr=async()=>{const t=(await po).transaction("chapterImages","readwrite");await t.store.clear(),await t.done},nn=async(e,t,n)=>{const o=await po,a=et(e,t);await o.put("chapterImages",n,a)},on=async(e,t)=>{const n=await po,o=et(e,t);return await n.get("chapterImages",o)??null},il=async e=>{const t=Z(e);return await Promise.all(t.inventory.map(async n=>{var o;await Promise.all(((o=n.chapters)==null?void 0:o.map(async(a,r)=>{a.imageData&&!tn(a.imageData)&&(await nn(n.id,r,a.imageData),a.imageData=It(n.id,r))}))??[])})),await Promise.all(t.playerJournal.map(async(n,o)=>{n.imageData&&!tn(n.imageData)&&(await nn(Ve,o,n.imageData),n.imageData=It(Ve,o))})),t},Wo=async e=>{const t=Z(e);return await Promise.all(t.inventory.map(async n=>{var o;await Promise.all(((o=n.chapters)==null?void 0:o.map(async(a,r)=>{if(tn(a.imageData)){const s=await on(n.id,r);a.imageData=s??void 0}}))??[])})),await Promise.all(t.playerJournal.map(async(n,o)=>{if(tn(n.imageData)){const a=await on(Ve,o);n.imageData=a??void 0}})),t},Jo=async e=>{const t=Z(e);return await Promise.all(t.inventory.map(async n=>{var o;await Promise.all(((o=n.chapters)==null?void 0:o.map(async(a,r)=>{a.imageData||await on(n.id,r)&&(a.imageData=It(n.id,r))}))??[])})),await Promise.all(t.playerJournal.map(async(n,o)=>{n.imageData||await on(Ve,o)&&(n.imageData=It(Ve,o))})),t},cl=e=>{const{enabledThemePacksProp:t,setIsLoading:n,setLoadingReason:o,setError:a,setParseErrorCounter:r,setHasGameBeenInitialized:s,thinkingEffortProp:i,getCurrentGameState:c,commitGameState:l,resetGameStateStack:d,setGameStateStack:p,processAiResponse:u,openCharacterSelectModal:m,openGenderSelectModal:g,onActIntro:h}=e,v=b.useCallback(async(y={})=>{var U;const{isRestart:P=!1,explicitThemeName:S=null,savedStateToLoad:C=null,clearImages:$=!1}=y;if(n(!0),o("initial_load"),a(null),r(0),(P||$)&&await nr(),C){const[F,q]=C;let E=F.currentTheme;if(!E){const pe=F.currentThemeName;pe&&(E=en(pe))}if(!E){const pe=F.currentThemeName;pe&&a(`Failed to apply loaded state: Theme "${pe}" not found. Game state may be unstable.`)}let _=F.mapData;E&&(_=await rc(_,E));const R=F.currentMapNodeId,G=F.destinationNodeId,V=F.mapLayoutConfig;typeof V.NESTED_PADDING!="number"&&(V.NESTED_PADDING=Pt().NESTED_PADDING),typeof V.NESTED_ANGLE_PADDING!="number"&&(V.NESTED_ANGLE_PADDING=Pt().NESTED_ANGLE_PADDING);const H={...F,currentTheme:E,mapData:_,currentMapNodeId:R,destinationNodeId:G,mapLayoutConfig:V,mapViewBox:F.mapViewBox,globalTurnNumber:F.globalTurnNumber,enabledThemePacks:t,thinkingEffort:i,isVictory:!1},B=q?{...q,enabledThemePacks:t,thinkingEffort:i,isVictory:!1}:H;p([H,B]);const J=H.storyArc,ce=J?J.acts[J.currentAct-1]:null;ce&&h(ce),s(!0),n(!1),o(null);return}let M=S;if(!M){const F=rl(t);if(F.length===0){a("No adventure themes are enabled or available. Please check settings."),n(!1),o(null);return}M=F[Math.floor(Math.random()*F.length)].name}const A=en(M);if(!A){a(`Theme "${M}" not found. Cannot start game.`),n(!1),o(null);return}const w=await g(((U=c().heroSheet)==null?void 0:U.gender)??"Male");let N=Jt();N.enabledThemePacks=t,N.mapLayoutConfig=Pt(),N.mapViewBox=Bn,N.globalTurnNumber=0,N.currentTheme=A,N.thinkingEffort=i,N.heroSheet={name:"Hero",gender:w,occupation:"",traits:[],startingItems:[]};const L=await Di(A),D=L??{geography:"",climate:"",technologyLevel:"",supernaturalElements:"",majorFactions:[],keyResources:[],culturalNotes:[],notableLocations:[]};N.worldFacts=L??null,l(N);const x=await _i(A,w,D);if(!x||x.length===0){a("Failed to generate character options. Please retry."),n(!1),o(null);return}let K=null,le=null;const j=[...x].sort(()=>Math.random()-.5).slice(0,10),ye=await Ri(A,w,D,j);if(!ye){a("Failed to generate character descriptions. Please retry."),n(!1),o(null);return}let ue=Promise.resolve();await m({theme:A,heroGender:w,worldFacts:D,options:ye},F=>(K=F.heroSheet,le=F.heroBackstory,N.storyArc=F.storyArc,N.heroSheet=K,N.heroBackstory=le,!F.storyArc||!dn(F.storyArc)?(a("Failed to generate a valid story arc. Please retry."),n(!1),o(null),Promise.resolve()):(ue=(async()=>{var _;if(L){const R=await Ii({themeName:A.name,worldFacts:D,heroSheet:K??void 0,heroBackstory:le??void 0,onSetLoadingReason:o});if(R){(_=N.lastDebugPacket)!=null&&_.loremasterDebugInfo&&(N.lastDebugPacket.loremasterDebugInfo.extract=R.debugInfo.extract);const G=R.facts.map(V=>({action:"add",text:V.text,entities:V.entities}));mn(N,G,N.globalTurnNumber)}}N.mapData={nodes:[],edges:[]},N.allNPCs=[],N.score=0,N.inventory=[],N.heroSheet&&(N.heroSheet.gender=w);const q=Z(N);let E="";try{E=sl({theme:A,storyArc:N.storyArc??void 0,worldFacts:N.worldFacts??void 0,heroSheet:N.heroSheet??void 0,heroBackstory:N.heroBackstory??void 0}),N.lastDebugPacket={prompt:E,systemInstruction:Lt,jsonSchema:void 0,rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null,journal:null},dialogueDebugInfo:null};const{response:R,thoughts:G,systemInstructionUsed:V,jsonSchemaUsed:H,promptUsed:B}=await xn(E,We(4096));N.lastDebugPacket.rawResponseText=R.text??null,N.lastDebugPacket.storytellerThoughts=G,N.lastDebugPacket.systemInstruction=V,N.lastDebugPacket.jsonSchema=H,N.lastDebugPacket.prompt=B;const J=N.mapData,ce=await Xt(R.text??"",A,N.heroSheet,()=>{r(1)},void 0,void 0,N.allNPCs,J,N.inventory.filter(pe=>pe.holderId===ne));await u(ce,A,N,{baseStateSnapshot:q,forceEmptyInventory:P,playerActionText:void 0}),s(!0),N.globalTurnNumber=1}catch(R){if(console.error("Error loading initial game:",R),_t(R)){N=Z(q);const G=ln(R);a(`AI service error (${String(G??"unknown")}). Please retry.`)}else{const G=R instanceof Error?R.message:String(R);a(`Failed to initialize the adventure in "${A.name}": ${G}`)}N.lastDebugPacket&&(N.lastDebugPacket.error=R instanceof Error?R.message:String(R))}finally{l(N),n(!1),o(null)}})(),ue))),await ue},[t,i,n,o,a,r,s,l,u,p,m,g,c,h]),f=b.useCallback(()=>{const y=Sn(t);y.thinkingEffort=i,d(y),s(!1),v({isRestart:!0})},[v,s,d,t,i]),I=b.useCallback(y=>{const P=Sn(t);P.thinkingEffort=i,d(P),s(!1),v({explicitThemeName:y,isRestart:!0})},[v,s,d,t,i]),T=b.useCallback(()=>{a(null);const y=Sn(t);y.thinkingEffort=i,d(y),s(!1),v({isRestart:!0})},[v,a,s,d,t,i]),k=b.useCallback(async()=>{var A;a(null);const y=c();if(!y.currentTheme){await v({isRestart:!0});return}const P=(A=y.lastDebugPacket)==null?void 0:A.prompt,S=y.currentTheme;if(!P){const w={...y,actionOptions:["Look around.","Ponder the situation.","Try to move on.","Check your inventory.","Consider your objective.","Plan your next steps."],lastActionLog:"Attempting to re-establish connection with the narrative flow...",dialogueState:null};l(w),n(!1),o(null);return}n(!0),o("storyteller"),r(0);const C=Z(y);let $=Z(y);const M={prompt:P,systemInstruction:Lt,jsonSchema:void 0,rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null,journal:null},dialogueDebugInfo:null};$.lastDebugPacket=M;try{const{response:w,thoughts:N,systemInstructionUsed:L,jsonSchemaUsed:D,promptUsed:x}=await xn(P);$.lastDebugPacket.rawResponseText=w.text??null,$.lastDebugPacket.storytellerThoughts=N,$.lastDebugPacket.systemInstruction=L,$.lastDebugPacket.jsonSchema=D,$.lastDebugPacket.prompt=x;const K=$.allNPCs,le=$.mapData,j=await Xt(w.text??"",S,$.heroSheet,()=>{r(1)},y.lastActionLog??void 0,y.currentScene,K,le,y.inventory.filter(ye=>ye.holderId===ne));await u(j,S,$,{baseStateSnapshot:C,scoreChangeFromAction:0,playerActionText:void 0}),$.globalTurnNumber+=1}catch(w){console.error("Error retrying last main AI request:",w);const N=w instanceof Error?w.message:String(w);a(`Retry failed: ${N}.`),$=Z(C),$.lastActionLog="Retry failed. The outcome remains uncertain.",$.actionOptions=["Look around.","Ponder the situation.","Check your inventory.","Try to move on.","Consider your objective.","Plan your next steps."],$.dialogueState=null,$.lastDebugPacket&&($.lastDebugPacket.error=N)}finally{l($),n(!1),o(null)}},[c,v,l,a,n,o,r,u]);return{loadInitialGame:v,handleStartNewGameFromButton:f,startCustomGame:I,executeRestartGame:T,handleRetry:k}},Ko=e=>{const{currentState:t}=e;return{...t,saveGameVersion:_e,mapData:t.mapData,currentMapNodeId:t.currentMapNodeId,destinationNodeId:t.destinationNodeId,mapLayoutConfig:t.mapLayoutConfig,mapViewBox:t.mapViewBox,globalTurnNumber:t.globalTurnNumber,currentTheme:t.currentTheme}},ql=e=>{var Te;const{enabledThemePacksProp:t,thinkingEffortProp:n,initialSavedStateFromApp:o,initialDebugStackFromApp:a,isAppReady:r,openDebugLoreModal:s,openCharacterSelectModal:i,openGenderSelectModal:c,onActIntro:l}=e,[d,p]=b.useState(()=>[Jt(),Jt()]),[u,m]=b.useState(()=>a??[null,null]),[g,h]=b.useState(!1),[v,f]=b.useState(!1),I=Or(),T=b.useRef(I),k=b.useCallback(O=>{T.current=O,Lr(O)},[]),[y,P]=b.useState(null),[S,C]=b.useState(0),[$,M]=b.useState(""),[A,w]=b.useState(!1),[N,L]=b.useState([]),D=b.useMemo(()=>N.reduce((O,z)=>O+z.cost,0),[N]),x=br-D,K=b.useRef(!1),le=b.useRef(!1),j=b.useRef(()=>Promise.resolve()),ye=b.useRef(null),ue=b.useCallback(()=>d[0],[d]),de=b.useCallback(O=>{p(z=>[O,z[0]]),m(z=>[O.lastDebugPacket??null,z[0]])},[]),U=b.useCallback(O=>{p([O,O]),m([O.lastDebugPacket??null,O.lastDebugPacket??null])},[]),F=b.useCallback(()=>{const[O,z]=d;return[Ko({currentState:O}),z?Ko({currentState:z}):void 0]},[d]),q=b.useCallback(()=>u,[u]),E=ue(),_=b.useCallback(()=>{p(O=>[{...O[0],debugLore:!O[0].debugLore},O[1]])},[]),R=b.useCallback(()=>{p(O=>[{...O[0],debugGoodFacts:[],debugBadFacts:[]},O[1]])},[]),{handleMapLayoutConfigChange:G,handleMapViewBoxChange:V,handleMapNodesPositionChange:H,handleSelectDestinationNode:B,processAiResponse:J,handleActionSelect:ce,handleItemInteraction:pe,handleDropItem:Ie,handleDiscardItem:me,handleTakeLocationItem:Oe,handleStashToggle:Ye,updateItemContent:ve,addJournalEntry:xe,addPlayerJournalEntry:ot,updatePlayerJournalContent:at,recordPlayerJournalInspect:rt,recordInspect:te,handleFreeFormActionSubmit:Ce,handleUndoTurn:Nt,triggerMainQuestAchieved:bt,simulateVictory:Tt}=Zc({getCurrentGameState:ue,commitGameState:de,setGameStateStack:p,setIsLoading:h,setIsTurnProcessing:f,setLoadingReason:k,setError:P,setParseErrorCounter:C,freeFormActionText:$,setFreeFormActionText:M,isLoading:g,isTurnProcessing:v,hasGameBeenInitialized:A,loadingReasonRef:T,debugLore:E.debugLore,openDebugLoreModal:s,actIntroRef:ye,onActIntro:l}),st=b.useCallback(O=>{L(z=>z.some(oe=>oe.id===O.id)?z.filter(oe=>oe.id!==O.id):[...z,O])},[]),St=b.useCallback(()=>{L([])},[]),Je=b.useCallback((O,z,he)=>{var Le;if(z==="take"){Oe(O.id);return}if(z==="drop"){Ie(O.id);return}if(z==="discard"){me(O.id);return}let oe="",fe="",ke="",ct,Ke=0;switch(z){case"inspect":{if(oe=`${O.id}-inspect`,fe=`Inspect the ${O.name}`,ct=()=>{te(O.id)},Ke=Ar,O.type==="book"||O.type==="page"){const Ee=(Le=O.tags)==null?void 0:Le.includes("recovered"),lt=(O.chapters??[]).map($e=>`${$e.heading}
${Ee?$e.actualContent??"":$e.visibleContent??""}`).join(`

`);ke=`Player reads the ${O.name} - ${O.description}. Here's what the player reads:
${lt}`}else ke=`Player investigates the ${O.name} - ${O.description}.`;break}case"generic":oe=`${O.id}-generic`,fe=`Attempt to use the ${O.name}`,ke=`Attempt to use: ${O.name}`,Ke=Sr;break;case"specific":he&&(oe=`${O.id}-specific-${he.actionName}`,fe=he.actionName,ke=he.promptEffect,Ke=Tr);break}if(oe&&fe&&ke){if(!N.some(lt=>lt.id===oe)&&Ke>x)return;st({id:oe,displayText:fe,promptText:ke,cost:Ke,effect:ct})}},[Ie,me,Oe,st,te,N,x]),{loadInitialGame:it,handleStartNewGameFromButton:gn,startCustomGame:hn,executeRestartGame:fn,handleRetry:yn}=cl({enabledThemePacksProp:t,thinkingEffortProp:n,setIsLoading:h,setLoadingReason:k,setError:P,setParseErrorCounter:C,setHasGameBeenInitialized:w,getCurrentGameState:ue,commitGameState:de,resetGameStateStack:U,setGameStateStack:p,processAiResponse:J,openCharacterSelectModal:i,openGenderSelectModal:c,onActIntro:l});j.current=it;const{isDialogueExiting:Ot,handleDialogueOptionSelect:vn,handleForceExitDialogue:wn}=Ai({getCurrentGameState:ue,commitGameState:de,setError:P,setIsLoading:h,setLoadingReason:k,onDialogueConcluded:(O,z,he)=>{const oe=Z(z);return J(O,z.currentTheme,oe,{baseStateSnapshot:Z(z),isFromDialogueSummary:!0,playerActionText:void 0,dialogueTranscript:z.gameLog[z.gameLog.length-1]??""}).then(()=>{oe.lastDebugPacket??(oe.lastDebugPacket={prompt:"",rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null},dialogueDebugInfo:null}),oe.lastDebugPacket.prompt=`[Dialogue Outcome]
${he.summaryPrompt??oe.lastDebugPacket.prompt}`,oe.lastDebugPacket.rawResponseText=he.summaryRawResponse??null,oe.lastDebugPacket.storytellerThoughts=he.summaryThoughts??null,oe.lastDebugPacket.parsedResponse=O,oe.lastDebugPacket.dialogueDebugInfo=he,de(oe),h(!1),k(null)}).catch(fe=>{console.error("Error in post-dialogue processAiResponse:",fe),P("Failed to fully process dialogue conclusion. Game state might be inconsistent."),de(z),h(!1),k(null)})}});b.useEffect(()=>{r&&!A&&o&&!K.current&&(it({savedStateToLoad:o}),K.current=!0)},[r,A,o,it]),b.useEffect(()=>{r&&a&&!le.current&&(m(a),le.current=!0)},[r,a]);const Y=ue();b.useEffect(()=>{A&&p(O=>{const z=O[0];return z.enabledThemePacks.length===t.length&&z.enabledThemePacks.every((fe,ke)=>fe===t[ke])?O:[{...z,enabledThemePacks:[...t]},O[1]]})},[t,A]);const In=b.useMemo(()=>{const O={},z=new Set(Y.mapData.nodes.map(he=>he.id));return Y.inventory.forEach(he=>{var oe;if(z.has(he.holderId)){const fe=O[he.holderId]??{hasUseful:!1,hasVehicle:!1};(oe=he.tags)!=null&&oe.includes("junk")||(fe.hasUseful=!0),he.type==="vehicle"&&(fe.hasVehicle=!0),O[he.holderId]=fe}}),O},[Y.inventory,Y.mapData.nodes]),At=b.useCallback(async()=>{var lt;const O=ue(),z=O.currentTheme;if(!z)return;h(!0),P(null);const he=O.mapData.nodes,oe=Array.from(new Set(O.inventory.filter($e=>$e.holderId===ne||he.some(Nn=>Nn.id===$e.holderId)?!0:!!O.allNPCs.find(Nn=>Nn.id===$e.holderId)).map($e=>$e.name))),fe=he.map($e=>$e.placeName),ke=O.gameLog.slice(-20);k("loremaster_refine");const ct=(lt=O.storyArc)==null?void 0:lt.acts[O.storyArc.currentAct-1],Ke=(ct==null?void 0:ct.mainObjective)??null,Le=await Ka({themeName:z.name,facts:O.themeFacts,currentQuest:Ke,currentObjective:O.currentObjective,inventoryItemNames:oe,mapNodeNames:fe,recentLogEntries:ke}),Ee=Z(O);Ee.lastLoreDistillTurn=O.globalTurnNumber,Ee.lastDebugPacket??(Ee.lastDebugPacket={prompt:"",rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null},dialogueDebugInfo:null}),Ee.lastDebugPacket.loremasterDebugInfo&&(Ee.lastDebugPacket.loremasterDebugInfo.distill=(Le==null?void 0:Le.debugInfo)??null),Le!=null&&Le.refinementResult&&mn(Ee,Le.refinementResult.factsChange,Ee.globalTurnNumber),de(Ee),h(!1),k(null)},[de,ue,P,h,k]);b.useEffect(()=>{!A||g||Y.dialogueState!==null||Y.globalTurnNumber>0&&Y.globalTurnNumber%ma===0&&Y.lastLoreDistillTurn!==Y.globalTurnNumber&&At()},[Y.globalTurnNumber,Y.lastLoreDistillTurn,At,A,g,Y.dialogueState]);const Ct=(Te=Y.storyArc)==null?void 0:Te.acts[Y.storyArc.currentAct-1],we=(Ct==null?void 0:Ct.mainObjective)??null;return{currentTheme:Y.currentTheme,currentScene:Y.currentScene,actionOptions:Y.actionOptions,mainQuest:we,storyArc:Y.storyArc,heroSheet:Y.heroSheet,currentObjective:Y.currentObjective,inventory:Y.inventory.filter(O=>O.holderId===ne),playerJournal:Y.playerJournal,lastJournalWriteTurn:Y.lastJournalWriteTurn,lastJournalInspectTurn:Y.lastJournalInspectTurn,lastLoreDistillTurn:Y.lastLoreDistillTurn,itemsHere:b.useMemo(()=>{if(!Y.currentMapNodeId)return[];const O=Y.inventory.filter(fe=>fe.holderId===Y.currentMapNodeId),z=Xa(Y.mapData,Y.currentMapNodeId),he=Y.inventory.filter(fe=>z.includes(fe.holderId)),oe=[...O];return he.forEach(fe=>{oe.includes(fe)||oe.push(fe)}),oe},[Y.currentMapNodeId,Y.inventory,Y.mapData]),itemPresenceByNode:In,gameLog:Y.gameLog,lastActionLog:Y.lastActionLog,isLoading:g||Y.dialogueState!==null&&Ot,isTurnProcessing:v,loadingReason:I,error:y,allNPCs:Y.allNPCs,mapData:Y.mapData,currentMapNodeId:Y.currentMapNodeId,destinationNodeId:Y.destinationNodeId,mapLayoutConfig:Y.mapLayoutConfig,mapViewBox:Y.mapViewBox,score:Y.score,freeFormActionText:$,setFreeFormActionText:M,handleFreeFormActionSubmit:Ce,objectiveAnimationType:Y.objectiveAnimationType,localTime:Y.localTime,localEnvironment:Y.localEnvironment,localPlace:Y.localPlace,globalTurnNumber:Y.globalTurnNumber,dialogueState:Y.dialogueState,isDialogueExiting:Ot,handleDialogueOptionSelect:vn,handleForceExitDialogue:wn,isVictory:Y.isVictory,lastDebugPacket:u[0],lastTurnChanges:Y.lastTurnChanges,gameStateStack:d,debugPacketStack:u,handleActionSelect:ce,executeItemInteraction:pe,handleDropItem:Ie,handleDiscardItem:me,handleTakeLocationItem:Oe,updateItemContent:ve,handleRetry:yn,executeRestartGame:fn,startCustomGame:hn,gatherCurrentGameState:F,gatherDebugPacketStack:q,applyLoadedGameState:it,setError:P,setIsLoading:h,hasGameBeenInitialized:A,handleStartNewGameFromButton:gn,handleMapLayoutConfigChange:G,handleMapViewBoxChange:V,handleMapNodesPositionChange:H,handleSelectDestinationNode:B,handleUndoTurn:Nt,triggerMainQuestAchieved:bt,simulateVictory:Tt,handleStashToggle:Ye,addJournalEntry:xe,addPlayerJournalEntry:ot,updatePlayerJournalContent:at,recordPlayerJournalInspect:rt,commitGameState:de,handleDistillFacts:At,toggleDebugLore:_,clearDebugFacts:R,debugLore:Y.debugLore,debugGoodFacts:Y.debugGoodFacts,debugBadFacts:Y.debugBadFacts,queueItemAction:Je,queuedItemActions:N,clearQueuedItemActions:St,remainingActionPoints:x}},zl=({items:e,onItemInteract:t,onStashToggle:n,onReadPage:o})=>{const[a,r]=b.useState(new Set),s=b.useRef(e),[i,c]=b.useState("default"),[l,d]=b.useState("all"),[p,u]=b.useState(new Set),m=b.useCallback(A=>{c(w=>w==="name"?"default":"name"),A.currentTarget.blur()},[]),g=b.useCallback(A=>{c(w=>w==="type"?"default":"type"),A.currentTarget.blur()},[]),h=b.useCallback(A=>{d("all"),A.currentTarget.blur()},[]),v=b.useCallback(A=>{d(w=>w==="stashed"?"all":"stashed"),A.currentTarget.blur()},[]),f=b.useCallback(A=>{const w=A.currentTarget.dataset.itemId;if(w){const N=e.find(L=>L.id===w);n(w),N!=null&&N.stashed?l==="stashed"?(u(L=>new Set(L).add(w)),setTimeout(()=>{u(L=>{const D=new Set(L);return D.delete(w),D})},1e3)):(r(L=>new Set(L).add(w)),setTimeout(()=>{r(L=>{const D=new Set(L);return D.delete(w),D})},1500)):(u(L=>new Set(L).add(w)),setTimeout(()=>{u(L=>{const D=new Set(L);return D.delete(w),D})},1e3)),A.currentTarget.blur()}},[l,e,n]),I=b.useCallback(A=>{const{itemId:w,actionName:N,promptEffect:L}=A.currentTarget.dataset;if(!w||!N||!L)return;const D=e.find(K=>K.id===w);if(!D)return;t(D,"specific",{actionName:N,promptEffect:L,description:N}),A.currentTarget.blur()},[e,t]),T=b.useCallback(A=>{const w=A.currentTarget.dataset.itemId;if(!w)return;const N=e.find(L=>L.id===w);N&&(t(N,"inspect"),A.currentTarget.blur())},[e,t]),k=b.useCallback(A=>{const w=A.currentTarget.dataset.itemId;if(!w)return;const N=e.find(L=>L.id===w);N&&(t(N,"generic"),A.currentTarget.blur())},[e,t]),y=b.useCallback(A=>{const w=A.currentTarget.dataset.itemId;if(!w)return;const N=e.find(L=>L.id===w);N&&(t(N,"drop"),A.currentTarget.blur())},[e,t]),P=b.useCallback(A=>{const w=A.currentTarget.dataset.itemId;if(!w)return;const N=e.find(L=>L.id===w);N&&(t(N,"discard"),A.currentTarget.blur())},[e,t]),S=b.useCallback(A=>{const w=A.currentTarget.dataset.itemId;if(!w)return;const N=e.find(x=>x.id===w);if(!N)return;const L=N.isActive?`Exit ${N.name}`:`Enter ${N.name}`;t(N,"specific",{actionName:L,promptEffect:L,description:L}),A.currentTarget.blur()},[e,t]),C=b.useCallback(A=>{const w=A.currentTarget.dataset.itemId;if(!w)return;const N=e.find(L=>L.id===w);N&&(o(N),A.currentTarget.blur())},[e,o]);b.useEffect(()=>{const A=new Set(e.map(L=>L.id)),w=new Set(s.current.map(L=>L.id)),N=[];A.forEach(L=>{w.has(L)||N.push(L)}),N.length>0&&(r(L=>{const D=new Set(L);return N.forEach(x=>D.add(x)),D}),N.forEach(L=>{setTimeout(()=>{r(D=>{const x=new Set(D);return x.delete(L),x})},1500)})),s.current=e},[e]);const $=b.useMemo(()=>{const w=[...e.filter(N=>{if(p.has(N.id))return!0;const L=["page","book","picture","map"].includes(N.type);return l==="stashed"?N.stashed&&L:!(N.stashed&&L)})];return i==="name"?w.sort((N,L)=>N.name.localeCompare(L.name)):i==="type"?w.sort((N,L)=>{const D=N.type.localeCompare(L.type);return D!==0?D:N.name.localeCompare(L.name)}):w.reverse(),w},[e,i,l,p]),M=b.useCallback(A=>A.knownUses?A.knownUses.filter(w=>{const N=!!A.isActive;return w.appliesWhenActive!==void 0&&w.appliesWhenInactive!==void 0?w.appliesWhenActive&&N||w.appliesWhenInactive&&!N||!w.appliesWhenActive&&!w.appliesWhenInactive:w.appliesWhenActive!==void 0?w.appliesWhenActive===N:w.appliesWhenInactive!==void 0?w.appliesWhenInactive===!N:!0}):[],[]);return{displayedItems:$,newlyAddedItemIds:a,stashingItemIds:p,sortOrder:i,filterMode:l,handleSortByName:m,handleSortByType:g,handleFilterAll:h,handleFilterStashed:v,handleSpecificUse:I,handleInspect:T,handleGenericUse:k,handleDrop:y,handleDiscard:P,handleVehicleToggle:S,handleStashToggleInternal:f,handleRead:C,getApplicableKnownUses:M}},Ql=()=>{const[e,t]=b.useState(es()),[n,o]=b.useState(ts());b.useEffect(()=>(qr(t),zr(o),()=>{Qr(t),Xr(o)}),[]);const a=b.useCallback(()=>{$a()},[]);return{progress:e,retryCount:n,clearProgress:a}},qo=()=>({[Q]:{model:Q,count:An(Q),limit:ua},[X]:{model:X,count:An(X),limit:da},[Se]:{model:Se,count:An(Se),limit:la}}),Xl=()=>{const[e,t]=b.useState(()=>qo());return b.useEffect(()=>{const n=()=>{t(qo())},o=Hr(n),a=setInterval(n,1e3);return()=>{o(),clearInterval(a)}},[]),e},zo=600,ll=2e3,dl=(e,t)=>{const n=e??[],o=t??[];if(n.length!==o.length)return!1;if(n.length===0)return!0;const a=i=>{const c={};return Object.keys(i).sort().forEach(l=>{c[l]=i[l]}),JSON.stringify(c)},r=n.map(a).sort(),s=o.map(a).sort();for(let i=0;i<r.length;i++)if(r[i]!==s[i])return!1;return!0},ul=(e,t)=>!e||!t?e===t:e.name!==t.name||e.type!==t.type||e.description!==t.description||(e.activeDescription??"")!==(t.activeDescription??"")||(e.isActive??!1)!==(t.isActive??!1)||JSON.stringify(e.tags??[])!==JSON.stringify(t.tags??[])?!1:dl(e.knownUses,t.knownUses),Zl=({lastTurnChanges:e,isGameBusy:t})=>{const[n,o]=b.useState([]),[a,r]=b.useState(null),[s,i]=b.useState("idle"),[c,l]=b.useState(null),[d,p]=b.useState(!1),[u,m]=b.useState(null),[g,h]=b.useState(null),[v,f]=b.useState(!1),[I,T]=b.useState(null),[k,y]=b.useState(null),P=b.useRef(null),S=b.useCallback(()=>{P.current&&(clearTimeout(P.current),P.current=null)},[]),C=b.useCallback(()=>{S(),o([]),r(null),i("idle"),f(!1),p(!1),m(null),h(null),l(null)},[S]);b.useEffect(()=>{t&&(k?(T(k),y(null)):e&&e!==I&&T(e),C())},[t,C,k,I,e]),b.useEffect(()=>{if(t||!e){!t&&n.length>0&&o([]);return}if(e===I||e===k||k&&a)return;y(e);const w=[];for(const N of e.itemChanges)N.type==="acquire"&&N.acquiredItem?w.push({type:"acquire",item:N.acquiredItem}):N.type==="loss"&&N.lostItem?w.push({type:"loss",item:N.lostItem}):N.type==="update"&&N.oldItem&&N.newItem&&(ul(N.oldItem,N.newItem)||w.push({type:"change",oldItem:N.oldItem,newItem:N.newItem}));w.sort((N,L)=>{const D={loss:0,acquire:1,change:2};return D[N.type]-D[L.type]}),w.length>0?o(w):(o([]),T(e),y(null),f(!1))},[e,t,I,k,a,n]);const $=b.useCallback(()=>{if(S(),n.length>0&&!t){const w=n[0];r(w),o(N=>N.slice(1)),f(!0),w.type==="change"&&w.oldItem&&w.newItem?l({oldItem:w.oldItem,newItem:w.newItem}):w.item?l({item:w.item}):l(null),i("appearing")}else r(null),i("idle"),l(null)},[n,t,S]);b.useEffect(()=>{s==="idle"&&!a&&!t&&(n.length>0?$():(f(!1),k&&k!==I&&T(k),y(null)))},[s,n,a,$,t,k,I]),b.useEffect(()=>{if(!(t||!a||s==="idle")){switch(S(),s){case"appearing":{m(null),h(null),p(!0);const w=a;P.current=window.setTimeout(()=>{a===w&&i("visible")},zo);break}case"visible":{a.type==="acquire"?h("acquire"):a.type==="loss"?h("loss"):h("change-new");const w=a;P.current=window.setTimeout(()=>{a===w&&i("disappearing")},ll);break}case"disappearing":h(null),a.type==="loss"?m("disappear-to-large"):m("disappear-to-small"),p(!1),P.current=window.setTimeout(()=>{r(null),i("idle"),m(null)},zo);break}return()=>{S()}}},[a,s,t,S]);const M=b.useCallback(()=>{t||(C(),k?(T(k),y(null)):e&&e!==I&&T(e))},[t,C,e,I,k]),A=b.useCallback(w=>{(w.key==="Enter"||w.key===" ")&&M()},[M]);return{itemForCardDisplay:c,currentAnimatingItem:a,isVisibleOverlay:v,isCardVisibleClass:d,explicitDisappearClass:u,activeGlowType:g,handleSkipAnimations:M,handleKeyDown:A}},Ue=(e,t,n)=>{const o=e.getScreenCTM();if(!o)return{x:t,y:n};const a=o.inverse(),r=e.createSVGPoint();r.x=t,r.y=n;const s=r.matrixTransform(a);return{x:s.x,y:s.y}},pl=(e,t,n)=>{const o=e.getScreenCTM();if(!o)return{x:t,y:n};const a=e.createSVGPoint();a.x=t,a.y=n;const r=a.matrixTransform(o);return{x:r.x,y:r.y}},ed=(e=`${String(-dt/2)} ${String(-ut/2)} ${String(dt)} ${String(ut)}`,t)=>{const[n,o]=b.useState(e),a=y=>{o(y),t&&t(y)},r=b.useRef(null),[s,i]=b.useState(!1),[c,l]=b.useState(null),[d,p]=b.useState(null);b.useEffect(()=>{o(y=>y===e?y:e)},[e]);const u=y=>{y.target.closest(".map-node")||(i(!0),l({x:y.clientX,y:y.clientY}),r.current&&(r.current.style.cursor="grabbing"))},m=y=>{if(!s||!c||!r.current)return;const P=r.current,S=Ue(P,c.x,c.y),C=Ue(P,y.clientX,y.clientY),$=S.x-C.x,M=S.y-C.y,[A,w,N,L]=n.split(" ").map(parseFloat);a(`${String(A+$)} ${String(w+M)} ${String(N)} ${String(L)}`),l({x:y.clientX,y:y.clientY})},g=()=>{i(!1),l(null),r.current&&(r.current.style.cursor="grab")},h=()=>{s&&g()},v=y=>{if(y.cancelable&&y.preventDefault(),!r.current)return;const[P,S,C,$]=n.split(" ").map(parseFloat),M=1.1,A=y.deltaY<0?C/M:C*M,w=y.deltaY<0?$/M:$*M,N=Math.min(dt,ut)*.1,L=Math.min(dt,ut)*10;if(A<N||A>L||w<N||w>L)return;const D=r.current,x=Ue(D,y.clientX,y.clientY),K=x.x-(x.x-P)*(A/C),le=x.y-(x.y-S)*(w/$);a(`${String(K)} ${String(le)} ${String(A)} ${String(w)}`)},f=(y,P)=>Math.sqrt(Math.pow(y.clientX-P.clientX,2)+Math.pow(y.clientY-P.clientY,2));return{viewBox:n,svgRef:r,handleMouseDown:u,handleMouseMove:m,handleMouseUp:g,handleMouseLeave:h,handleWheel:v,handleTouchStart:y=>{if(r.current)if(y.cancelable&&y.preventDefault(),y.touches.length===1){if(y.target.closest(".map-node"))return;i(!0),l({x:y.touches[0].clientX,y:y.touches[0].clientY}),p(null),r.current.style.cursor="grabbing"}else y.touches.length===2&&(i(!1),p(f(y.touches[0],y.touches[1])),l(null))},handleTouchMove:y=>{if(r.current){if(y.cancelable&&y.preventDefault(),y.touches.length===1&&s&&c){const P=y.touches[0],S=r.current,C=Ue(S,c.x,c.y),$=Ue(S,P.clientX,P.clientY),M=C.x-$.x,A=C.y-$.y,[w,N,L,D]=n.split(" ").map(parseFloat);a(`${String(w+M)} ${String(N+A)} ${String(L)} ${String(D)}`),l({x:P.clientX,y:P.clientY})}else if(y.touches.length===2&&d!==null){const P=f(y.touches[0],y.touches[1]);if(P===0||d===0)return;const S=P/d,[C,$,M,A]=n.split(" ").map(parseFloat);let w=M/S,N=A/S;const L=Math.min(dt,ut)*.1,D=Math.min(dt,ut)*10;(w<L||w>D||N<L||N>D)&&(w<L&&(N*=L/w,w=L),N<L&&(w*=L/N,N=L),w>D&&(N*=D/w,w=D),N>D&&(w*=D/N,N=D));const x=(y.touches[0].clientX+y.touches[1].clientX)/2,K=(y.touches[0].clientY+y.touches[1].clientY)/2,le=r.current,j=Ue(le,x,K),ye=j.x-(j.x-C)*(w/M),ue=j.y-(j.y-$)*(N/A);a(`${String(ye)} ${String(ue)} ${String(w)} ${String(N)}`),p(P)}}},handleTouchEnd:y=>{r.current&&(r.current.style.cursor="grab"),y.touches.length<2&&p(null),y.touches.length<1&&(i(!1),l(null))}}},td=({nodes:e,edges:t,svgRef:n,viewBox:o,destinationNodeId:a,onSelectDestination:r})=>{const[s,i]=b.useState(null),[c,l]=b.useState(!1),d=b.useRef(null),p=250,[u,m]=b.useState(null);b.useLayoutEffect(()=>{if(!s||!n.current){m(null);return}const{x:y,y:P}=pl(n.current,s.svgX,s.svgY),S=n.current.getBoundingClientRect();m({x:y-S.left,y:P-S.top})},[s,o,n]);const g=b.useCallback((y,P,S)=>{const C=y>S.width/2?"right":"left";return`${P>S.height*.75?"bottom":"top"}-${C}`},[]),h=b.useCallback(()=>{d.current&&(clearTimeout(d.current),d.current=null),c||i(null)},[c]),v=b.useCallback(y=>{const P=y.target;!P.closest(".map-node")&&!P.closest(".map-edge-group")&&(l(!1),i(null))},[]),f=b.useCallback(y=>{var x;if(c)return;const P=y.currentTarget.dataset.edgeId;if(!P)return;const S=t.find(K=>K.id===P);if(!S)return;const C=(x=n.current)==null?void 0:x.getBoundingClientRect();if(!C)return;const $=y.clientX-C.left,M=y.clientY-C.top,A=n.current?Ue(n.current,y.clientX,y.clientY):{x:0,y:0},w=e.find(K=>K.id===S.sourceNodeId),N=e.find(K=>K.id===S.targetNodeId);let L=S.data.description??`Path between ${(w==null?void 0:w.placeName)??"Unknown"} and ${(N==null?void 0:N.placeName)??"Unknown"}`;S.data.travelTime&&(L+=`
${S.data.travelTime}`),S.data.status&&(L+=`
Status: ${S.data.status}`);const D=g($,M,C);d.current&&clearTimeout(d.current),d.current=window.setTimeout(()=>{i({content:L,svgX:A.x,svgY:A.y,anchor:D})},p)},[g,t,c,e,n]),I=b.useCallback(y=>{var L;if(c)return;const P=y.currentTarget.getAttribute("data-node-id");if(!P)return;const S=e.find(D=>D.id===P);if(!S)return;const C=(L=n.current)==null?void 0:L.getBoundingClientRect();if(!C)return;const $=y.clientX-C.left,M=y.clientY-C.top,A=n.current?Ue(n.current,y.clientX,y.clientY):{x:0,y:0};let w=S.placeName;S.data.aliases&&S.data.aliases.length>0&&(w+=` (aka ${S.data.aliases.join(", ")})`),S.data.description&&(w+=`
${S.data.description}`),w+=`
Status: ${S.data.status}`;const N=g($,M,C);d.current&&clearTimeout(d.current),d.current=window.setTimeout(()=>{i({content:w,svgX:A.x,svgY:A.y,anchor:N,nodeId:P})},p)},[g,c,e,n]),T=b.useCallback(y=>{var L;y.stopPropagation();const P=y.currentTarget.getAttribute("data-node-id");if(!P)return;const S=e.find(D=>D.id===P);if(!S)return;d.current&&(clearTimeout(d.current),d.current=null);const C=(L=n.current)==null?void 0:L.getBoundingClientRect();if(!C)return;const $=y.clientX-C.left,M=y.clientY-C.top,A=n.current?Ue(n.current,y.clientX,y.clientY):{x:0,y:0};let w=S.placeName;S.data.aliases&&S.data.aliases.length>0&&(w+=` (aka ${S.data.aliases.join(", ")})`),S.data.description&&(w+=`
${S.data.description}`),w+=`
Status: ${S.data.status}`,l(!0);const N=g($,M,C);i({content:w,svgX:A.x,svgY:A.y,anchor:N,nodeId:P})},[g,e,n]),k=b.useCallback(y=>{const P=y.currentTarget.dataset.nodeId;P&&(r(P===a?null:P),l(!1),i(null))},[a,r]);return{tooltip:s,tooltipScreenPosition:u,isTooltipLocked:c,handleMouseLeaveGeneral:h,handleSvgClick:v,handleEdgeMouseEnterById:f,handleNodeMouseEnterById:I,handleNodeClickById:T,handleDestinationClick:k,setIsTooltipLocked:l}};function ml(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.summaryText=="string"&&Array.isArray(t.participants)&&t.participants.every(n=>typeof n=="string")&&typeof t.timestamp=="string"&&typeof t.location=="string"}function or(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.heading=="string"&&typeof t.description=="string"&&typeof t.contentLength=="number"&&(t.actualContent===void 0||typeof t.actualContent=="string")&&(t.visibleContent===void 0||typeof t.visibleContent=="string")&&(t.imageData===void 0||typeof t.imageData=="string")}function gl(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.id=="string"&&typeof t.name=="string"&&typeof t.type=="string"&&tt.includes(t.type)&&typeof t.description=="string"&&typeof t.holderId=="string"&&(t.activeDescription===void 0||typeof t.activeDescription=="string")&&(t.isActive===void 0||typeof t.isActive=="boolean")&&(t.stashed===void 0||typeof t.stashed=="boolean")&&(t.tags===void 0||Array.isArray(t.tags)&&t.tags.every(n=>typeof n=="string"))&&(t.lastWriteTurn===void 0||typeof t.lastWriteTurn=="number")&&(t.lastInspectTurn===void 0||typeof t.lastInspectTurn=="number")&&(t.contentLength===void 0||typeof t.contentLength=="number")&&(t.actualContent===void 0||typeof t.actualContent=="string")&&(t.visibleContent===void 0||typeof t.visibleContent=="string")&&(t.imageData===void 0||typeof t.imageData=="string")&&(t.chapters===void 0||Array.isArray(t.chapters)&&t.chapters.every(or))&&(t.knownUses===void 0||Array.isArray(t.knownUses)&&t.knownUses.every(n=>typeof n.actionName=="string"&&typeof n.promptEffect=="string"&&(n.description===void 0||typeof n.description=="string")&&(n.appliesWhenActive===void 0||typeof n.appliesWhenActive=="boolean")&&(n.appliesWhenInactive===void 0||typeof n.appliesWhenInactive=="boolean")))}function hl(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.id=="number"&&typeof t.text=="string"&&Array.isArray(t.entities)&&t.entities.every(n=>typeof n=="string")&&typeof t.createdTurn=="number"&&typeof t.tier=="number"}function ar(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.geography=="string"&&typeof t.climate=="string"&&typeof t.technologyLevel=="string"&&typeof t.supernaturalElements=="string"&&Array.isArray(t.majorFactions)&&t.majorFactions.every(n=>typeof n=="string")&&Array.isArray(t.keyResources)&&t.keyResources.every(n=>typeof n=="string")&&Array.isArray(t.culturalNotes)&&t.culturalNotes.every(n=>typeof n=="string")&&Array.isArray(t.notableLocations)&&t.notableLocations.every(n=>typeof n=="string")}function rr(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.name=="string"&&typeof t.occupation=="string"&&Array.isArray(t.traits)&&t.traits.every(n=>typeof n=="string")&&Array.isArray(t.startingItems)&&t.startingItems.every(n=>typeof n=="string")}function sr(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.fiveYearsAgo=="string"&&typeof t.oneYearAgo=="string"&&typeof t.sixMonthsAgo=="string"&&typeof t.oneMonthAgo=="string"&&typeof t.oneWeekAgo=="string"&&typeof t.yesterday=="string"&&typeof t.now=="string"}function fl(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.id=="string"&&t.id.trim()!==""&&typeof t.name=="string"&&t.name.trim()!==""&&typeof t.description=="string"&&t.description.trim()!==""&&(t.aliases===void 0||Array.isArray(t.aliases)&&t.aliases.every(n=>typeof n=="string"))&&(t.presenceStatus===void 0||gt.includes(t.presenceStatus))&&(t.lastKnownLocation===void 0||t.lastKnownLocation===null||typeof t.lastKnownLocation=="string")&&(t.preciseLocation===void 0||t.preciseLocation===null||typeof t.preciseLocation=="string")&&(t.dialogueSummaries===void 0||Array.isArray(t.dialogueSummaries)&&t.dialogueSummaries.every(ml))}function yl(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.description=="string"&&(t.aliases===void 0||Array.isArray(t.aliases)&&t.aliases.every(n=>typeof n=="string"))&&(t.status===void 0||["undiscovered","discovered","rumored","quest_target","blocked"].includes(t.status))&&(t.visited===void 0||typeof t.visited=="boolean")&&(t.isFeature===void 0||typeof t.isFeature=="boolean")&&(t.parentNodeId===void 0||typeof t.parentNodeId=="string")}function vl(e){if(!e||typeof e!="object")return!1;const t=e,n=t.position;return typeof t.id=="string"&&t.id.trim()!==""&&typeof t.placeName=="string"&&t.placeName.trim()!==""&&n!==void 0&&typeof n.x=="number"&&typeof n.y=="number"&&yl(t.data)}function wl(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.id=="string"&&t.id.trim()!==""&&typeof t.sourceNodeId=="string"&&t.sourceNodeId.trim()!==""&&typeof t.targetNodeId=="string"&&t.targetNodeId.trim()!==""&&typeof t.data=="object"}function Il(e){if(!e||typeof e!="object")return!1;const t=e;return Array.isArray(t.nodes)&&t.nodes.every(vl)&&Array.isArray(t.edges)&&t.edges.every(wl)}function Nl(e){if(!e||typeof e!="object")return!1;const t=e,n=Object.keys(Pt());for(const o of n){const a=t[o];if(typeof a!="number")return console.warn(`isValidMapLayoutConfig: Key '${o}' is missing or not a number. Value: ${String(a)}`),!1}return!0}function bl(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.name=="string"&&t.name.trim()!==""&&typeof t.storyGuidance=="string"&&typeof t.playerJournalStyle=="string"}function Tl(e){if(!e||typeof e!="object")return console.warn("Invalid save data: Not an object."),!1;const t=e;if(t.saveGameVersion!==_e){const a=e.saveGameVersion;console.warn(`Save data version mismatch. Expected ${_e}, got ${String(a)}. Attempting to load anyway if structure is V3-compatible.`)}const n=["currentTheme","currentScene","actionOptions","mainQuest","currentObjective","inventory","playerJournal","lastJournalWriteTurn","lastJournalInspectTurn","lastLoreDistillTurn","gameLog","lastActionLog","themeFacts","worldFacts","heroSheet","heroBackstory","allNPCs","mapData","currentMapNodeId","destinationNodeId","mapLayoutConfig","mapViewBox","score","localTime","localEnvironment","localPlace","globalTurnNumber"];for(const a of n)if(!(a in t)&&!(["currentTheme","mainQuest","currentObjective","lastActionLog","localTime","localEnvironment","localPlace","currentMapNodeId","destinationNodeId","themeFacts","worldFacts","heroSheet","heroBackstory"].includes(a)&&t[a]===null)&&a!=="globalTurnNumber"&&a!=="themeFacts"&&a!=="worldFacts"&&a!=="heroSheet"&&a!=="heroBackstory")return console.warn(`Invalid save data (V3): Missing field '${a}'.`),!1;if(t.currentTheme!==null&&!bl(t.currentTheme))return console.warn("Invalid save data (V3): currentTheme type or structure."),!1;if(typeof t.currentScene!="string")return console.warn("Invalid save data (V3): currentScene type."),!1;if(!Array.isArray(t.actionOptions)||!t.actionOptions.every(a=>typeof a=="string"))return console.warn("Invalid save data (V3): actionOptions."),!1;if(t.mainQuest!==null&&typeof t.mainQuest!="string")return console.warn("Invalid save data (V3): mainQuest type."),!1;if(t.currentObjective!==null&&typeof t.currentObjective!="string")return console.warn("Invalid save data (V3): currentObjective type."),!1;if(!Array.isArray(t.inventory)||!t.inventory.every(gl))return console.warn("Invalid save data (V3): inventory."),!1;if(!Array.isArray(t.playerJournal)||!t.playerJournal.every(or))return console.warn("Invalid save data (V3): playerJournal type."),!1;if(typeof t.lastJournalWriteTurn!="number")return console.warn("Invalid save data (V3): lastJournalWriteTurn type."),!1;if(typeof t.lastJournalInspectTurn!="number")return console.warn("Invalid save data (V3): lastJournalInspectTurn type."),!1;if(typeof t.lastLoreDistillTurn!="number")return console.warn("Invalid save data (V3): lastLoreDistillTurn type."),!1;if(!Array.isArray(t.gameLog)||!t.gameLog.every(a=>typeof a=="string"))return console.warn("Invalid save data (V3): gameLog."),!1;if(t.lastActionLog!==null&&typeof t.lastActionLog!="string")return console.warn("Invalid save data (V3): lastActionLog type."),!1;if(t.themeFacts!==void 0&&!Array.isArray(t.themeFacts))return console.warn("Invalid save data (V5): themeFacts type."),!1;if(Array.isArray(t.themeFacts)&&!t.themeFacts.every(hl))return console.warn("Invalid save data (V5): themeFacts structure."),!1;if(t.worldFacts!==null&&t.worldFacts!==void 0&&!ar(t.worldFacts))return console.warn("Invalid save data (V5): worldFacts structure."),!1;if(t.heroSheet!==null&&t.heroSheet!==void 0&&!rr(t.heroSheet))return console.warn("Invalid save data (V5): heroSheet structure."),!1;if(t.heroBackstory!==null&&t.heroBackstory!==void 0&&!sr(t.heroBackstory))return console.warn("Invalid save data (V5): heroBackstory structure."),!1;if(!Array.isArray(t.allNPCs)||!t.allNPCs.every(fl))return console.warn("Invalid save data (V3): allNPCs."),!1;if(!Il(t.mapData))return console.warn("Invalid save data (V3): mapData."),!1;if(t.currentMapNodeId!==null&&typeof t.currentMapNodeId!="string")return console.warn("Invalid save data (V3): currentMapNodeId type."),!1;if(t.destinationNodeId!==null&&typeof t.destinationNodeId!="string")return console.warn("Invalid save data (V3): destinationNodeId type."),!1;if(!Nl(t.mapLayoutConfig))return console.warn("Invalid save data (V3): mapLayoutConfig."),!1;if(typeof t.mapViewBox!="string")return console.warn("Invalid save data (V3): mapViewBox type."),!1;if(typeof t.score!="number")return console.warn("Invalid save data (V3): score type."),!1;if(t.localTime!==null&&typeof t.localTime!="string")return console.warn("Invalid save data (V3): localTime type."),!1;if(t.localEnvironment!==null&&typeof t.localEnvironment!="string")return console.warn("Invalid save data (V3): localEnvironment type."),!1;if(t.localPlace!==null&&typeof t.localPlace!="string")return console.warn("Invalid save data (V3): localPlace type."),!1;if(typeof t.globalTurnNumber!="number")return console.warn("Invalid save data(V3): globalTurnNumber type."),!1;const o=["dialogueState"];for(const a of o)if(a in t&&t[a]!==null&&t[a]!==void 0)return console.warn(`Invalid save data (V3): Unexpected dialogue field '${a}' found in SavedGameDataShape. It should be null/undefined here.`),!1;return!0}function Qo(e){const t=Pt();if(e.mapLayoutConfig&&typeof e.mapLayoutConfig=="object"){const n=e.mapLayoutConfig,o={};for(const a of Object.keys(t)){const r=n[a];Object.prototype.hasOwnProperty.call(n,a)&&typeof r=="number"?o[a]=r:o[a]=t[a]}e.mapLayoutConfig=o}else e.mapLayoutConfig=t}function Xo(e){!e||!Array.isArray(e.nodes)||e.nodes.forEach(t=>{t.data||(t.data={}),typeof t.data.description!="string"&&(t.data.description="No description provided."),Array.isArray(t.data.aliases)?t.data.aliases=t.data.aliases.filter(o=>typeof o=="string"):t.data.aliases=[],["undiscovered","discovered","rumored","quest_target","blocked"].includes(t.data.status)||(t.data.status="discovered"),typeof t.data.visited!="boolean"&&(t.data.visited=!1),typeof t.data.isFeature!="boolean"&&(t.data.isFeature=!1)})}function Sl(e){return e.inventory=e.inventory.map(t=>({...t,id:t.id||Va(t.name),tags:t.tags??[],stashed:t.stashed??!1,holderId:t.holderId||ne})),e.allNPCs=e.allNPCs.map(t=>{const n=t;return{...n,id:n.id??Be(n.name??""),aliases:n.aliases??[],presenceStatus:n.presenceStatus??"unknown",lastKnownLocation:n.lastKnownLocation??null,preciseLocation:n.preciseLocation??null,dialogueSummaries:n.dialogueSummaries??[]}}),e.mapViewBox=typeof e.mapViewBox=="string"?e.mapViewBox:Bn,Array.isArray(e.themeFacts)||(e.themeFacts=[]),(!e.worldFacts||!ar(e.worldFacts))&&(e.worldFacts=null),(!e.heroSheet||!rr(e.heroSheet))&&(e.heroSheet=null),(!e.heroBackstory||!sr(e.heroBackstory))&&(e.heroBackstory=null),Array.isArray(e.playerJournal)||(e.playerJournal=[]),typeof e.lastJournalInspectTurn!="number"&&(e.lastJournalInspectTurn=0),typeof e.lastLoreDistillTurn!="number"&&(e.lastLoreDistillTurn=0),e}function Zo(e,t){let n=null;e.saveGameVersion===_e||typeof e.saveGameVersion=="string"&&e.saveGameVersion.startsWith(_e.split(".")[0])?(e.saveGameVersion!==_e&&console.warn(`Potentially compatible future V${_e.split(".")[0]}.x save version '${e.saveGameVersion}' from ${t}. Attempting to treat as current version (V3) for validation.`),n=e,Qo(n),Xo(n.mapData)):(console.warn(`Unknown save version '${String(e.saveGameVersion)}' from ${t}. This might fail validation.`),n=e,Qo(n),Xo(n.mapData));const o=e.currentThemeName;!n.currentTheme&&o&&(n.currentTheme=en(o),n.currentTheme||console.warn(`Failed to find theme "${o}" during ${t} load. Game state might be incomplete.`));const a=e.globalTurnNumber;if(typeof a=="string"){const r=parseInt(a,10);n.globalTurnNumber=isNaN(r)?0:r}else a==null&&(n.globalTurnNumber=0);return n.destinationNodeId=n.destinationNodeId??null,Tl(n)?Sl(n):null}const Al=e=>{const{dialogueState:t,objectiveAnimationType:n,lastDebugPacket:o,lastTurnChanges:a,debugLore:r,debugGoodFacts:s,debugBadFacts:i,isVictory:c,...l}=e,d={nodes:e.mapData.nodes.map(u=>({...u,data:{description:u.data.description||"Description missing in save prep",aliases:u.data.aliases??[],status:u.data.status,isFeature:u.data.isFeature,visited:u.data.visited,parentNodeId:u.data.parentNodeId,nodeType:u.data.nodeType,...Object.fromEntries(Object.entries(u.data).filter(([m])=>!["description","aliases"].includes(m)))}})),edges:e.mapData.edges};return{...l,saveGameVersion:_e,currentTheme:e.currentTheme,inventory:e.inventory.map(u=>({...u,tags:u.tags??[],stashed:u.stashed??!1,holderId:u.holderId||ne})),allNPCs:e.allNPCs.map(u=>({...u,aliases:u.aliases??[],presenceStatus:u.presenceStatus,lastKnownLocation:u.lastKnownLocation,preciseLocation:u.preciseLocation,dialogueSummaries:u.dialogueSummaries??[]})),mapData:d,currentMapNodeId:e.currentMapNodeId,destinationNodeId:e.destinationNodeId,mapLayoutConfig:e.mapLayoutConfig,mapViewBox:e.mapViewBox,score:e.score,localTime:e.localTime,localEnvironment:e.localEnvironment,localPlace:e.localPlace,globalTurnNumber:e.globalTurnNumber,themeFacts:e.themeFacts,worldFacts:e.worldFacts,heroSheet:e.heroSheet,heroBackstory:e.heroBackstory}},ea=e=>{const t={nodes:e.mapData.nodes.map(o=>({...o,data:{...o.data,description:o.data.description||"Description missing on load",aliases:o.data.aliases??[]}})),edges:e.mapData.edges};let n=e.currentTheme;if(!n){const o=e.currentThemeName;o&&(n=en(o),n||console.warn(`expandSavedDataToFullState: Theme "${o}" not found in current definitions. Game may be unstable.`))}return{...e,currentTheme:n,enabledThemePacks:[...an],thinkingEffort:"Medium",allNPCs:e.allNPCs.map(o=>({...o,dialogueSummaries:o.dialogueSummaries??[]})),mapData:t,currentMapNodeId:e.currentMapNodeId,destinationNodeId:e.destinationNodeId,mapLayoutConfig:e.mapLayoutConfig,mapViewBox:e.mapViewBox,globalTurnNumber:e.globalTurnNumber,themeFacts:e.themeFacts,worldFacts:e.worldFacts,heroSheet:e.heroSheet,heroBackstory:e.heroBackstory,debugLore:!1,debugGoodFacts:[],debugBadFacts:[],dialogueState:null,isVictory:!1,objectiveAnimationType:null,lastDebugPacket:null,lastTurnChanges:null}},ta=e=>{const t=Al(e);return t.inventory=t.inventory.map(n=>{var o;return{...n,chapters:(o=n.chapters)==null?void 0:o.map(a=>({...a,imageData:void 0}))}}),t.playerJournal=t.playerJournal.map(n=>({...n,imageData:void 0})),t},ir=e=>({current:ta(e[0]),previous:e[1]?ta(e[1]):null}),cr=e=>[ea(e.current),e.previous?ea(e.previous):void 0];function lr(e,t){const n=e.current;if(!n||typeof n!="object")return null;const o=Zo(n,t);if(!o)return null;const a=e.previous;let r=null;if(a&&typeof a=="object"){const s=Zo(a,t);s&&(r=s)}return{current:o,previous:r}}const Cl=(e,t,n)=>{const o=new Blob([e],{type:n}),a=URL.createObjectURL(o),r=document.createElement("a");r.href=a,r.download=t,document.body.appendChild(r),r.click(),document.body.removeChild(r),URL.revokeObjectURL(a)},El=async(e,t,n)=>{try{const o=await Wo(e[0]),a=e[1]?await Wo(e[1]):void 0,r={},s=l=>{l.inventory.forEach(d=>{var p;(p=d.chapters)==null||p.forEach((u,m)=>{u.imageData&&(r[et(d.id,m)]=u.imageData)})}),l.playerJournal.forEach((d,p)=>{d.imageData&&(r[et(Ve,p)]=d.imageData)})};s(o),a&&s(a);const i=ir(e),c=JSON.stringify({game:i,debug:t,images:r},null,2);return Cl(c,`WhispersInTheDark_Save_V${_e}_${new Date().toISOString().slice(0,10)}.json`,"application/json"),!0}catch(o){return console.error("Error saving game state to file:",o),n&&n("An error occurred while preparing your game data for download."),!1}},Pl=async e=>new Promise(t=>{const n=new FileReader;n.onload=o=>{try{if(o.target&&typeof o.target.result=="string"){const a=ge(o.target.result);if(a===null){t(null);return}const{game:r=a,debug:s,images:i}=a,c=lr(r,"file");if(c){(async()=>{try{const l=cr(c),d=async g=>{const h=Z(g);return i&&(await Promise.all(h.inventory.map(async v=>{var f;await Promise.all(((f=v.chapters)==null?void 0:f.map(async(I,T)=>{const k=et(v.id,T),y=i[k];y&&(await nn(v.id,T,y),I.imageData=It(v.id,T))}))??[])})),await Promise.all(h.playerJournal.map(async(v,f)=>{const I=et(Ve,f),T=i[I];T&&(await nn(Ve,f,T),v.imageData=It(Ve,f))}))),il(h)},p=await d(l[0]),u=l[1]?await d(l[1]):void 0,m=Array.isArray(s)?[s[0]??null,s[1]??null]:[s??null,null];t({gameStateStack:[p,u],debugPacketStack:m})}catch{t(null)}})();return}}console.warn("File save data is invalid or version mismatch for V3. Not loading."),t(null)}catch(a){console.error("Error loading game state from file:",a),t(null)}},n.onerror=()=>{console.error("Error reading file."),t(null)},n.readAsText(e)}),Yn=(e,t)=>{try{const n=ir(e);return localStorage.setItem(Ft,JSON.stringify(n)),!0}catch(n){console.error("Error saving game state to localStorage:",n);const o=n instanceof DOMException&&(n.name==="QuotaExceededError"||n.code===22)?"Could not save game: Browser storage is full. Please clear some space or try saving to a file.":"An unexpected error occurred while trying to automatically save your game.";return t&&t(o),!1}},$l=()=>{try{const e=localStorage.getItem(Ft);if(!e)return null;const t=ge(e);if(t===null)return console.warn("Saved data found in localStorage could not be parsed as JSON."),null;if(typeof t!="object")return console.warn("Saved data found in localStorage is not an object."),null;const n=lr(t,"localStorage");return n?cr(n):(console.warn("Local save data is invalid or version mismatch for V3. Starting new game."),localStorage.removeItem(Ft),localStorage.removeItem(Mt),null)}catch(e){return console.error("Error loading game state from localStorage:",e),localStorage.removeItem(Ft),localStorage.removeItem(Mt),null}},Ml=async()=>{const e=$l();if(!e)return null;const[t,n]=e,o=await Jo(t),a=n?await Jo(n):void 0;return[o,a]},kl=e=>e==="Low"||e==="Medium"||e==="High",Ll=e=>Array.isArray(e)&&e.every(t=>typeof t=="string"),Dl=e=>{try{localStorage.setItem(On,JSON.stringify(e))}catch(t){console.error("Error saving settings to localStorage:",t)}},_l=()=>{const e={enabledThemePacks:[...an],thinkingEffort:"Medium"};try{const t=localStorage.getItem(On);if(!t)return{...e};const n=ge(t);if(!n||typeof n!="object")return console.warn("Saved settings found in localStorage could not be parsed."),{...e};const o={...e};return Ll(n.enabledThemePacks)&&(o.enabledThemePacks=[...n.enabledThemePacks]),kl(n.thinkingEffort)&&(o.thinkingEffort=n.thinkingEffort),o}catch(t){return console.error("Error loading settings from localStorage:",t),localStorage.removeItem(On),{...e}}},Hn=e=>{try{localStorage.setItem(Mt,JSON.stringify(e))}catch(t){console.error("Error saving debug packet stack to localStorage:",t)}},Rl=()=>{try{const e=localStorage.getItem(Mt);if(!e)return null;const t=ge(e);if(Array.isArray(t)){const[n,o]=t;return[n??null,o??null]}return t&&typeof t=="object"?[t,null]:(console.warn("Saved debug stack found in localStorage could not be parsed."),null)}catch(e){return console.error("Error loading debug packet stack from localStorage:",e),localStorage.removeItem(Mt),null}},Gt=e=>{try{localStorage.setItem(Rn,JSON.stringify(e))}catch(t){console.error("Error saving debug lore state to localStorage:",t)}},na=()=>{try{const e=localStorage.getItem(Rn);if(!e)return null;const t=ge(e);if(!t||typeof t!="object"||typeof t.debugLore!="boolean")return console.warn("Saved debug lore data found in localStorage could not be parsed."),null;const n=Array.isArray(t.debugGoodFacts)?[...t.debugGoodFacts]:[],o=Array.isArray(t.debugBadFacts)?[...t.debugBadFacts]:[];return{debugLore:t.debugLore,debugGoodFacts:n,debugBadFacts:o}}catch(e){return console.error("Error loading debug lore state from localStorage:",e),localStorage.removeItem(Rn),null}},Ol=1500,nd=({gatherGameStateStack:e,gatherDebugPacketStack:t,applyLoadedGameState:n,setError:o,setIsLoading:a,isLoading:r=!1,dialogueState:s=null,hasGameBeenInitialized:i=!1})=>{const[c,l]=b.useState([...an]),[d,p]=b.useState("Medium"),[u,m]=b.useState(null),[g,h]=b.useState(null),[v,f]=b.useState(!1);b.useEffect(()=>{(async()=>{const C=await Ml(),$=Rl(),M=na(),A=_l();if(l(A.enabledThemePacks),p(A.thinkingEffort),C){$&&h($),M&&(C[0].debugLore=M.debugLore,C[0].debugGoodFacts=M.debugGoodFacts,C[0].debugBadFacts=M.debugBadFacts);const{thinkingEffort:w,enabledThemePacks:N}=A;C[0].thinkingEffort=w,C[0].enabledThemePacks=N,C[1]&&(C[1].thinkingEffort=w,C[1].enabledThemePacks=N),m(C)}else m(null);f(!0)})()},[]),b.useEffect(()=>{Kr(d),Dl({enabledThemePacks:c,thinkingEffort:d})},[c,d]);const I=b.useRef(null),T=b.useRef(null);b.useEffect(()=>{if(!(r||!i||!v||s))return T.current&&clearTimeout(T.current),T.current=window.setTimeout(()=>{if(e&&t){const C=e(),$=t();Yn(C,o?M=>{o(M)}:void 0),Hn($),Gt({debugLore:C[0].debugLore,debugGoodFacts:C[0].debugGoodFacts,debugBadFacts:C[0].debugBadFacts})}},Ol),()=>{T.current&&clearTimeout(T.current)}},[e,t,r,i,v,s,o]);const k=b.useCallback(async()=>{if(r||s){o==null||o("Cannot save to file while loading or in dialogue.");return}if(e&&t){const C=e(),$=t();await El(C,$,o?M=>{o(M)}:void 0)}},[e,t,r,s,o]),y=()=>{var C;if(r||s){o==null||o("Cannot load from file while another operation is in progress or while in dialogue.");return}(C=I.current)==null||C.click()},P=async C=>{var M;if(r||s){o==null||o("Cannot load from file while another operation is in progress or while in dialogue."),C.target.value="";return}const $=(M=C.target.files)==null?void 0:M[0];if($){a==null||a(!0),o==null||o(null),await nr();const A=await Pl($);if(A){const{gameStateStack:w,debugPacketStack:N}=A,L=[{...w[0],enabledThemePacks:c,thinkingEffort:d},w[1]?{...w[1],enabledThemePacks:c,thinkingEffort:d}:void 0],D=na();D&&(L[0].debugLore=D.debugLore,L[0].debugGoodFacts=D.debugGoodFacts,L[0].debugBadFacts=D.debugBadFacts),n&&await n({savedStateToLoad:L}),Yn(L,o?x=>{o(x)}:void 0),Hn(N),Gt(D||{debugLore:L[0].debugLore,debugGoodFacts:L[0].debugGoodFacts,debugBadFacts:L[0].debugBadFacts})}else o==null||o("Failed to load game from file. The file might be corrupted, an incompatible version, or not a valid save file.");a==null||a(!1)}C.target.value=""};return{enabledThemePacks:c,setEnabledThemePacks:l,thinkingEffort:d,setThinkingEffort:p,initialSavedState:u,initialDebugStack:g,appReady:v,fileInputRef:I,handleSaveToFile:k,handleLoadFromFileClick:y,handleFileInputChange:C=>{P(C)}}},od=()=>{const[e,t]=b.useState(!1),[n,o]=b.useState(null),[a,r]=b.useState(null),[s,i]=b.useState(!1),[c,l]=b.useState(!1),[d,p]=b.useState(!1),[u,m]=b.useState(!1),[g,h]=b.useState(!1),[v,f]=b.useState(!1),[I,T]=b.useState(!1),[k,y]=b.useState(!1),[P,S]=b.useState(!1),[C,$]=b.useState(!1),[M,A]=b.useState(!1),[w,N]=b.useState(null),[L,D]=b.useState(0),[x,K]=b.useState(!1),[le,j]=b.useState(!1),[ye,ue]=b.useState([]),de=b.useRef(null),[U,F]=b.useState(!1),[q,E]=b.useState("Male"),_=b.useRef(null),[R,G]=b.useState(!1),[V,H]=b.useState(null),B=b.useRef(null),J=b.useRef(null),ce=b.useCallback(()=>{t(!0)},[]),pe=b.useCallback(()=>{t(!1)},[]),Ie=b.useCallback(()=>{i(!0)},[]),me=b.useCallback(()=>{i(!1)},[]),Oe=b.useCallback(()=>{m(!0)},[]),Ye=b.useCallback(()=>{m(!1)},[]),ve=b.useCallback(()=>{l(!0)},[]),xe=b.useCallback(()=>{l(!1)},[]),ot=b.useCallback(()=>{p(!0)},[]),at=b.useCallback(()=>{p(!1)},[]),rt=b.useCallback(()=>{h(!0)},[]),te=b.useCallback(()=>{h(!1)},[]),Ce=b.useCallback(()=>{T(!1)},[]),Nt=b.useCallback(()=>{y(!0)},[]),bt=b.useCallback(()=>{y(!1)},[]),Tt=b.useCallback(()=>{S(!0)},[]),st=b.useCallback(()=>{S(!1)},[]),St=b.useCallback(()=>{$(!0)},[]),Je=b.useCallback(()=>{$(!1)},[]),it=b.useCallback(()=>{A(!0)},[]),gn=b.useCallback(()=>{A(!1)},[]),hn=b.useCallback((we,Te=0)=>{N(we),D(Te),K(!0)},[]),fn=b.useCallback(()=>{K(!1),N(null),D(0),$a()},[]),yn=b.useCallback((we,Te)=>{ue(we),de.current=Te,j(!0)},[]),Ot=b.useCallback((we,Te,O)=>{var z;(z=de.current)==null||z.call(de,we,Te,O),j(!1)},[]),vn=b.useCallback(()=>{var we;(we=de.current)==null||we.call(de,[],[],!1),j(!1)},[]),wn=b.useCallback((we,Te)=>{E(we),_.current=Te,F(!0)},[]),Y=b.useCallback(we=>{var Te;(Te=_.current)==null||Te.call(_,we),F(!1)},[]),In=b.useCallback((we,Te,O)=>{H(we),J.current=Te,B.current=O,G(!0)},[]),At=b.useCallback(we=>{var Te;return((Te=J.current)==null?void 0:Te.call(J,we))??Promise.resolve()},[]),Ct=b.useCallback(()=>{var we;(we=B.current)==null||we.call(B),G(!1),H(null)},[]);return{isVisualizerVisible:e,visualizerImageUrl:n,visualizerImageScene:a,isKnowledgeBaseVisible:s,isSettingsVisible:c,isInfoVisible:d,isMapVisible:u,userRequestedTitleMenuOpen:g,shouldReturnToTitleMenu:v,isDebugViewVisible:I,isCustomGameSetupVisible:k,shiftConfirmOpen:P,newGameFromMenuConfirmOpen:C,loadGameFromMenuConfirmOpen:M,pageItemId:w,pageStartChapterIndex:L,isPageVisible:x,isCharacterSelectVisible:R,characterSelectData:V,setVisualizerImageUrl:o,setVisualizerImageScene:r,setShouldReturnToTitleMenu:f,setIsDebugViewVisible:T,openVisualizer:ce,closeVisualizer:pe,openKnowledgeBase:Ie,closeKnowledgeBase:me,openMap:Oe,closeMap:Ye,openSettings:ve,closeSettings:xe,openInfo:ot,closeInfo:at,openTitleMenu:rt,closeTitleMenu:te,closeDebugView:Ce,openCustomGameSetup:Nt,closeCustomGameSetup:bt,openShiftConfirm:Tt,closeShiftConfirm:st,openNewGameFromMenuConfirm:St,closeNewGameFromMenuConfirm:Je,openLoadGameFromMenuConfirm:it,closeLoadGameFromMenuConfirm:gn,openPageView:hn,closePageView:fn,isDebugLoreVisible:le,debugLoreFacts:ye,openDebugLoreModal:yn,submitDebugLoreModal:Ot,closeDebugLoreModal:vn,isGenderSelectVisible:U,genderSelectDefault:q,openGenderSelectModal:wn,submitGenderSelectModal:Y,openCharacterSelectModal:In,submitCharacterSelectModal:Ct,submitCharacterSelectHeroData:At}},xl=1500;function ad({appReady:e,dependencies:t,dialogueState:n,gatherDebugPacketStack:o,gatherGameStateStack:a,hasGameBeenInitialized:r,isLoading:s,isTurnProcessing:i,setError:c}){const l=b.useRef(null),d=JSON.stringify(t);b.useEffect(()=>{if(!(s||i||!r||!e||n))return l.current&&clearTimeout(l.current),l.current=window.setTimeout(()=>{const p=a(),u=o();Yn(p,c?m=>{c(m)}:void 0),Hn(u),Gt({debugLore:p[0].debugLore,debugGoodFacts:p[0].debugGoodFacts,debugBadFacts:p[0].debugBadFacts})},xl),()=>{l.current&&clearTimeout(l.current)}},[a,o,s,r,e,n,d,i,c])}export{Gc as A,Yc as B,tn as C,ha as D,on as E,nn as F,It as G,xa as H,be as I,nd as J,od as K,ql as L,Gt as M,ad as N,un as O,Kl as P,Oa as Q,Gn as T,Or as a,Ql as b,Xl as c,Hl as d,Zl as e,Jl as f,Bl as g,Qa as h,ee as i,ed as j,td as k,Yl as l,zn as m,Qn as n,Na as o,Lr as p,re as q,ln as r,Wl as s,ie as t,zl as u,se as v,nt as w,mt as x,Ho as y,Fc as z};
